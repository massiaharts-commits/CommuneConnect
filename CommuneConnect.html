<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>CommuneCollab
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net;
    style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;
    font-src 'self' https://fonts.gstatic.com;
    img-src 'self' data: https: blob:;
    connect-src 'self' https://*.supabase.co https://jsonlink.io https://image.thum.io https://nominatim.openstreetmap.org https://img.youtube.com https://www.google.com;
    frame-src 'none';
    object-src 'none';
    base-uri 'self';
  ">
  </title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    :root {
      --bg-primary: #0d0d0f;
      --bg-secondary: #141418;
      --bg-card: rgba(255, 255, 255, 0.03);
      --bg-card-hover: rgba(255, 255, 255, 0.06);
      --bg-elevated: rgba(255, 255, 255, 0.05);
      --border-subtle: rgba(255, 255, 255, 0.08);
      --border-medium: rgba(255, 255, 255, 0.12);
      --accent: #6366f1;
      --accent-2: #8b5cf6;
      --accent-glow: rgba(99, 102, 241, 0.3);
      --gradient: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      --success: #10b981;
      --warning: #f59e0b;
      --danger: #ef4444;
      --text-1: #f4f4f5;
      --text-2: #a1a1aa;
      --text-3: #71717a;
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
    }
    html { scroll-behavior: smooth; }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
      background: var(--bg-primary);
      color: var(--text-1);
      min-height: 100vh;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
    }
    body::before {
      content: '';
      position: fixed;
      inset: 0;
      background: 
        radial-gradient(ellipse 60% 40% at 20% 20%, rgba(99, 102, 241, 0.12) 0%, transparent 50%),
        radial-gradient(ellipse 50% 50% at 80% 30%, rgba(236, 72, 153, 0.08) 0%, transparent 40%),
        radial-gradient(ellipse 70% 50% at 70% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 50%),
        radial-gradient(ellipse 40% 40% at 10% 70%, rgba(245, 158, 11, 0.06) 0%, transparent 40%);
      pointer-events: none;
      z-index: 0;
      animation: bodyGradientShift 20s ease-in-out infinite;
    }
    
    @keyframes bodyGradientShift {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    /* Personal star field for main view */
    body::after {
      content: '';
      position: fixed;
      inset: 0;
      background-image: 
        radial-gradient(1px 1px at 10% 15%, rgba(255,255,255,0.4) 50%, transparent 50%),
        radial-gradient(1px 1px at 25% 35%, rgba(255,255,255,0.3) 50%, transparent 50%),
        radial-gradient(1.5px 1.5px at 40% 10%, rgba(255,255,255,0.5) 50%, transparent 50%),
        radial-gradient(1px 1px at 55% 45%, rgba(255,255,255,0.25) 50%, transparent 50%),
        radial-gradient(1px 1px at 70% 20%, rgba(255,255,255,0.35) 50%, transparent 50%),
        radial-gradient(1.5px 1.5px at 85% 55%, rgba(255,255,255,0.4) 50%, transparent 50%),
        radial-gradient(1px 1px at 15% 65%, rgba(255,255,255,0.3) 50%, transparent 50%),
        radial-gradient(1px 1px at 30% 80%, rgba(255,255,255,0.25) 50%, transparent 50%),
        radial-gradient(1.5px 1.5px at 50% 70%, rgba(255,255,255,0.35) 50%, transparent 50%),
        radial-gradient(1px 1px at 65% 85%, rgba(255,255,255,0.3) 50%, transparent 50%),
        radial-gradient(1px 1px at 80% 75%, rgba(255,255,255,0.4) 50%, transparent 50%),
        radial-gradient(1px 1px at 95% 40%, rgba(255,255,255,0.25) 50%, transparent 50%),
        radial-gradient(1.5px 1.5px at 5% 90%, rgba(255,255,255,0.3) 50%, transparent 50%),
        radial-gradient(1px 1px at 45% 25%, rgba(255,255,255,0.35) 50%, transparent 50%),
        radial-gradient(1px 1px at 75% 5%, rgba(255,255,255,0.3) 50%, transparent 50%),
        radial-gradient(2px 2px at 20% 50%, rgba(245, 158, 11, 0.4) 50%, transparent 50%),
        radial-gradient(2px 2px at 60% 60%, rgba(236, 72, 153, 0.3) 50%, transparent 50%),
        radial-gradient(2px 2px at 90% 25%, rgba(99, 102, 241, 0.35) 50%, transparent 50%);
      pointer-events: none;
      z-index: 0;
      animation: starsTwinkle 8s ease-in-out infinite;
    }
    
    @keyframes starsTwinkle {
      0%, 100% { opacity: 0.6; }
      25% { opacity: 0.8; }
      50% { opacity: 0.5; }
      75% { opacity: 0.9; }
    }
    .header {
      position: sticky;
      top: 0;
      z-index: 100;
      background: rgba(13, 13, 15, 0.85);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border-subtle);
    }
    .header-main {
      max-width: 1400px;
      margin: 0 auto;
      padding: 1rem 1.25rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 1rem;
    }
    .logo h1 {
      font-size: 1.25rem;
      font-weight: 700;
      background: var(--gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    .logo-sub { font-size: 0.7rem; color: var(--text-3); margin-top: 2px; }
    .header-actions { display: flex; gap: 0.5rem; align-items: center; }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.625rem 1rem;
      border-radius: var(--radius-md);
      font-size: 0.875rem;
      font-weight: 500;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 1px solid transparent;
      white-space: nowrap;
    }
    .btn-icon {
      width: 40px; height: 40px; padding: 0;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      color: var(--text-2);
      border-radius: var(--radius-md);
    }
    .btn-icon:hover { background: var(--bg-card-hover); color: var(--text-1); }
    .btn-primary {
      background: var(--gradient);
      color: white;
      border: none;
      box-shadow: 0 4px 16px var(--accent-glow);
    }
    .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 6px 20px var(--accent-glow); }
    .btn-secondary {
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      color: var(--text-1);
    }
    .btn-secondary:hover { background: var(--bg-card-hover); border-color: var(--border-medium); }
    .btn-ghost { background: transparent; color: var(--text-2); }
    .btn-ghost:hover { background: var(--bg-elevated); color: var(--text-1); }
    .btn-danger {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid rgba(239, 68, 68, 0.3);
      color: var(--danger);
    }
    .btn-danger:hover { background: rgba(239, 68, 68, 0.2); }
    .btn-add { width: 44px; height: 44px; font-size: 1.5rem; padding: 0; }
    .header-expand {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 1.25rem;
      max-height: 500px;
      overflow: hidden;
      transition: max-height 0.25s ease;
    }
    
    .btn-add {
      width: 52px;
      height: 52px;
      font-size: 1.75rem;
      padding: 0;
      position: relative;
      overflow: visible;
      border-radius: 16px;
      animation: addBtnFloat 3s ease-in-out infinite;
    }
    
    .btn-add:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 0 8px 30px rgba(99, 102, 241, 0.5);
    }
    
    .btn-add:active {
      transform: scale(0.95);
    }
    
    @keyframes addBtnFloat {
      0%, 100% { box-shadow: 0 4px 16px var(--accent-glow); }
      50% { box-shadow: 0 6px 24px rgba(99, 102, 241, 0.5); }
    }
    
    .add-btn-icon {
      position: relative;
      z-index: 2;
      font-weight: 300;
    }
    
    .add-btn-pulse {
      position: absolute;
      inset: -4px;
      border-radius: 20px;
      border: 2px solid var(--accent);
      opacity: 0;
      animation: addBtnPulse 2s ease-out infinite;
    }
    
    @keyframes addBtnPulse {
      0% { transform: scale(0.9); opacity: 0.7; }
      100% { transform: scale(1.3); opacity: 0; }
    }
    
    /* Sync button states */
    #editSyncBtn {
      transition: all 0.2s ease;
    }

    #editSyncBtn:not([disabled]):hover {
      background: rgba(6, 182, 212, 0.2);
      border-color: rgba(6, 182, 212, 0.5);
      color: #06b6d4;
    }

    #editSyncBtn[disabled] {
      cursor: wait;
      animation: syncPulse 1s ease-in-out infinite;
    }

    @keyframes syncPulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
    
    /* Tooltip styling */
    .btn-add::after {
      content: 'Share something!';
      position: absolute;
      bottom: -35px;
      left: 50%;
      transform: translateX(-50%) scale(0.9);
      background: var(--bg-secondary);
      border: 1px solid var(--border-medium);
      padding: 0.4rem 0.75rem;
      border-radius: var(--radius-sm);
      font-size: 0.75rem;
      font-weight: 500;
      white-space: nowrap;
      opacity: 0;
      pointer-events: none;
      transition: all 0.2s ease;
      z-index: 1000;
    }
    
    .btn-add:hover::after {
      opacity: 1;
      transform: translateX(-50%) scale(1);
      bottom: -40px;
    }
    
    .header-expand.collapsed { max-height: 0; }
    .header-expand-inner { padding: 1rem 0; display: flex; flex-direction: column; gap: 1rem; }
    .search-box { position: relative; }
    .search-input {
      width: 100%;
      padding: 0.75rem 1rem 0.75rem 2.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      color: var(--text-1);
      font-size: 0.9rem;
      font-family: inherit;
    }
    .search-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }
    .search-input::placeholder { color: var(--text-3); }
    .search-icon {
      position: absolute;
      left: 1rem;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-3);
    }
    .filter-row { display: flex; gap: 0.5rem; flex-wrap: wrap; align-items: center; }
    .filter-select {
      padding: 0.5rem 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      color: var(--text-1);
      font-size: 0.8rem;
      font-family: inherit;
      cursor: pointer;
    }
    .filter-select option {
      background: #1a1a1f;
      color: #f4f4f5;
      padding: 0.5rem;
    }
    .chips { display: flex; gap: 0.5rem; overflow-x: auto; padding: 0.25rem 0; scrollbar-width: none; }
    .chips::-webkit-scrollbar { display: none; }
    .chip {
      padding: 0.5rem 1rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-xl);
      font-size: 0.8rem;
      color: var(--text-2);
      white-space: nowrap;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    .chip:hover { background: var(--bg-card-hover); color: var(--text-1); }
    .chip.active { background: var(--gradient); border-color: transparent; color: white; font-weight: 500; }
    .sort-tabs {
      display: flex;
      gap: 0.25rem;
      background: var(--bg-elevated);
      padding: 0.25rem;
      border-radius: var(--radius-md);
      width: fit-content;
    }
    .sort-tab {
      padding: 0.5rem 1rem;
      background: transparent;
      border: none;
      border-radius: var(--radius-sm);
      color: var(--text-2);
      font-size: 0.8rem;
      font-family: inherit;
      cursor: pointer;
    }
    .sort-tab:hover { color: var(--text-1); }
    .sort-tab.active { background: var(--bg-card-hover); color: var(--text-1); font-weight: 500; }
    .action-bar { display: flex; gap: 0.5rem; flex-wrap: wrap; }
    .action-bar .btn { flex: 1; min-width: 100px; font-size: 0.75rem; padding: 0.5rem 0.75rem; }
    .collapse-toggle {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.5rem;
      background: transparent;
      border: none;
      border-top: 1px solid var(--border-subtle);
      color: var(--text-3);
      font-size: 0.75rem;
      font-family: inherit;
      cursor: pointer;
      width: 100%;
    }
   .grid {
      max-width: 1400px;
      margin: 0 auto;
      padding: 1.5rem 1.25rem;
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      gap: 1.25rem;
      position: relative;
      z-index: 2;
      align-items: start;
    }
    @media (max-width: 640px) { .grid { grid-template-columns: 1fr; padding: 1rem; } }
    .card {
	  background: var(--bg-card);
	  border: 1px solid var(--border-subtle);
	  border-radius: var(--radius-lg);
	  overflow: hidden;
	  cursor: pointer;
	  transition: all 0.25s ease;
	  position: relative;
	  display: flex;
	  flex-direction: column;
	}
    .card:hover {
      background: var(--bg-card-hover);
      border-color: var(--border-medium);
      transform: translateY(-4px);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }
    .card-image {
      width: 100%;
      height: 180px;
      overflow: hidden;
      background: var(--bg-secondary);
      position: relative;
    }
    .card-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.25s ease;
    }
    .card:hover .card-image img { transform: scale(1.02); }
    .card-badges {
      position: absolute;
      top: 0.75rem;
      left: 0.75rem;
      right: 0.75rem;
      display: flex;
      justify-content: space-between;
      pointer-events: none;
    }
    .badge {
      padding: 0.25rem 0.5rem;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(8px);
      border-radius: var(--radius-sm);
      font-size: 0.7rem;
      font-weight: 500;
      color: white;
    }
    .badge-vote { background: rgba(16, 185, 129, 0.9); }
    .badge-vote.negative { background: rgba(239, 68, 68, 0.9); }
    .card-star {
      position: absolute;
      top: 0.75rem;
      right: 0.75rem;
      width: 32px; height: 32px;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      border: none;
      border-radius: var(--radius-sm);
      color: var(--text-2);
      font-size: 1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 5;
    }
    .card-star:hover { background: rgba(0, 0, 0, 0.8); color: var(--warning); }
    .card-star.active { color: var(--warning); }
    .card-content { padding: 1rem; flex: 1; display: flex; flex-direction: column; }
    .card-title {
      font-size: 1rem;
      font-weight: 600;
      margin-bottom: 0.375rem;
      line-height: 1.4;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .card-url {
      font-size: 0.75rem;
      color: var(--text-3);
      margin-bottom: 0.5rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .card-notes {
      font-size: 0.8rem;
      color: var(--text-2);
      margin-bottom: 0.75rem;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }
    .card-tags { display: flex; flex-wrap: wrap; gap: 0.375rem; margin-bottom: 0.75rem; }
    .tag {
      padding: 0.2rem 0.5rem;
      background: rgba(99, 102, 241, 0.15);
      border-radius: var(--radius-sm);
      font-size: 0.7rem;
      color: var(--accent);
      font-weight: 500;
    }
    .card-meta {
	  display: flex;
	  align-items: center;
	  justify-content: space-between;
	  font-size: 0.7rem;
	  color: var(--text-3);
	  margin-top: auto;
	}
    .card-location {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      padding: 0.25rem 0.5rem;
      background: rgba(16, 185, 129, 0.1);
      border-radius: var(--radius-sm);
      color: var(--success);
      font-size: 0.7rem;
      margin-bottom: 0.5rem;
    }
    .card-footer {
	  display: flex;
	  gap: 0.5rem;
	  padding: 0.75rem 1rem;
	  background: rgba(0, 0, 0, 0.2);
	  border-top: 1px solid var(--border-subtle);
	  margin-top: auto;
	}
    .card-footer .btn { flex: 1; padding: 0.5rem; font-size: 0.7rem; }
    .card.compact { display: flex; align-items: center; padding: 0.75rem 1rem; }
    .card.compact .card-image,
    .card.compact .card-notes,
    .card.compact .card-tags,
    .card.compact .card-location,
    .card.compact .card-url { display: none; }
    .card.compact .card-content { flex: 1; padding: 0; display: flex; align-items: center; gap: 0.75rem; }
    .card.compact .card-title { flex: 1; margin: 0; }
    .collection-badges { display: flex; flex-wrap: wrap; gap: 0.25rem; margin-top: 0.5rem; }
    .collection-badge { padding: 0.15rem 0.4rem; border-radius: 4px; font-size: 0.6rem; font-weight: 500; }
    .empty-state { grid-column: 1 / -1; text-align: center; padding: 4rem 2rem; }
    .empty-icon { font-size: 4rem; margin-bottom: 1.5rem; opacity: 0.5; }
    .empty-state h2 { font-size: 1.5rem; font-weight: 600; margin-bottom: 0.5rem; }
    .empty-state p { color: var(--text-2); margin-bottom: 1.5rem; }
    .modal {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      z-index: 1000;
      padding: 1rem;
      overflow-y: auto;
    }
    .modal.active { display: flex; align-items: center; justify-content: center; animation: fadeIn 0.2s ease; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    .modal-content {
      background: var(--bg-secondary);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-xl);
      padding: 1.5rem;
      max-width: 500px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 16px 48px rgba(0,0,0,0.4);
      animation: slideUp 0.3s ease;
    }
    @keyframes slideUp { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
    .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; }
    .modal-title { font-size: 1.25rem; font-weight: 600; }
    .modal-close {
      width: 36px; height: 36px;
      background: var(--bg-elevated);
      border: none;
      border-radius: var(--radius-sm);
      color: var(--text-2);
      font-size: 1.25rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* ========== EDIT MODAL - MEDIA FOCUSED LAYOUT ========== */
    .modal-content.edit-modal {
      max-width: 1100px;
      max-height: 90vh;
      padding: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: linear-gradient(135deg, var(--bg-secondary) 0%, rgba(20, 20, 24, 0.98) 100%);
      border: 1px solid var(--border-medium);
    }

    .edit-modal .modal-header {
      padding: 1rem 1.5rem;
      border-bottom: 1px solid var(--border-subtle);
      flex-shrink: 0;
      background: rgba(0, 0, 0, 0.2);
    }

    /* Main Layout - Side by side like YouTube */
    .edit-media-layout {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Left Column - Media Player */
    .edit-media-column {
      flex: 1.4;
      display: flex;
      flex-direction: column;
      border-right: 1px solid var(--border-subtle);
      overflow-y: auto;
    }

    /* Media Container */
    .edit-media-container {
      position: relative;
      background: #000;
      width: 100%;
    }

    .edit-media-player {
      width: 100%;
      aspect-ratio: 16/9;
      display: none;
    }

    .edit-media-player.active {
      display: block;
    }

    .edit-media-player iframe,
    .edit-media-player video,
    .edit-media-player audio {
      width: 100%;
      height: 100%;
      border: none;
    }

    .edit-media-player audio {
      height: 60px;
      margin-top: 40%;
    }

    .edit-media-thumbnail {
      width: 100%;
      aspect-ratio: 16/9;
      position: relative;
      cursor: pointer;
      overflow: hidden;
      background: var(--bg-elevated);
    }

    .edit-media-thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.3s ease;
    }

    .edit-media-thumbnail:hover img {
      transform: scale(1.02);
    }

    .edit-media-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.2s ease;
      color: white;
      font-size: 0.85rem;
      gap: 0.5rem;
    }

    .edit-media-thumbnail:hover .edit-media-overlay {
      opacity: 1;
    }

    .edit-media-play-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 72px;
      height: 72px;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid white;
      border-radius: 50%;
      color: white;
      font-size: 1.75rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      padding-left: 4px;
    }

    .edit-media-play-btn:hover {
      background: var(--accent);
      border-color: var(--accent);
      transform: translate(-50%, -50%) scale(1.1);
    }

    /* Media Info Section */
    .edit-media-info {
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border-subtle);
    }

    .edit-title-input {
      font-size: 1.2rem;
      font-weight: 600;
      background: transparent;
      border: none;
      color: var(--text-1);
      padding: 0.25rem 0;
      width: 100%;
      border-bottom: 2px solid transparent;
      transition: border-color 0.2s ease;
    }

    .edit-title-input:focus {
      outline: none;
      border-bottom-color: var(--accent);
    }

    .edit-url-display {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: var(--accent);
      text-decoration: none;
      margin-top: 0.5rem;
      word-break: break-all;
    }

    .edit-url-display:hover {
      text-decoration: underline;
    }

    /* Votes Row */
    .edit-votes-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.875rem 1.25rem;
      border-bottom: 1px solid var(--border-subtle);
      background: rgba(0, 0, 0, 0.1);
    }

    .edit-vote-btn {
      width: 44px;
      height: 44px;
      border-radius: var(--radius-md);
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      color: var(--text-2);
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .edit-vote-btn:hover {
      border-color: var(--accent);
      color: var(--text-1);
      transform: scale(1.05);
    }

    .edit-vote-btn.upvote:hover,
    .edit-vote-btn.upvote.active {
      background: rgba(16, 185, 129, 0.2);
      border-color: var(--success);
      color: var(--success);
    }

    .edit-vote-btn.downvote:hover,
    .edit-vote-btn.downvote.active {
      background: rgba(239, 68, 68, 0.2);
      border-color: var(--danger);
      color: var(--danger);
    }

    .edit-vote-score {
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-1);
      min-width: 50px;
      text-align: center;
    }

    .edit-actions-quick {
      margin-left: auto;
      display: flex;
      gap: 0.5rem;
    }

    .edit-actions-quick .btn-icon {
      width: 38px;
      height: 38px;
      font-size: 1rem;
    }

    /* Tags Bar */
    .edit-tags-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      padding: 0.875rem 1.25rem;
      align-items: center;
      border-bottom: 1px solid var(--border-subtle);
    }

    .edit-tags-bar .tag {
      padding: 0.35rem 0.6rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-xl);
      font-size: 0.75rem;
      color: var(--text-2);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .edit-tags-bar .tag:hover {
      background: rgba(239, 68, 68, 0.2);
      border-color: var(--danger);
      color: var(--danger);
    }

    .edit-tag-input {
      padding: 0.35rem 0.6rem;
      background: transparent;
      border: 1px dashed var(--border-subtle);
      border-radius: var(--radius-xl);
      color: var(--text-2);
      font-size: 0.75rem;
      min-width: 100px;
      transition: all 0.2s ease;
    }

    .edit-tag-input:focus {
      outline: none;
      border-color: var(--accent);
      border-style: solid;
      background: var(--bg-elevated);
    }

    /* Right Column - Info & Comments */
    .edit-info-column {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-width: 320px;
    }

    /* Sections */
    .edit-section {
      border-bottom: 1px solid var(--border-subtle);
    }

    .edit-section-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.75rem 1.25rem;
      cursor: pointer;
      transition: background 0.2s ease;
    }

    .edit-section-header:hover {
      background: rgba(255, 255, 255, 0.02);
    }

    .edit-section-header.collapsed .edit-section-toggle {
      transform: rotate(-90deg);
    }

    .edit-section-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-1);
    }

    .edit-section-toggle {
      color: var(--text-3);
      font-size: 0.7rem;
      transition: transform 0.2s ease;
    }

    .edit-section-content {
      padding: 0 1.25rem 1rem;
    }

    .edit-section-content.collapsed {
      display: none;
    }

    .edit-section-content textarea {
      width: 100%;
      min-height: 100px;
      padding: 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      color: var(--text-1);
      font-size: 0.875rem;
      font-family: inherit;
      resize: vertical;
      line-height: 1.5;
    }

    .edit-section-content textarea:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Photo Grid */
    .edit-photo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
      gap: 0.5rem;
    }

    .edit-photo-item {
      aspect-ratio: 1;
      border-radius: var(--radius-sm);
      overflow: hidden;
      position: relative;
    }

    .edit-photo-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .edit-photo-delete {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: rgba(0, 0, 0, 0.7);
      border: none;
      border-radius: 50%;
      color: white;
      font-size: 0.7rem;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .edit-photo-item:hover .edit-photo-delete {
      opacity: 1;
    }

    .edit-photo-add {
      aspect-ratio: 1;
      border: 2px dashed var(--border-subtle);
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.5rem;
      color: var(--text-3);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .edit-photo-add:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(99, 102, 241, 0.1);
    }

    /* Location Row */
    .edit-location-row {
      display: flex;
      gap: 0.5rem;
    }

    .edit-location-row input {
      flex: 1;
      padding: 0.6rem 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      color: var(--text-1);
      font-size: 0.875rem;
    }

    .edit-location-row input:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Comments Section */
    .edit-comments-section {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 200px;
    }

    .edit-comments-header {
      padding: 0.75rem 1.25rem;
      border-bottom: 1px solid var(--border-subtle);
      background: rgba(0, 0, 0, 0.1);
    }

    .edit-comments-title {
      font-size: 0.9rem;
      font-weight: 600;
      color: var(--text-1);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .edit-comments-count {
      background: var(--accent);
      color: white;
      font-size: 0.7rem;
      padding: 0.15rem 0.5rem;
      border-radius: var(--radius-xl);
    }

    .edit-comments-list {
      flex: 1;
      overflow-y: auto;
      padding: 1rem 1.25rem;
    }

    .edit-comments-empty {
      text-align: center;
      padding: 2rem 1rem;
      color: var(--text-3);
    }

    .edit-comments-empty-icon {
      font-size: 2.5rem;
      margin-bottom: 0.75rem;
      opacity: 0.5;
    }

    .edit-comment {
      padding: 0.75rem;
      background: var(--bg-elevated);
      border-radius: var(--radius-md);
      margin-bottom: 0.75rem;
    }

    .edit-comment:last-child {
      margin-bottom: 0;
    }

    .edit-comment-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
    }

    .edit-comment-author {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .edit-comment-avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      background: var(--gradient);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      font-weight: 600;
      color: white;
    }

    .edit-comment-name {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-1);
    }

    .edit-comment-time {
      font-size: 0.7rem;
      color: var(--text-3);
    }

    .edit-comment-delete {
      background: transparent;
      border: none;
      color: var(--text-3);
      font-size: 0.8rem;
      cursor: pointer;
      padding: 0.25rem;
      border-radius: var(--radius-sm);
      opacity: 0;
      transition: all 0.15s ease;
    }

    .edit-comment:hover .edit-comment-delete {
      opacity: 1;
    }

    .edit-comment-delete:hover {
      color: var(--danger);
      background: rgba(239, 68, 68, 0.1);
    }

    .edit-comment-text {
      font-size: 0.85rem;
      color: var(--text-2);
      line-height: 1.5;
    }

    /* Comment Input */
    .edit-comment-input-area {
      padding: 1rem 1.25rem;
      border-top: 1px solid var(--border-subtle);
      background: rgba(0, 0, 0, 0.2);
    }

    .edit-comment-input-row {
      display: flex;
      gap: 0.75rem;
    }

    .edit-comment-input {
      flex: 1;
      padding: 0.75rem 1rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-xl);
      color: var(--text-1);
      font-size: 0.875rem;
      font-family: inherit;
    }

    .edit-comment-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }

    .edit-comment-submit {
      padding: 0.75rem 1.25rem;
      background: var(--gradient);
      border: none;
      border-radius: var(--radius-xl);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .edit-comment-submit:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px var(--accent-glow);
    }

    /* Footer */
    .edit-modal-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.875rem 1.5rem;
      border-top: 1px solid var(--border-subtle);
      background: rgba(0, 0, 0, 0.3);
      flex-shrink: 0;
    }

    .edit-footer-left {
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .edit-privacy-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-2);
      cursor: pointer;
    }

    .edit-privacy-toggle input {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }

    .edit-footer-meta {
      font-size: 0.75rem;
      color: var(--text-3);
    }

    /* ========== MOBILE RESPONSIVE - EDIT MODAL ========== */
    @media (max-width: 768px) {
      .modal-content.edit-modal {
        max-height: 100vh;
        border-radius: var(--radius-lg) var(--radius-lg) 0 0;
      }
      
      .edit-media-layout {
        flex-direction: column;
      }
      
      .edit-media-column {
        border-right: none;
        border-bottom: 1px solid var(--border-subtle);
      }
      
      .edit-media-thumbnail {
        aspect-ratio: 16/10;
      }
      
      .edit-media-info {
        padding: 0.875rem 1rem;
      }
      
      .edit-title-input {
        font-size: 1.05rem;
      }
      
      .edit-votes-row {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
      }
      
      .edit-vote-btn {
        width: 48px;
        height: 48px;
      }
      
      .edit-actions-quick {
        width: 100%;
        justify-content: flex-end;
        margin-top: 0.5rem;
      }
      
      .edit-tags-bar {
        padding: 0.75rem 1rem;
      }
      
      .edit-info-column {
        min-width: unset;
        max-height: 50vh;
        overflow-y: auto;
      }
      
      .edit-section-content textarea {
        min-height: 80px;
        font-size: 16px !important;
      }
      
      .edit-comment-input {
        font-size: 16px !important;
      }
      
      .edit-modal-footer {
        flex-direction: column;
        gap: 0.75rem;
        padding: 0.75rem 1rem calc(0.75rem + env(safe-area-inset-bottom));
      }
      
      .edit-footer-left,
      .edit-footer-right {
        width: 100%;
        justify-content: space-between;
      }
      
      /* Always show delete buttons on touch */
      .edit-photo-delete,
      .edit-comment-delete {
        opacity: 1 !important;
      }
    }
    /* Location with inline button */
    .location-input-row {
      display: flex;
      gap: 0.5rem;
    }
    
    .location-input-row .form-input {
      flex: 1;
    }
    
    .location-input-row .btn {
      padding: 0.6rem 0.75rem;
      font-size: 0.8rem;
      white-space: nowrap;
    }
    
    /* Compact Vote Row */
    .edit-vote-row {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0;
    }
    
    .edit-vote-row .vote-btn {
      width: 44px;
      height: 44px;
      font-size: 1.1rem;
    }
    
    .edit-vote-row .vote-score {
      font-size: 1.5rem;
      font-weight: 700;
      min-width: 60px;
      text-align: center;
    }
    
    /* Tags Section */
    .edit-tags-section {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    
    .edit-tags-row {
      display: flex;
      flex-wrap: wrap;
      gap: 0.375rem;
      align-items: center;
    }
    
    .edit-tags-row .tag {
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .edit-tags-row .tag:hover {
      background: rgba(239, 68, 68, 0.2);
      color: var(--danger);
    }
    
    .edit-tags-input {
      flex: 1;
      min-width: 100px;
      padding: 0.3rem 0.5rem;
      font-size: 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      color: var(--text-1);
    }
    
    .edit-tags-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    /* Privacy & Share Row */
    .edit-actions-row {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      padding: 0.5rem 0;
      flex-wrap: wrap;
    }
    
    .privacy-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-2);
      cursor: pointer;
    }
    
    .privacy-toggle input {
      width: 16px;
      height: 16px;
      accent-color: var(--accent);
    }
    
    .share-buttons {
      display: flex;
      gap: 0.25rem;
      margin-left: auto;
    }
    
    .share-buttons .btn {
      width: 36px;
      height: 36px;
      padding: 0;
      font-size: 0.9rem;
    }
    
    /* Compact Collapsible Sections */
    .edit-collapsible {
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      overflow: hidden;
    }
    
    .edit-collapsible-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.6rem 0.75rem;
      background: var(--bg-elevated);
      cursor: pointer;
      font-size: 0.8rem;
      font-weight: 500;
      transition: background 0.15s ease;
    }
    
    .edit-collapsible-header:hover {
      background: var(--bg-card-hover);
    }
    
    .edit-collapsible-header .count {
      color: var(--text-3);
      font-weight: 400;
    }
    
    .edit-collapsible-header .toggle-icon {
      color: var(--text-3);
      font-size: 0.7rem;
      transition: transform 0.2s ease;
    }
    
    .edit-collapsible-header.collapsed .toggle-icon {
      transform: rotate(-90deg);
    }
    
    .edit-collapsible-content {
      max-height: 200px;
      overflow-y: auto;
      padding: 0.75rem;
      border-top: 1px solid var(--border-subtle);
      transition: max-height 0.25s ease, padding 0.25s ease;
    }
    
    .edit-collapsible-content.collapsed {
      max-height: 0;
      padding: 0 0.75rem;
      border-top: none;
      overflow: hidden;
    }
    
    /* Photo Grid in Collapsible */
    .edit-photo-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
      gap: 0.5rem;
    }
    
    .edit-photo-item {
      aspect-ratio: 1;
      border-radius: var(--radius-sm);
      overflow: hidden;
      position: relative;
      border: 1px solid var(--border-subtle);
    }
    
    .edit-photo-item img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    
    .edit-photo-item .delete-btn {
      position: absolute;
      top: 2px;
      right: 2px;
      width: 18px;
      height: 18px;
      background: var(--danger);
      border: none;
      border-radius: 3px;
      color: white;
      font-size: 0.65rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.15s ease;
    }
    
    .edit-photo-item:hover .delete-btn {
      opacity: 1;
    }
    
    .edit-photo-add {
      aspect-ratio: 1;
      border: 2px dashed var(--border-medium);
      border-radius: var(--radius-sm);
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-3);
      font-size: 1.25rem;
      cursor: pointer;
      transition: all 0.15s ease;
    }
    
    .edit-photo-add:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(99, 102, 241, 0.05);
    }
    
    /* Comments in Collapsible */
    .edit-comment {
      padding: 0.5rem;
      background: var(--bg-card);
      border-radius: var(--radius-sm);
      margin-bottom: 0.5rem;
    }
    
    .edit-comment:last-of-type {
      margin-bottom: 0;
    }
    
    .edit-comment-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.25rem;
    }
    
    .edit-comment-author {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--accent);
    }
    
    .edit-comment-time {
      font-size: 0.6rem;
      color: var(--text-3);
    }
    
    .edit-comment-text {
      font-size: 0.75rem;
      color: var(--text-2);
      line-height: 1.4;
    }
    
    .edit-comment-delete {
      background: transparent;
      border: none;
      color: var(--danger);
      font-size: 0.65rem;
      cursor: pointer;
      padding: 0;
      margin-left: 0.5rem;
    }
    
    .edit-comment-input-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
      padding-top: 0.5rem;
      border-top: 1px solid var(--border-subtle);
    }
    
    .edit-comment-input-row input {
      flex: 1;
      padding: 0.4rem 0.6rem;
      font-size: 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      color: var(--text-1);
    }
    
    .edit-comment-input-row .btn {
      padding: 0.4rem 0.75rem;
      font-size: 0.7rem;
    }
    
    /* URL Link Style */
    .edit-url-link {
      display: block;
      font-size: 0.8rem;
      color: var(--accent);
      text-decoration: none;
      word-break: break-all;
      padding: 0.4rem 0;
    }
    
    .edit-url-link:hover {
      text-decoration: underline;
    }
    
    /* Mobile Responsive */
    @media (max-width: 700px) {
      .edit-modal-body {
        flex-direction: column;
      }
      
      .edit-modal-left,
      .edit-modal-right {
        width: 100%;
        border-right: none;
      }
      
      .edit-modal-left {
        border-bottom: 1px solid var(--border-subtle);
      }
      
      .edit-image-container {
        aspect-ratio: 16/9;
      }
      
      .modal-content.edit-modal {
        max-height: 95vh;
      }
    }
    .form-group { margin-bottom: 1.25rem; }
    .form-label { display: block; font-size: 0.75rem; font-weight: 500; color: var(--text-2); margin-bottom: 0.5rem; text-transform: uppercase; letter-spacing: 0.05em; }
    .form-input, .form-textarea, .form-select {
      width: 100%;
      padding: 0.75rem 1rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      color: var(--text-1);
      font-size: 0.9rem;
      font-family: inherit;
    }
    .form-input:focus, .form-textarea:focus, .form-select:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }
    .form-textarea { resize: vertical; min-height: 100px; }
    .section { margin-bottom: 1rem; }
    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem;
      background: var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-md);
      cursor: pointer;
    }
    .section-title { display: flex; align-items: center; gap: 0.5rem; font-size: 0.8rem; font-weight: 600; }
    .section-toggle { color: var(--text-3); font-size: 0.75rem; transition: transform 0.15s ease; }
    .section-toggle.collapsed { transform: rotate(-90deg); }
    .section-content { padding: 1rem 0; max-height: 500px; overflow: hidden; transition: all 0.25s ease; }
    .section-content.collapsed { max-height: 0; padding: 0; }
    .vote-row { display: flex; align-items: center; gap: 0.5rem; padding: 0.75rem; background: var(--bg-elevated); border-radius: var(--radius-md); margin-bottom: 1rem; }
    .vote-btn {
      width: 40px; height: 40px;
      background: var(--bg-card);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius-sm);
      color: var(--text-2);
      font-size: 1.1rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .vote-btn.upvoted { background: rgba(16, 185, 129, 0.2); border-color: var(--success); color: var(--success); }
    .vote-btn.downvoted { background: rgba(239, 68, 68, 0.2); border-color: var(--danger); color: var(--danger); }
    .vote-score { font-size: 1.25rem; font-weight: 600; min-width: 50px; text-align: center; }
    .vote-score.positive { color: var(--success); }
    .vote-score.negative { color: var(--danger); }
    .tabs { display: flex; gap: 0.25rem; padding: 0.25rem; background: var(--bg-elevated); border-radius: var(--radius-md); margin-bottom: 1.5rem; }
    .tab { flex: 1; padding: 0.75rem; background: transparent; border: none; border-radius: var(--radius-sm); color: var(--text-2); font-size: 0.8rem; font-weight: 500; font-family: inherit; cursor: pointer; }
    .tab.active { background: var(--gradient); color: white; }
    .toast {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%) translateY(100px);
      background: var(--bg-secondary);
      border: 1px solid var(--border-medium);
      color: var(--text-1);
      padding: 1rem 1.5rem;
      border-radius: var(--radius-md);
      font-size: 0.875rem;
      z-index: 10000;
      opacity: 0;
      transition: all 0.3s ease;
      pointer-events: none;
      box-shadow: 0 16px 48px rgba(0,0,0,0.4);
    }
    .toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    .toast.success { background: var(--success); border-color: var(--success); }
    .toast.error { background: var(--danger); border-color: var(--danger); }
    .upload-zone {
      position: relative;
      width: 100%;
      height: 200px;
      border: 2px dashed var(--border-medium);
      border-radius: var(--radius-lg);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      margin-bottom: 1.5rem;
      background: var(--bg-elevated);
      overflow: hidden;
    }
    .upload-zone:hover { border-color: var(--accent); background: rgba(99, 102, 241, 0.05); }
    .upload-zone.has-image { border-style: solid; }
    .upload-zone img { width: 100%; height: 100%; object-fit: cover; }
    .upload-prompt { text-align: center; color: var(--text-3); }
    .upload-prompt-icon { font-size: 2.5rem; margin-bottom: 0.5rem; opacity: 0.5; }
    .gallery-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 0.5rem; margin-bottom: 1rem; }
    .gallery-item { position: relative; aspect-ratio: 1; border-radius: var(--radius-sm); overflow: hidden; border: 1px solid var(--border-subtle); }
    .gallery-item img { width: 100%; height: 100%; object-fit: cover; }
    .gallery-delete { position: absolute; top: 0.25rem; right: 0.25rem; width: 20px; height: 20px; background: var(--danger); border: none; border-radius: 4px; color: white; font-size: 0.7rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
    .comment { padding: 0.75rem; background: var(--bg-elevated); border-radius: var(--radius-md); margin-bottom: 0.5rem; }
    .comment-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.375rem; }
    .comment-author { font-size: 0.75rem; font-weight: 600; color: var(--accent); }
    .comment-time { font-size: 0.65rem; color: var(--text-3); }
    .comment-text { font-size: 0.8rem; color: var(--text-2); line-height: 1.5; }
    .share-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
    .share-btn { padding: 0.75rem; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: var(--radius-md); color: var(--text-1); font-size: 0.75rem; font-family: inherit; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.5rem; }
    .url-link { display: block; padding: 0.75rem 1rem; background: var(--bg-elevated); border: 1px solid var(--border-subtle); border-radius: var(--radius-md); color: var(--accent); text-decoration: none; font-size: 0.8rem; word-break: break-all; }
    .info-box { padding: 0.75rem 1rem; background: var(--bg-elevated); border-radius: var(--radius-md); font-size: 0.75rem; color: var(--text-3); margin-bottom: 1rem; line-height: 1.6; }
    .promo-banner { background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%); border: 1px solid rgba(99, 102, 241, 0.2); border-radius: var(--radius-md); padding: 1rem; margin-bottom: 1rem; }
    .promo-banner strong { color: var(--text-1); }
    .promo-banner p { color: var(--text-2); font-size: 0.8rem; margin-top: 0.25rem; }
    .thought-preview { padding: 2rem 1.5rem; border-radius: var(--radius-lg); min-height: 150px; position: relative; overflow: hidden; box-shadow: 0 8px 32px rgba(0,0,0,0.3); margin-bottom: 1rem; }
    .thought-preview-title { font-size: 1.1rem; font-weight: 600; color: white; margin-bottom: 0.75rem; text-shadow: 0 2px 4px rgba(0,0,0,0.3); }
    .thought-preview-content { color: rgba(255,255,255,0.95); font-size: 0.875rem; white-space: pre-wrap; line-height: 1.6; text-shadow: 0 1px 2px rgba(0,0,0,0.2); }
    .bulk-bar { position: fixed; bottom: 0; left: 0; right: 0; background: var(--gradient); padding: 1rem; z-index: 1000; box-shadow: 0 -4px 20px rgba(0,0,0,0.3); display: none; }
    .bulk-bar.active { display: block; }
    .bulk-bar-inner { max-width: 500px; margin: 0 auto; display: flex; flex-direction: column; gap: 0.5rem; }
    .bulk-bar-row { display: flex; gap: 0.5rem; }
    .bulk-bar .btn { flex: 1; background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; }
    .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    .stat-item { background: var(--bg-elevated); padding: 1rem; border-radius: var(--radius-md); }
    .stat-label { font-size: 0.7rem; color: var(--text-3); margin-bottom: 0.25rem; }
    .stat-value { font-size: 1.5rem; font-weight: 700; }
    .contributor-list { background: var(--bg-elevated); border-radius: var(--radius-md); padding: 0.75rem; max-height: 250px; overflow-y: auto; }
    .contributor-item { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; border-bottom: 1px solid var(--border-subtle); }
    .contributor-item:last-child { border-bottom: none; }
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: var(--bg-elevated); border-radius: 3px; }
    ::-webkit-scrollbar-thumb { background: var(--border-medium); border-radius: 3px; }
    /* Discover Bubble View Styles */
    /* ========== DISCOVER BUBBLE VIEW STYLES ========== */
    .discover-view {
      position: fixed;
      inset: 0;
      background: #050508;
      z-index: 900;
      display: none;
      flex-direction: column;
      overflow: hidden;
    }
    
    .discover-view.active {
      display: flex;
    }

    .discover-header {
      padding: 1rem 1.25rem;
      background: rgba(5, 5, 8, 0.95);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.06);
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
      position: relative;
    }
    .discover-search-box {
      position: relative;
      flex: 1;
      max-width: 400px;
    }
    .discover-search-input {
      width: 100%;
      padding: 0.6rem 1rem 0.6rem 2.5rem;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--radius-md);
      color: var(--text-1);
      font-size: 0.85rem;
      font-family: inherit;
    }
    .discover-search-input:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.15);
    }
    .discover-search-input::placeholder {
      color: var(--text-3);
    }
    .discover-search-icon {
      position: absolute;
      left: 0.85rem;
      top: 50%;
      transform: translateY(-50%);
      color: var(--text-3);
      font-size: 0.85rem;
    }
    .discover-canvas {
      flex: 1;
      overflow: hidden;
      position: relative;
      background: #050508;
    }

    /* Cosmic background layers */
    .discover-canvas::before {
      content: '';
      position: absolute;
      inset: 0;
      background: 
        radial-gradient(ellipse 80% 50% at 50% 50%, rgba(99, 102, 241, 0.08) 0%, transparent 50%),
        radial-gradient(ellipse 60% 40% at 30% 30%, rgba(139, 92, 246, 0.06) 0%, transparent 40%),
        radial-gradient(ellipse 50% 50% at 70% 70%, rgba(236, 72, 153, 0.04) 0%, transparent 40%);
      pointer-events: none;
      animation: cosmicPulse 15s ease-in-out infinite;
    }

    @keyframes cosmicPulse {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.05); }
    }



    /* Star field background */
    .star-field {
      position: absolute;
      inset: -50%;
      width: 200%;
      height: 200%;
      pointer-events: none;
      overflow: hidden;
      transition: transform 0.1s ease-out;
    }

    .star {
      position: absolute;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      animation: starTwinkle var(--duration) ease-in-out infinite;
      opacity: var(--opacity);
    }

    @keyframes starTwinkle {
      0%, 100% { opacity: var(--opacity); transform: scale(1); }
      50% { opacity: calc(var(--opacity) * 0.3); transform: scale(0.8); }
    }

    /* Ambient particles */
    .ambient-particles {
      position: absolute;
      inset: -25%;
      width: 150%;
      height: 150%;
      pointer-events: none;
      overflow: hidden;
      transition: transform 0.15s ease-out;
    }

    .particle {
      position: absolute;
      border-radius: 50%;
      animation: particleFloat var(--duration) ease-in-out infinite;
      opacity: 0.4;
    }

    @keyframes particleFloat {
      0%, 100% { 
        transform: translate(0, 0) scale(1); 
        opacity: 0.4;
      }
      25% { 
        transform: translate(var(--dx), var(--dy)) scale(1.2); 
        opacity: 0.6;
      }
      50% { 
        transform: translate(calc(var(--dx) * -0.5), calc(var(--dy) * 1.5)) scale(0.8); 
        opacity: 0.3;
      }
      75% { 
        transform: translate(calc(var(--dx) * 0.8), calc(var(--dy) * -0.5)) scale(1.1); 
        opacity: 0.5;
      }
    }

    .bubble-container {
      position: absolute;
      inset: 0;
      overflow: visible;
      z-index: 10;
    }

    /* ========== BUBBLE CARD STYLES ========== */
    .bubble-card {
      position: absolute;
      background: rgba(15, 15, 20, 0.9);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 16px;
      cursor: pointer;
      user-select: none;
      display: flex;
      flex-direction: column;
      width: 240px;
      overflow: hidden;
      box-shadow: 
        0 4px 24px rgba(0, 0, 0, 0.4),
        0 0 0 1px rgba(255, 255, 255, 0.03) inset;
      transition: 
        transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1),
        box-shadow 0.4s ease,
        border-color 0.3s ease,
        opacity 0.4s ease;
      will-change: transform;
      transform-origin: center center;
    }

    /* Glow effect layer */
    .bubble-card::before {
      content: '';
      position: absolute;
      inset: -1px;
      border-radius: 16px;
      background: linear-gradient(135deg, 
        rgba(99, 102, 241, 0.2) 0%, 
        transparent 50%,
        rgba(139, 92, 246, 0.1) 100%);
      opacity: 0;
      transition: opacity 0.4s ease;
      pointer-events: none;
      z-index: -1;
    }

    .bubble-card:hover::before {
      opacity: 1;
    }

    /* Breathing animation */
    .bubble-card.breathing {
      animation: cardBreathe 4s ease-in-out infinite;
      animation-delay: var(--breath-delay, 0s);
    }

    @keyframes cardBreathe {
      0%, 100% { transform: translateY(0) scale(1); }
      50% { transform: translateY(-3px) scale(1.005); }
    }

    /* Hover state */
    .bubble-card:hover {
      transform: translateY(-8px) scale(1.03) !important;
      border-color: rgba(255, 255, 255, 0.15);
      box-shadow: 
        0 20px 50px rgba(0, 0, 0, 0.5),
        0 0 30px rgba(99, 102, 241, 0.15),
        0 0 0 1px rgba(255, 255, 255, 0.08) inset;
      z-index: 100 !important;
      animation: none !important;
    }

    /* Magnetic push effect on nearby cards */
    .bubble-card.pushed {
      transition: transform 0.3s cubic-bezier(0.34, 1.2, 0.64, 1);
    }

    /* Selected state */
    .bubble-card.selected {
      border-color: var(--accent);
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 0 0 2px rgba(99, 102, 241, 0.5),
        0 0 50px rgba(99, 102, 241, 0.2);
      z-index: 200 !important;
      animation: none !important;
    }

    .bubble-card.selected::before {
      opacity: 1;
      background: linear-gradient(135deg, 
        rgba(99, 102, 241, 0.3) 0%, 
        rgba(139, 92, 246, 0.2) 100%);
    }

    /* Related cards */
    .bubble-card.related {
      border-color: rgba(139, 92, 246, 0.5);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4),
        0 0 25px rgba(139, 92, 246, 0.15);
      animation: relatedPulse 2s ease-in-out infinite !important;
    }

    @keyframes relatedPulse {
      0%, 100% { box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 25px rgba(139,92,246,0.15); }
      50% { box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 40px rgba(139,92,246,0.25); }
    }

    /* Center card special styling */
    .bubble-card.center-card {
      width: 280px;
      border: 2px solid rgba(99, 102, 241, 0.5);
      box-shadow: 
        0 8px 40px rgba(0, 0, 0, 0.4),
        0 0 60px rgba(99, 102, 241, 0.2),
        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      z-index: 50;
    }

    .bubble-card.center-card::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: 20px;
      background: linear-gradient(135deg, rgba(99, 102, 241, 0.4), rgba(139, 92, 246, 0.4));
      z-index: -2;
      opacity: 0.5;
      filter: blur(8px);
      animation: centerGlow 3s ease-in-out infinite;
    }

    @keyframes centerGlow {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.02); }
    }

    /* Depth-based styling */
    .bubble-card[data-depth="1"] {
      opacity: 0.95;
    }

    .bubble-card[data-depth="2"] {
      opacity: 0.8;
      filter: blur(0.3px);
    }

    .bubble-card[data-depth="3"] {
      opacity: 0.65;
      filter: blur(0.6px);
    }

    .bubble-card[data-depth="4"] {
      opacity: 0.5;
      filter: blur(1px);
    }

    /* Guide card styling */
    .bubble-card.guide-card {
      border-color: rgba(99, 102, 241, 0.4);
    }

    .bubble-card.guide-card .guide-badge {
      background: linear-gradient(135deg, var(--accent), var(--accent-2)) !important;
      font-weight: 600;
    }

    /* Card internal elements */
    .bubble-card-image {
      width: 100%;
      height: 120px;
      overflow: hidden;
      background: linear-gradient(135deg, var(--bg-elevated) 0%, var(--bg-secondary) 100%);
      position: relative;
    }

    .bubble-card-image img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition: transform 0.5s ease;
    }

    .bubble-card:hover .bubble-card-image img {
      transform: scale(1.08);
    }

    .bubble-card-image-overlay {
      position: absolute;
      inset: 0;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 0.5rem;
      background: linear-gradient(180deg, rgba(0,0,0,0.5) 0%, transparent 60%);
    }

    .bubble-badge {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      padding: 0.2rem 0.5rem;
      border-radius: 6px;
      font-size: 0.65rem;
      color: white;
      font-weight: 500;
    }

    .bubble-star-btn {
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(8px);
      border: none;
      padding: 0.3rem 0.45rem;
      border-radius: 6px;
      color: var(--text-2);
      cursor: pointer;
      font-size: 0.85rem;
      transition: all 0.2s ease;
    }

    .bubble-star-btn:hover {
      background: rgba(0, 0, 0, 0.8);
      color: var(--warning);
      transform: scale(1.1);
    }

    .bubble-star-btn.active {
      color: var(--warning);
    }

    .bubble-card-content {
      padding: 0.75rem;
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      flex: 1;
    }

    .bubble-card-title {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text-1);
      line-height: 1.3;
      display: -webkit-box;
      -webkit-line-clamp: 2;
      -webkit-box-orient: vertical;
      overflow: hidden;
      margin: 0;
    }

    .bubble-card-url {
      font-size: 0.65rem;
      color: var(--text-3);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .bubble-card-tags {
      display: flex;
      gap: 0.25rem;
      flex-wrap: wrap;
      margin-top: 0.25rem;
    }

    .bubble-card-tags .tag {
      font-size: 0.6rem;
      padding: 0.12rem 0.35rem;
      background: rgba(99, 102, 241, 0.2);
      border-radius: 4px;
      color: var(--accent);
    }

    .bubble-card-author {
      font-size: 0.65rem;
      color: var(--text-3);
      margin-top: auto;
    }

    .bubble-card-footer {
      display: flex;
      gap: 0.25rem;
      padding: 0.5rem 0.75rem;
      border-top: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(0, 0, 0, 0.3);
    }

    .bubble-card-footer button {
      flex: 1;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 6px;
      color: var(--text-3);
      cursor: pointer;
      padding: 0.4rem;
      font-size: 0.8rem;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.2rem;
    }

    .bubble-card-footer button:hover {
      background: rgba(99, 102, 241, 0.15);
      border-color: rgba(99, 102, 241, 0.3);
      color: var(--text-1);
      transform: scale(1.05);
    }

    .bubble-card-footer button:active {
      transform: scale(0.95);
    }

    .bubble-card-footer .vote-count {
      font-size: 0.65rem;
      font-weight: 600;
    }

    /* ========== CELESTIAL TYPE STYLES ========== */

    /* Star - Hub cards */
    .bubble-card.celestial-star {
      border: 2px solid rgba(250, 204, 21, 0.4);
      box-shadow: 
        0 8px 40px rgba(0, 0, 0, 0.4),
        0 0 60px rgba(250, 204, 21, 0.15),
        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      z-index: 50;
    }

    .bubble-card.celestial-star::before {
      background: linear-gradient(135deg, 
        rgba(250, 204, 21, 0.15) 0%, 
        transparent 50%,
        rgba(251, 191, 36, 0.1) 100%);
    }

    .star-corona {
      position: absolute;
      inset: -8px;
      border-radius: 20px;
      background: radial-gradient(ellipse at center, 
        rgba(250, 204, 21, 0.1) 0%, 
        transparent 70%);
      pointer-events: none;
      animation: coronaPulse 4s ease-in-out infinite;
    }

    @keyframes coronaPulse {
      0%, 100% { opacity: 0.5; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.02); }
    }

    /* Planet - Connected cards */
    .bubble-card.celestial-planet {
      border-color: rgba(99, 102, 241, 0.3);
      animation: gentleFloat 6s ease-in-out infinite;
    }

    @keyframes gentleFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-4px); }
    }

    /* Moon - Secondary cards */
    .bubble-card.celestial-moon {
      border-color: rgba(148, 163, 184, 0.25);
      opacity: 0.9;
    }

    .bubble-card.celestial-moon .bubble-card-image {
      height: 100px;
    }

    /* Comet - New arrivals */
    .bubble-card.celestial-comet {
      border: 2px solid rgba(34, 211, 238, 0.4);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.4),
        0 0 30px rgba(34, 211, 238, 0.2);
      animation: cometShimmer 3s ease-in-out infinite;
    }

    @keyframes cometShimmer {
      0%, 100% { 
        box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 30px rgba(34, 211, 238, 0.2);
      }
      50% { 
        box-shadow: 0 8px 32px rgba(0,0,0,0.4), 0 0 50px rgba(34, 211, 238, 0.35);
      }
    }

    .comet-tail {
      position: absolute;
      top: 50%;
      right: 100%;
      width: 80px;
      height: 4px;
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(34, 211, 238, 0.1) 30%,
        rgba(34, 211, 238, 0.3) 70%,
        rgba(34, 211, 238, 0.5) 100%);
      transform: translateY(-50%);
      border-radius: 2px;
      pointer-events: none;
      animation: tailFade 2s ease-in-out infinite;
    }

    @keyframes tailFade {
      0%, 100% { opacity: 0.6; width: 60px; }
      50% { opacity: 1; width: 100px; }
    }

    .comet-badge {
      background: linear-gradient(135deg, #22d3ee, #06b6d4) !important;
      animation: badgePulse 2s ease-in-out infinite;
    }

    @keyframes badgePulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Asteroid - Orphan cards */
    .bubble-card.celestial-asteroid {
      border-color: rgba(100, 116, 139, 0.2);
      opacity: 0.75;
    }

    .bubble-card.celestial-asteroid .bubble-card-image {
      height: 90px;
    }

    .bubble-card.celestial-asteroid:hover {
      opacity: 1;
    }

    /* Remove breathing animation from non-stars to keep things subtle */
    .bubble-card.celestial-planet,
    .bubble-card.celestial-moon,
    .bubble-card.celestial-asteroid {
      animation: none;
    }

    .bubble-card.celestial-planet {
      animation: gentleFloat 6s ease-in-out infinite;
    }

    /* ========== CONNECTION LINES ========== */
    .connection-line {
      pointer-events: none;
      stroke-linecap: round;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .connection-line.visible {
      opacity: 1;
    }

    .connection-line.active {
      animation: connectionFlow 2s linear infinite;
    }

    @keyframes connectionFlow {
      0% { stroke-dashoffset: 20; }
      100% { stroke-dashoffset: 0; }
    }

     .synapse-path {
      filter: url(#synapseGlow);
      animation: synapsePulse 3s ease-in-out infinite;
    }
    
    @keyframes synapsePulse {
      0%, 100% { opacity: 0.5; stroke-width: 1; }
      50% { opacity: 0.8; stroke-width: 1.5; }
    }
    
    .synapse-node {
      filter: url(#synapseGlow);
      animation: nodeGlow 2s ease-in-out infinite;
    }
    
    @keyframes nodeGlow {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.2); }
    }
    
    .synapse-glow {
      animation: glowPulse 2.5s ease-in-out infinite;
    }
    
    @keyframes glowPulse {
      0%, 100% { opacity: 0.3; r: attr(r); }
      50% { opacity: 0.6; }
    }
    
    .synapse-pulse {
      filter: blur(1px);
    }

    /* ========== INFO PANEL ========== */
    .discover-info {
      position: absolute;
      bottom: 1.5rem;
      left: 1.5rem;
      background: rgba(15, 15, 20, 0.95);
      backdrop-filter: blur(24px);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 20px;
      padding: 1.25rem;
      max-width: 360px;
      box-shadow: 
        0 20px 60px rgba(0, 0, 0, 0.5),
        0 0 40px rgba(99, 102, 241, 0.1),
        0 0 0 1px rgba(255, 255, 255, 0.05) inset;
      z-index: 200;
      animation: infoPanelSlide 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes infoPanelSlide {
      from { opacity: 0; transform: translateY(30px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }

    .discover-info-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 0.75rem;
      gap: 0.75rem;
    }

    .discover-info-topic {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      flex-shrink: 0;
      margin-top: 0.2rem;
      box-shadow: 0 0 15px currentColor;
      animation: topicPulse 2s ease-in-out infinite;
    }
    
    .discover-add-btn {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.5rem 1rem;
      font-size: 0.85rem;
      font-weight: 600;
      border-radius: 12px;
      position: relative;
      overflow: hidden;
    }
    
    .discover-add-btn::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.2) 0%, transparent 50%);
      opacity: 0;
      transition: opacity 0.2s ease;
    }
    
    .discover-add-btn:hover::before {
      opacity: 1;
    }
    
    .discover-add-icon {
      font-size: 1.1rem;
      font-weight: 300;
    }
    
    .discover-add-text {
      font-weight: 600;
    }
    
    /* Floating add button for Discover (mobile friendly) */
    .discover-fab {
      position: absolute;
      bottom: 1.5rem;
      right: 6.5rem;
      width: 52px;
      height: 52px;
      border-radius: 14px;
      background: var(--gradient);
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      box-shadow: 0 8px 32px rgba(99, 102, 241, 0.4);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      animation: fabPulse 3s ease-in-out infinite;
    }

    .discover-fab:hover {
      transform: scale(1.1);
      box-shadow: 0 12px 40px rgba(99, 102, 241, 0.6);
    }
    
    @keyframes fabPulse {
      0%, 100% { box-shadow: 0 8px 32px rgba(99, 102, 241, 0.4); }
      50% { box-shadow: 0 8px 40px rgba(99, 102, 241, 0.6); }
    }
    
    @keyframes topicPulse {
      0%, 100% { box-shadow: 0 0 10px currentColor; }
      50% { box-shadow: 0 0 20px currentColor, 0 0 30px currentColor; }
    }

    .discover-info-title {
      font-size: 1.1rem;
      font-weight: 600;
      flex: 1;
      margin: 0;
      line-height: 1.3;
    }

    .discover-info-url {
      font-size: 0.75rem;
      color: var(--text-3);
      margin-bottom: 0.75rem;
      word-break: break-all;
    }

    .discover-info-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 0.375rem;
      margin-bottom: 0.75rem;
    }

    .discover-info-notes {
      font-size: 0.85rem;
      color: var(--text-2);
      margin-bottom: 1rem;
      line-height: 1.5;
      max-height: 80px;
      overflow-y: auto;
    }

    .discover-info-actions {
      display: flex;
      gap: 0.5rem;
    }

    .discover-info-actions .btn {
      flex: 1;
      padding: 0.65rem;
    }

    /* ========== CONTROLS ========== */
    .discover-controls {
      position: absolute;
      bottom: 1.5rem;
      right: 1.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      z-index: 200;
    }

    .discover-controls .btn {
      width: 44px;
      height: 44px;
      padding: 0;
      font-size: 1.1rem;
      background: rgba(15, 15, 20, 0.9);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      transition: all 0.2s ease;
    }

    .discover-controls .btn:hover {
      background: rgba(99, 102, 241, 0.2);
      border-color: rgba(99, 102, 241, 0.4);
      transform: scale(1.1);
    }

    /* ========== STATS ========== */
    .discover-stats {
      position: absolute;
      top: 1rem;
      right: 1rem;
      display: flex;
      gap: 0.75rem;
      z-index: 200;
    }

    .discover-stat {
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(12px);
      padding: 0.5rem 0.75rem;
      border-radius: 10px;
      font-size: 0.75rem;
      color: var(--text-2);
      border: 1px solid rgba(255, 255, 255, 0.08);
    }

    .discover-stat strong {
      color: var(--text-1);
      margin-right: 0.25rem;
    }

    /* ========== LOADING STATE ========== */
    .discover-loading {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      z-index: 300;
      background: rgba(5, 5, 8, 0.9);
    }

    .discover-loading-spinner {
      width: 50px;
      height: 50px;
      border: 3px solid rgba(99, 102, 241, 0.2);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* ========== EMPTY STATE ========== */
    .discover-empty {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 2rem;
    }

    .discover-empty-icon {
      font-size: 4rem;
      margin-bottom: 1rem;
      opacity: 0.5;
    }

    .discover-empty h2 {
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
    }

    .discover-empty p {
      color: var(--text-2);
      margin-bottom: 1.5rem;
    }
     /* Community card indicator */
    .bubble-card.community-card {
      border-color: rgba(6, 182, 212, 0.3);
    }
    
    .bubble-card.community-card::before {
      background: linear-gradient(135deg, 
        rgba(6, 182, 212, 0.2) 0%, 
        transparent 50%);
    }
    
    .community-badge {
      background: linear-gradient(135deg, #06b6d4, #0891b2) !important;
    }
    
    /* Sync status indicator */
    .sync-indicator {
      position: fixed;
      bottom: 1rem;
      left: 1rem;
      padding: 0.5rem 0.75rem;
      background: rgba(0, 0, 0, 0.8);
      border-radius: var(--radius-md);
      font-size: 0.75rem;
      color: var(--text-2);
      z-index: 1000;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    
    .sync-indicator.syncing {
      color: var(--accent);
    }
    
    .sync-indicator.synced {
      color: var(--success);
    }
    /* ========== ENTRY ANIMATIONS ========== */
    .bubble-card.entering {
      opacity: 0;
      animation: bubbleEnter 0.6s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }

    @keyframes bubbleEnter {
      from {
        opacity: 0;
        transform: scale(0.5) translateY(30px);
      }
      to {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }

    /* Staggered delays */
    .bubble-card.entering-delay-1 { animation-delay: 0.05s; }
    .bubble-card.entering-delay-2 { animation-delay: 0.1s; }
    .bubble-card.entering-delay-3 { animation-delay: 0.15s; }
    .bubble-card.entering-delay-4 { animation-delay: 0.2s; }
    .bubble-card.entering-delay-5 { animation-delay: 0.25s; }
    .bubble-card.entering-delay-6 { animation-delay: 0.3s; }
    .bubble-card.entering-delay-7 { animation-delay: 0.35s; }
    .bubble-card.entering-delay-8 { animation-delay: 0.4s; }
    .bubble-card.entering-delay-9 { animation-delay: 0.45s; }
    .bubble-card.entering-delay-10 { animation-delay: 0.5s; }
    /* ========== MOBILE RESPONSIVE STYLES ========== */
    /* These styles ONLY apply on mobile - desktop remains unchanged */
    
    @media (max-width: 768px) {
      /* Safe areas for notched devices */
      body {
        padding-top: env(safe-area-inset-top);
        padding-bottom: env(safe-area-inset-bottom);
        padding-left: env(safe-area-inset-left);
        padding-right: env(safe-area-inset-right);
      }
      
      /* ===== HEADER MOBILE ===== */
      .header-main {
        padding: 0.75rem 1rem;
        gap: 0.5rem;
      }
      
      .logo h1 {
        font-size: 1.1rem;
      }
      
      .logo-sub {
        display: none; /* Hide stats on mobile header */
      }
      
      .header-actions {
        gap: 0.35rem;
      }
      
      .header-actions .btn-icon {
        width: 36px;
        height: 36px;
        font-size: 0.9rem;
      }
      
      /* Hide less essential header buttons on small screens */
      .header-actions .btn-icon[title="Community"] {
        display: none;
      }
      
      .btn-add {
        width: 44px;
        height: 44px;
        font-size: 1.5rem;
        border-radius: 12px;
      }
      
      .btn-add::after {
        display: none; /* Hide tooltip on mobile */
      }
      
      .add-btn-pulse {
        inset: -2px;
        border-radius: 14px;
      }
      
      /* Header expand section */
      .header-expand-inner {
        padding: 0.75rem 0;
        gap: 0.75rem;
      }
      
      .filter-row {
        flex-direction: column;
        gap: 0.75rem;
      }
      
      .sort-tabs {
        width: 100%;
        justify-content: center;
      }
      
      .action-bar {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.5rem;
      }
      
      .action-bar .btn {
        min-width: unset;
      }
      
      /* ===== GRID MOBILE ===== */
      .grid {
        padding: 1rem;
        gap: 1rem;
      }
      
      .card-footer .btn {
        padding: 0.6rem;
        font-size: 0.75rem;
      }
      
      /* ===== MODALS MOBILE ===== */
      .modal {
        padding: 0.5rem;
        align-items: flex-end; /* Slide up from bottom */
      }
      
      .modal-content {
        max-height: 95vh;
        border-radius: var(--radius-xl) var(--radius-xl) 0 0;
        margin-bottom: 0;
      }
      
      .modal-header {
        padding: 1rem;
        position: sticky;
        top: 0;
        background: var(--bg-secondary);
        z-index: 10;
        border-bottom: 1px solid var(--border-subtle);
      }
      
      .modal-title {
        font-size: 1.1rem;
      }
      
      /* Inputs - prevent iOS zoom */
      .form-input,
      .form-textarea,
      .form-select,
      .search-input,
      .discover-search-input,
      .edit-title-input,
      .edit-tag-input,
      .edit-comment-input,
      input[type="text"],
      input[type="email"],
      input[type="url"],
      textarea {
        font-size: 16px !important; /* Prevents iOS auto-zoom */
      }
      
      /* ===== DISCOVER VIEW MOBILE ===== */
      .discover-view {
        flex-direction: column;
      }
      
      .discover-header {
        padding: 0.75rem 1rem;
        flex-wrap: wrap;
        gap: 0.75rem;
      }
      
      .discover-header > div:first-child {
        width: 100%;
        flex-direction: row;
        align-items: center;
        gap: 0.75rem;
      }
      
      .discover-header > div:first-child > div:first-child {
        flex-shrink: 0;
      }
      
      .discover-header > div:first-child h2 {
        font-size: 1rem;
      }
      
      .discover-header > div:first-child span {
        display: none; /* Hide subtitle */
      }
      
      .discover-search-box {
        flex: 1;
        max-width: none;
        min-width: 120px;
      }
      
      .discover-search-input {
        padding: 0.5rem 0.75rem 0.5rem 2rem;
        font-size: 16px !important;
      }
      
      .discover-search-icon {
        left: 0.6rem;
        font-size: 0.75rem;
      }
      
      /* Header right side controls */
      .discover-header > div:last-child {
        width: 100%;
        justify-content: space-between;
      }
      
      .discover-header .btn-secondary[onclick="closeDiscover()"] {
        font-size: 0.7rem;
        padding: 0.4rem 0.6rem;
      }
      
      .discover-header .filter-select {
        flex: 1;
        max-width: 120px;
        font-size: 0.75rem;
        padding: 0.4rem 0.5rem;
      }
      
      .discover-add-btn {
        padding: 0.4rem 0.6rem !important;
        font-size: 0.75rem !important;
        border-radius: 8px !important;
      }
      
      .discover-add-btn .discover-add-text {
        display: none; /* Icon only on mobile */
      }
      
      .discover-header .btn-icon {
        width: 36px;
        height: 36px;
      }
      
      /* ===== DISCOVER HEADER - SIMPLIFIED FOR MOBILE ===== */
      .discover-header {
        padding: 0.5rem 0.75rem;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      
      /* First row: Title + Search */
      .discover-header > div:first-child {
        width: 100%;
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      
      .discover-header > div:first-child > div:first-child {
        flex-shrink: 0;
      }
      
      .discover-header > div:first-child h2 {
        font-size: 0.9rem;
        margin: 0;
      }
      
      .discover-header > div:first-child > span {
        display: none !important; /* Hide "Community feed" subtitle */
      }
      
      .discover-search-box {
        flex: 1;
        max-width: none;
      }
      
      .discover-search-input {
        padding: 0.4rem 0.6rem 0.4rem 1.8rem;
        font-size: 16px !important;
        height: 36px;
      }
      
      .discover-search-icon {
        left: 0.5rem;
        font-size: 0.7rem;
      }
      
      /* Second row: Filters + Actions - more compact */
      .discover-header > div:last-child {
        width: 100%;
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 0.35rem;
      }
      
      .discover-header .btn-secondary[onclick="closeDiscover()"] {
        font-size: 0.65rem;
        padding: 0.35rem 0.5rem;
        white-space: nowrap;
      }
      
      .discover-header .filter-select {
        flex: 1;
        max-width: 100px;
        font-size: 0.7rem;
        padding: 0.35rem 0.4rem;
        height: 32px;
      }
      
      /* Hide the header + button on mobile (use FAB instead) */
      .discover-header .discover-add-btn {
        display: none !important;
      }
      
      .discover-header .btn-icon {
        width: 32px;
        height: 32px;
        font-size: 0.85rem;
      }
      
      /* ===== HIDE STATS ON MOBILE ===== */
      .discover-stats {
        display: none !important;
      }
      
      /* ===== SMALLER BUBBLE CARDS ===== */
      .bubble-card {
        width: 140px !important;
        min-width: 140px !important;
      }
      
      .bubble-card.center-card,
      .bubble-card.celestial-star {
        width: 160px !important;
        min-width: 160px !important;
      }
      
      .bubble-card.celestial-moon,
      .bubble-card.celestial-asteroid {
        width: 120px !important;
        min-width: 120px !important;
      }
      
      .bubble-card-image {
        height: 70px;
      }
      
      .bubble-card.celestial-star .bubble-card-image {
        height: 80px;
      }
      
      .bubble-card.celestial-moon .bubble-card-image,
      .bubble-card.celestial-asteroid .bubble-card-image {
        height: 55px;
      }
      
      .bubble-card-content {
        padding: 0.4rem;
        gap: 0.2rem;
      }
      
      .bubble-card-title {
        font-size: 0.7rem;
        -webkit-line-clamp: 2;
        line-height: 1.2;
      }
      
      .bubble-card-url {
        font-size: 0.55rem;
        display: none; /* Hide URL to save space */
      }
      
      .bubble-card-tags {
        display: none !important;
      }
      
      .bubble-card-author {
        font-size: 0.55rem;
      }
      
      .bubble-card-footer {
        padding: 0.25rem 0.4rem;
      }
      
      .bubble-card-footer button {
        padding: 0.25rem;
        font-size: 0.65rem;
        min-height: 28px;
      }
      
      .bubble-badge {
        font-size: 0.5rem;
        padding: 0.1rem 0.25rem;
      }
      
      .bubble-star-btn {
        width: 28px;
        height: 28px;
        padding: 0.25rem;
        font-size: 0.7rem;
      }
      
      /* ===== CONTROLS - SMALLER & REPOSITIONED ===== */
      .discover-controls {
        bottom: auto;
        top: 50%;
        transform: translateY(-50%);
        right: 0.35rem;
        gap: 0.25rem;
      }
      
      .discover-controls .btn {
        width: 32px;
        height: 32px;
        font-size: 0.8rem;
        border-radius: 6px;
        padding: 0;
      }
      
      /* ===== FAB ===== */
      .discover-fab {
        width: 44px;
        height: 44px;
        bottom: calc(0.75rem + env(safe-area-inset-bottom));
        right: 0.75rem;
        font-size: 1.2rem;
        border-radius: 10px;
      }
      
      /* ===== INFO PANEL - BOTTOM SHEET ===== */
      .discover-info {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        max-width: 100%;
        border-radius: 16px 16px 0 0;
        padding: 0.75rem;
        padding-bottom: calc(0.75rem + env(safe-area-inset-bottom));
        max-height: 45vh;
        animation: slideUpMobile 0.25s ease-out;
      }
      
      .discover-info-header {
        margin-bottom: 0.5rem;
      }
      
      .discover-info-title {
        font-size: 0.95rem;
      }
      
      .discover-info-url {
        font-size: 0.65rem;
        margin-bottom: 0.5rem;
      }
      
      .discover-info-tags {
        margin-bottom: 0.5rem;
      }
      
      .discover-info-tags .tag {
        font-size: 0.6rem;
        padding: 0.15rem 0.35rem;
      }
      
      .discover-info-notes {
        font-size: 0.75rem;
        max-height: 50px;
        margin-bottom: 0.75rem;
      }
      
      .discover-info-actions {
        gap: 0.35rem;
      }
      
      .discover-info-actions .btn {
        padding: 0.6rem;
        font-size: 0.8rem;
      }
      
      /* ===== BUBBLE CARDS MOBILE ===== */
      .bubble-card {
        width: 180px !important; /* Smaller cards on mobile */
      }
      
      .bubble-card.center-card,
      .bubble-card.celestial-star {
        width: 200px !important;
      }
      
      .bubble-card-image {
        height: 90px;
      }
      
      .bubble-card.celestial-moon .bubble-card-image,
      .bubble-card.celestial-asteroid .bubble-card-image {
        height: 70px;
      }
      
      .bubble-card-content {
        padding: 0.5rem;
        gap: 0.25rem;
      }
      
      .bubble-card-title {
        font-size: 0.75rem;
        -webkit-line-clamp: 2;
      }
      
      .bubble-card-url {
        font-size: 0.6rem;
      }
      
      .bubble-card-tags {
        display: none; /* Hide tags to save space */
      }
      
      .bubble-card-author {
        font-size: 0.6rem;
      }
      
      .bubble-card-footer {
        padding: 0.35rem 0.5rem;
      }
      
      .bubble-card-footer button {
        padding: 0.35rem;
        font-size: 0.7rem;
        min-height: 32px; /* Better touch target */
      }
      
      .bubble-badge {
        font-size: 0.55rem;
        padding: 0.15rem 0.35rem;
      }
      
      .bubble-star-btn {
        padding: 0.4rem;
        font-size: 0.75rem;
        min-width: 32px;
        min-height: 32px;
      }
      
      /* ===== DISCOVER INFO PANEL - BOTTOM SHEET ON MOBILE ===== */
      .discover-info {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        max-width: 100%;
        border-radius: var(--radius-xl) var(--radius-xl) 0 0;
        padding: 1rem;
        padding-bottom: calc(1rem + env(safe-area-inset-bottom));
        max-height: 50vh;
        overflow-y: auto;
        animation: slideUpMobile 0.3s ease;
      }
      
      @keyframes slideUpMobile {
        from { transform: translateY(100%); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
      }
      
      .discover-info-header {
        gap: 0.5rem;
      }
      
      .discover-info-title {
        font-size: 1rem;
      }
      
      .discover-info-notes {
        max-height: 60px;
        font-size: 0.8rem;
      }
      
      .discover-info-actions {
        flex-direction: row;
      }
      
      .discover-info-actions .btn {
        flex: 1;
        padding: 0.75rem;
        font-size: 0.85rem;
      }
      
      /* ===== DISCOVER CONTROLS MOBILE ===== */
      .discover-controls {
        bottom: auto;
        top: 50%;
        transform: translateY(-50%);
        right: 0.5rem;
        gap: 0.35rem;
      }
      
      .discover-controls .btn {
        width: 36px;
        height: 36px;
        font-size: 0.9rem;
        border-radius: 8px;
      }
      
      /* ===== DISCOVER FAB MOBILE ===== */
      .discover-fab {
        bottom: calc(1rem + env(safe-area-inset-bottom));
        right: 1rem;
        width: 48px;
        height: 48px;
        border-radius: 12px;
        font-size: 1.25rem;
      }
      
      /* ===== DISCOVER STATS MOBILE ===== */
      .discover-stats {
        top: 0.5rem;
        right: 3rem; /* Don't overlap close button */
        gap: 0.5rem;
      }
      
      .discover-stat {
        padding: 0.35rem 0.5rem;
        font-size: 0.65rem;
        border-radius: 6px;
      }
      
      /* ===== EDIT MODAL MOBILE ===== */
      .modal-content.edit-modal {
        max-width: 100%;
        max-height: 100vh;
        border-radius: var(--radius-lg) var(--radius-lg) 0 0;
      }
      
      .edit-top-section {
        flex-direction: column;
        padding: 1rem;
        gap: 1rem;
      }
      
      .edit-image-container {
        width: 100%;
        height: 150px;
      }
      
      .edit-votes-row {
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      
      .edit-vote-btn {
        width: 48px;
        height: 48px;
        font-size: 1.2rem;
      }
      
      .edit-vote-score {
        font-size: 1.5rem;
        min-width: 50px;
      }
      
      .edit-actions-quick {
        margin-left: 0;
        width: 100%;
        justify-content: flex-end;
        gap: 0.35rem;
      }
      
      .edit-actions-quick .btn-icon {
        width: 40px;
        height: 40px;
      }
      
      .edit-tags-bar {
        padding: 0.75rem 1rem;
        gap: 0.35rem;
      }
      
      .edit-tags-bar .tag {
        padding: 0.3rem 0.5rem;
        font-size: 0.75rem;
      }
      
      .edit-main-content {
        flex-direction: column;
        max-height: 40vh;
        overflow-y: auto;
      }
      
      .edit-left-column {
        width: 100%;
        border-right: none;
        border-bottom: 1px solid var(--border-subtle);
        max-height: none;
      }
      
      .edit-right-column {
        min-height: 200px;
      }
      
      .edit-section-content textarea {
        min-height: 80px;
      }
      
      .edit-comment-input-row {
        gap: 0.5rem;
      }
      
      .edit-comment-input {
        font-size: 16px !important;
        padding: 0.65rem 0.85rem;
      }
      
      .edit-comment-submit {
        padding: 0.65rem 1rem;
        font-size: 0.8rem;
      }
      
      .edit-modal-footer {
        flex-direction: column;
        gap: 0.75rem;
        padding: 0.75rem 1rem calc(0.75rem + env(safe-area-inset-bottom));
      }
      
      .edit-footer-left,
      .edit-footer-right {
        width: 100%;
        justify-content: space-between;
      }
      
      /* ===== TOUCH-FRIENDLY: ALWAYS SHOW DELETE BUTTONS ===== */
      .edit-photo-delete,
      .edit-photo-item .delete-btn,
      .edit-comment-delete,
      .gallery-delete {
        opacity: 1 !important; /* Always visible on mobile */
      }
      
      /* ===== BULK BAR MOBILE ===== */
      .bulk-bar {
        padding-bottom: calc(1rem + env(safe-area-inset-bottom));
      }
      
      /* ===== TOAST MOBILE ===== */
      .toast {
        bottom: calc(1.5rem + env(safe-area-inset-bottom));
        left: 1rem;
        right: 1rem;
        transform: translateX(0) translateY(100px);
        max-width: none;
      }
      
      .toast.show {
        transform: translateX(0) translateY(0);
      }
      
      /* ===== PERFORMANCE: REDUCE ANIMATIONS ===== */
      .star-field .star {
        animation-duration: 8s; /* Slower = less CPU */
      }
      
      .ambient-particles .particle {
        animation-duration: 25s; /* Slower = less CPU */
      }
      
      /* Disable breathing on smaller cards */
      .bubble-card.breathing {
        animation: none;
      }
      
      .bubble-card.celestial-planet {
        animation: none;
      }
      
      /* Keep subtle hover effect but simpler */
      .bubble-card:active {
        transform: scale(0.98) !important;
        transition: transform 0.1s ease;
      }
    }
    
    /* ===== EXTRA SMALL SCREENS (< 360px) ===== */
    @media (max-width: 360px) {
      .header-actions .btn-icon[title="Collections"] {
        display: none; /* Hide more buttons on tiny screens */
      }
      
      .discover-header .btn-secondary[onclick="closeDiscover()"] {
        display: none; /* Just use X button */
      }
      
      .bubble-card {
        width: 160px !important;
      }
      
      .bubble-card-image {
        height: 75px;
      }
      
      .discover-info-actions {
        flex-direction: column;
      }
    }
    
    /* ===== LANDSCAPE MOBILE ===== */
    @media (max-height: 500px) and (orientation: landscape) {
      .discover-header {
        padding: 0.5rem 1rem;
      }
      
      .discover-header > div:first-child {
        width: auto;
      }
      
      .discover-header > div:last-child {
        width: auto;
      }
      
      .discover-info {
        max-height: 70vh;
        width: 300px;
        left: auto;
        right: 0;
        bottom: 0;
        border-radius: var(--radius-xl) 0 0 0;
      }
      
      .bubble-card {
        width: 160px !important;
      }
      
      .bubble-card-image {
        height: 70px;
      }
    }
    
    /* ===== PREFERS REDUCED MOTION ===== */
    @media (prefers-reduced-motion: reduce) {
      .star-field .star,
      .ambient-particles .particle,
      .bubble-card.breathing,
      .bubble-card.celestial-planet,
      .bubble-card.celestial-comet,
      .comet-tail,
      .star-corona,
      .add-btn-pulse,
      body::before,
      body::after {
        animation: none !important;
      }
      
      .bubble-card {
        transition: transform 0.1s ease, box-shadow 0.1s ease !important;
      }
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body>
<header class="header">
  <div class="header-main">
    <div class="logo" onclick="openDiscover()" style="cursor:pointer;" title="Open Discover">
      <h1>CommuneCollab</h1>
      <span class="logo-sub"><span id="link-count">0</span> links  <span id="contributor-count">1</span> contributors</span>
    </div>
    <div class="header-actions">
      <button class="btn btn-icon" onclick="openDiscover()" title="Discover"></button>
      <button class="btn btn-icon" onclick="openCollections()" title="Collections"></button>
      <button class="btn btn-icon" onclick="openCommunity()" title="Community"></button>
      <button class="btn btn-icon" onclick="openSettings()" title="Settings"></button>
      <button class="btn btn-primary btn-add" onclick="openAddModal()" title="Share something new!" id="mainAddBtn">
        <span class="add-btn-icon">+</span>
        <span class="add-btn-pulse"></span>
      </button>
    </div>
  </div>
  <div class="header-expand" id="headerExpand">
    <div class="header-expand-inner">
      <div class="search-box">
        <span class="search-icon"></span>
        <input type="text" class="search-input" id="searchBar" placeholder="Search links, notes, tags..." oninput="handleSearch()">
      </div>
      <div class="filter-row">
        <select class="filter-select" id="collectionFilter" onchange="filterByCollection()">
          <option value="">All Collections</option>
        </select>
        <div class="sort-tabs">
          <button class="sort-tab active" onclick="setSortMode('date',this)">Recent</button>
          <button class="sort-tab" onclick="setSortMode('votes',this)">Top</button>
          <button class="sort-tab" onclick="setSortMode('title',this)">A-Z</button>
        </div>
      </div>
      <div class="chips" id="topicChips">
        <button class="chip active" onclick="switchTopic('all',this)">All</button>
        <button class="chip" onclick="switchTopic('tech',this)"> Tech</button>
        <button class="chip" onclick="switchTopic('news',this)"> News</button>
        <button class="chip" onclick="switchTopic('food',this)"> Food</button>
        <button class="chip" onclick="switchTopic('travel',this)"> Travel</button>
        <button class="chip" onclick="switchTopic('entertainment',this)"> Entertainment</button>
        <button class="chip" onclick="switchTopic('other',this)"> Other</button>
      </div>
      <div class="action-bar">
        <button class="btn btn-secondary" onclick="exportCollection()"> Export</button>
        <button class="btn btn-secondary" onclick="document.getElementById('importFile').click()"> Import</button>
        <button class="btn btn-secondary" onclick="toggleStarred()" id="starFilterBtn"> Starred</button>
        <button class="btn btn-secondary" onclick="toggleBulkMode()" id="bulkModeBtn"> Select</button>
      </div>
      <input type="file" id="importFile" accept=".json" onchange="importCollection(event)">
    </div>
  </div>
  <button class="collapse-toggle" onclick="toggleHeaderCollapse()">
    <span id="collapseIcon"></span>
    <span id="collapseText">Hide filters</span>
  </button>
</header>

<main class="grid" id="grid">
  <div class="empty-state">
    <div class="empty-icon"></div>
    <h2>Start your collection</h2>
    <p>Add links, organize, and share with your community</p>
    <button class="btn btn-primary" onclick="openAddModal()">+ Add Link</button>
  </div>
</main>

<div class="bulk-bar" id="bulkBar">
  <div class="bulk-bar-inner">
    <div class="bulk-bar-row">
      <button class="btn" onclick="bulkAddToCollection()"> Add to Collection</button>
      <button class="btn" onclick="bulkDelete()"> Delete (<span id="bulkCount">0</span>)</button>
    </div>
    <button class="btn" onclick="toggleBulkMode()"> Cancel</button>
  </div>
</div>

<div class="toast" id="toast"></div>
<!-- ADD MODAL -->
<div class="modal" id="addModal">
  <div class="modal-content">
    <div class="modal-header">
      <h2 class="modal-title">Add New</h2>
      <button class="modal-close" onclick="closeAddModal()"></button>
    </div>
    <div class="tabs">
      <button class="tab active" id="linkTabBtn" onclick="switchAddTab('link')"> Link</button>
      <button class="tab" id="mediaTabBtn" onclick="switchAddTab('media')"> Media</button>
      <button class="tab" id="thoughtTabBtn" onclick="switchAddTab('thought')"> Thought</button>
    </div>
    <div id="linkTab">
      <div class="form-group">
        <label class="form-label">Topic</label>
        <select class="form-select" id="newLinkTopic">
          <option value="tech"> Tech</option>
          <option value="news"> News</option>
          <option value="food"> Food</option>
          <option value="travel"> Travel</option>
          <option value="entertainment"> Entertainment</option>
          <option value="other"> Other</option>
        </select>
      </div>
      <div class="form-group">
        <label class="form-label">URL</label>
        <input type="url" class="form-input" id="newUrl" placeholder="https://example.com" oninput="checkRestrictedSite()" onkeypress="if(event.key==='Enter')addLink()">
      </div>
      <div id="restrictedSitePrompt" style="display:none">
        <div class="upload-screenshot-prompt" id="uploadScreenshotPrompt" onclick="document.getElementById('linkScreenshotInput').click()">
          <input type="file" id="linkScreenshotInput" accept="image/*" onchange="handleLinkScreenshot(event)">
          <div style="font-size:2rem;margin-bottom:0.5rem"></div>
          <div style="font-weight:500;color:var(--text-1)">This site blocks previews</div>
          <div style="font-size:0.8rem;color:var(--text-2);margin-top:0.25rem">Tap to upload a screenshot</div>
        </div>
        <div id="linkScreenshotPreview" class="screenshot-preview" style="display:none">
          <img id="linkScreenshotImg" src="">
          <button class="remove-btn" onclick="removeLinkScreenshot(event)"></button>
        </div>
      </div>
      <div style="display:flex;gap:0.75rem;margin-top:1.5rem">
        <button class="btn btn-secondary" style="flex:1" onclick="closeAddModal()">Cancel</button>
        <button class="btn btn-primary" style="flex:1" onclick="addLink()">Add Link</button>
      </div>
    </div>
    <div id="mediaTab" style="display:none">
      <div class="promo-banner"><strong> Share files</strong><p>Upload images, videos, PDFs, documents</p></div>
      <input type="file" id="newMediaFileInput" multiple accept="*/*" onchange="handleNewMediaUpload(event)">
      <div id="newMediaPreviewArea" style="margin-bottom:1rem;display:none">
        <label class="form-label">Selected Files</label>
        <div id="newMediaPreviewList" style="display:flex;flex-direction:column;gap:0.5rem;max-height:200px;overflow-y:auto"></div>
      </div>
      <button class="btn btn-primary" style="width:100%;margin-bottom:1rem" onclick="document.getElementById('newMediaFileInput').click()"> Choose Files</button>
      <div class="form-group"><label class="form-label">Title</label><input type="text" class="form-input" id="newMediaTitle" placeholder="My file"></div>
      <div class="form-group"><label class="form-label">Topic</label><select class="form-select" id="newMediaTopic"><option value="tech"> Tech</option><option value="news"> News</option><option value="food"> Food</option><option value="travel"> Travel</option><option value="entertainment"> Entertainment</option><option value="other"> Other</option></select></div>
      <div style="display:flex;gap:0.75rem"><button class="btn btn-secondary" style="flex:1" onclick="closeAddModal()">Cancel</button><button class="btn btn-primary" style="flex:1;opacity:0.5" id="createMediaCardBtn" onclick="createMediaCard()" disabled>Create</button></div>
    </div>
    <div id="thoughtTab" style="display:none">
      <div class="promo-banner"><strong> Share thoughts</strong><p>Post ideas, notes, quotes</p></div>
      <div class="form-group"><label class="form-label">Title (Optional)</label><input type="text" class="form-input" id="thoughtTitle" placeholder="Title..." oninput="updateThoughtPreview()"></div>
      <div class="form-group"><label class="form-label">Your Thought</label><textarea class="form-textarea" id="thoughtContent" placeholder="What's on your mind?" style="min-height:150px" oninput="updateThoughtPreview()"></textarea><div style="display:flex;justify-content:space-between;margin-top:0.5rem;font-size:0.7rem;color:var(--text-3)"><span id="thoughtCharCount">0 chars</span><span id="thoughtLineCount">0 lines</span></div></div>
      <div class="thought-preview" id="thoughtPreview" style="background:var(--gradient)"><div class="thought-preview-title" id="previewTitle"></div><div class="thought-preview-content" id="previewContent">Your thought here...</div></div>
      <div class="form-group"><label class="form-label">Topic</label><select class="form-select" id="thoughtTopic"><option value="tech"> Tech</option><option value="news"> News</option><option value="food"> Food</option><option value="travel"> Travel</option><option value="entertainment"> Entertainment</option><option value="other"> Other</option></select></div>
      <div style="display:flex;gap:0.75rem"><button class="btn btn-secondary" style="flex:1" onclick="closeAddModal()">Cancel</button><button class="btn btn-primary" style="flex:1;opacity:0.5" id="createThoughtBtn" onclick="createThoughtCard()" disabled>Post</button></div>
    </div>
  </div>
</div>

<!-- EDIT MODAL - MEDIA FOCUSED -->
<div class="modal" id="editModal">
  <div class="modal-content edit-modal">
    <div class="modal-header">
      <h2 class="modal-title">Edit Link</h2>
      <button class="modal-close" onclick="closeEditModal()"></button>
    </div>
    
    <!-- Main Layout: Media Left, Info Right (YouTube style) -->
    <div class="edit-media-layout">
      <!-- Left: Media Player / Thumbnail -->
      <div class="edit-media-column">
        <div class="edit-media-container" id="editMediaContainer">
          <div class="edit-media-player" id="editMediaPlayer">
            <!-- Media content injected here -->
          </div>
          <div class="edit-media-thumbnail" id="editMediaThumbnail" onclick="document.getElementById('screenshotUpload').click()">
            <input type="file" id="screenshotUpload" accept="image/*" onchange="handleScreenshotUpload(event)" style="display:none">
            <img id="detailImage" src="" alt="">
            <div class="edit-media-overlay">
              <span></span>
              <span>Change thumbnail</span>
            </div>
            <button class="edit-media-play-btn" id="editPlayBtn" onclick="playMedia(event)" style="display:none">
              
            </button>
          </div>
        </div>
        
        <!-- Title & URL under media -->
        <div class="edit-media-info">
          <input type="text" class="edit-title-input" id="editTitle" placeholder="Title...">
          <a class="edit-url-display" id="editUrlLink" href="#" target="_blank" rel="noopener">
            <span></span>
            <span id="editUrlText"></span>
          </a>
        </div>
        
        <!-- Votes Row -->
        <div class="edit-votes-row">
          <button class="edit-vote-btn upvote" onclick="voteCard(1)" title="Upvote"></button>
          <span class="edit-vote-score" id="editVoteScore">0</span>
          <button class="edit-vote-btn downvote" onclick="voteCard(-1)" title="Downvote"></button>
          
          <div class="edit-actions-quick">
            <button class="btn btn-icon" id="editStarBtn" onclick="toggleStar()" title="Star"></button>
            <button class="btn btn-icon" id="editSyncBtn" onclick="syncCardData(currentCardId)" title="Sync to cloud" style="display:none"></button>
            <button class="btn btn-icon" onclick="window.open(document.getElementById('editUrlLink').href)" title="Open Link"></button>
            <button class="btn btn-icon" onclick="navigator.clipboard.writeText(document.getElementById('editUrlLink').href);showToast('Copied!','success')" title="Copy Link"></button>
            <button class="btn btn-icon" onclick="shareLink()" title="Share"></button>
          </div>
        </div>
        
        <!-- Tags -->
        <div class="edit-tags-bar" id="editTagsBar">
          <div id="tagsContainer"></div>
          <input type="text" class="edit-tag-input" id="newTag" placeholder="+ Add tag..." onkeypress="if(event.key==='Enter'){addTag();event.preventDefault()}">
        </div>
      </div>
      
      <!-- Right: Notes & Comments -->
      <div class="edit-info-column">
        <!-- Notes Section (expanded by default) -->
        <div class="edit-section expanded">
          <div class="edit-section-header" onclick="toggleEditSection('notes')">
            <span class="edit-section-title"> Notes</span>
            <span class="edit-section-toggle"></span>
          </div>
          <div class="edit-section-content" id="editNotesSection">
            <textarea id="editNotes" placeholder="Add personal notes about this link..."></textarea>
          </div>
        </div>
        
        <!-- Photos Section -->
        <div class="edit-section">
          <div class="edit-section-header collapsed" onclick="toggleEditSection('photos')">
            <span class="edit-section-title"> Photos <span id="editPhotoCount"></span></span>
            <span class="edit-section-toggle"></span>
          </div>
          <div class="edit-section-content collapsed" id="editPhotosSection">
            <div class="edit-photo-grid" id="editPhotoGrid"></div>
            <input type="file" id="addPhoto" accept="image/*" multiple onchange="addPhotos(event)" style="display:none">
          </div>
        </div>
        
        <!-- Location Section -->
        <div class="edit-section">
          <div class="edit-section-header collapsed" onclick="toggleEditSection('location')">
            <span class="edit-section-title"> Location</span>
            <span class="edit-section-toggle"></span>
          </div>
          <div class="edit-section-content collapsed" id="editLocationSection">
            <div class="edit-location-row">
              <input type="text" id="editLocation" placeholder="Add location...">
              <button class="btn btn-secondary" onclick="getMyLocation()"></button>
            </div>
          </div>
        </div>
        
        <!-- Comments Section (always visible) -->
        <div class="edit-comments-section">
          <div class="edit-comments-header">
            <span class="edit-comments-title">
               Comments
              <span class="edit-comments-count" id="editCommentsCount">0</span>
            </span>
          </div>
          
          <div class="edit-comments-list" id="editCommentsList">
            <!-- Comments rendered here -->
          </div>
          
          <div class="edit-comment-input-area">
            <div class="edit-comment-input-row">
              <input type="text" class="edit-comment-input" id="newCommentInput" placeholder="Join the conversation..." onkeypress="if(event.key==='Enter'){addCommentFromInput();event.preventDefault()}">
              <button class="edit-comment-submit" onclick="addCommentFromInput()">Post</button>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- Footer -->
    <div class="edit-modal-footer">
      <div class="edit-footer-left">
        <label class="edit-privacy-toggle">
          <input type="checkbox" id="editPrivate" onchange="toggleCardPrivacy(currentCardId)">
          <span> Private</span>
        </label>
        <span class="edit-footer-meta" id="editFooterMeta"></span>
      </div>
      <div class="edit-footer-right">
        <button class="btn btn-danger" onclick="deleteCard()"> Delete</button>
      </div>
    </div>
  </div>
</div>
<!-- SETTINGS MODAL -->
<div class="modal" id="settingsModal">
  <div class="modal-content">
    <div class="modal-header"><h2 class="modal-title"> Settings</h2><button class="modal-close" onclick="closeSettings()"></button></div>
    
    <!-- Sign In Section (shows when NOT logged in) -->
    <div id="settingsSignInSection" class="form-group" style="background:linear-gradient(135deg,rgba(99,102,241,0.1) 0%,rgba(139,92,246,0.1) 100%);padding:1rem;border-radius:var(--radius-md);border:1px solid rgba(99,102,241,0.2);margin-bottom:1.5rem;">
      <div style="text-align:center;margin-bottom:1rem;">
        <span style="font-size:2rem;"></span>
        <h3 style="margin:0.5rem 0 0.25rem;font-size:1rem;">Sync Your Data</h3>
        <p style="color:var(--text-3);font-size:0.8rem;margin:0;">Access your links from any device</p>
      </div>
      <input type="email" class="form-input" id="settingsAuthEmail" placeholder="your@email.com" style="margin-bottom:0.5rem;">
      <button class="btn btn-primary" style="width:100%" onclick="sendMagicLinkFromSettings()"> Send Magic Link</button>
      <div id="settingsAuthStatus" style="margin-top:0.5rem;text-align:center;font-size:0.8rem;min-height:1.25rem;"></div>
    </div>
    
    <!-- Cloud Sync Section (shows when logged in) -->
    <div id="cloudSyncSection" class="form-group" style="display:none;background:rgba(16,185,129,0.1);padding:1rem;border-radius:var(--radius-md);border:1px solid rgba(16,185,129,0.3);margin-bottom:1.5rem;">
      <div style="display:flex;align-items:center;gap:0.75rem;margin-bottom:0.75rem;">
        <span style="font-size:1.5rem;"></span>
        <div>
          <div style="font-weight:600;font-size:0.9rem;">Signed in</div>
          <div id="userEmailDisplay" style="font-size:0.8rem;color:var(--success);"></div>
        </div>
      </div>
      <div style="display:flex;align-items:center;gap:0.5rem;padding:0.5rem;background:rgba(0,0,0,0.2);border-radius:var(--radius-sm);margin-bottom:0.75rem;">
        <span style="color:var(--success);font-size:0.9rem;"></span>
        <span style="font-size:0.75rem;color:var(--text-2);">Cloud sync active</span>
        <span id="lastSyncDisplay" style="font-size:0.7rem;color:var(--text-3);margin-left:auto;"></span>
      </div>
      <p style="font-size:0.75rem;color:var(--text-3);margin-bottom:0.75rem;">Your public cards sync automatically across all devices</p>
      <button class="btn btn-secondary" style="width:100%;margin-bottom:0.5rem" onclick="syncImagesToCloud()" id="syncImagesBtn"> Sync All Images to Cloud</button>
      <p style="font-size:0.7rem;color:var(--text-3);margin-bottom:0.75rem">Upload local screenshots so others can see them</p>
      <button class="btn btn-danger" style="width:100%" onclick="signOut()"> Sign Out</button>
    </div>
    
    <div class="form-group">
      <label class="form-label"> Display Name</label>
      <div style="position:relative;">
        <input type="text" class="form-input" id="usernameInput" placeholder="Choose a display name" 
               oninput="validateUsernameInput()" maxlength="30" style="padding-right:40px;">
        <span id="usernameStatus" style="position:absolute;right:12px;top:50%;transform:translateY(-50%);font-size:1rem;"></span>
      </div>
      <p id="usernameHint" style="font-size:0.7rem;color:var(--text-3);margin-top:0.5rem">This is how others see you. Your email is never shown.</p>
      <button class="btn btn-secondary" style="width:100%;margin-top:0.5rem" onclick="updateAllCardsUsername()" id="updateUsernameBtn"> Update all my cards with this name</button>
    </div>
    
    <div class="form-group">
      <label class="form-label"> Privacy</label>
      <label style="display:flex;align-items:center;gap:0.75rem;padding:0.75rem;background:var(--bg-elevated);border-radius:var(--radius-md);cursor:pointer;margin-bottom:0.5rem;">
        <input type="checkbox" id="showContributorsToggle" onchange="toggleShowContributors()" style="width:18px;height:18px;accent-color:var(--accent)">
        <span style="font-size:0.85rem">Show contributor names</span>
      </label>
      <label style="display:flex;align-items:center;gap:0.75rem;padding:0.75rem;background:var(--bg-elevated);border-radius:var(--radius-md);cursor:pointer;margin-bottom:0.5rem;">
        <input type="checkbox" id="profilePublicToggle" onchange="toggleProfilePublic()" style="width:18px;height:18px;accent-color:var(--accent)">
        <span style="font-size:0.85rem">Make my profile public</span>
      </label>
      <label style="display:flex;align-items:center;gap:0.75rem;padding:0.75rem;background:var(--bg-elevated);border-radius:var(--radius-md);cursor:pointer;">
        <input type="checkbox" id="defaultCardPrivateToggle" onchange="toggleDefaultCardPrivate()" style="width:18px;height:18px;accent-color:var(--accent)">
        <span style="font-size:0.85rem">New cards are private by default</span>
      </label>
      <p style="font-size:0.7rem;color:var(--text-3);margin-top:0.5rem">Private cards are only visible to you</p>
    </div>
    
    <div class="form-group"><label class="form-label">Top Contributors</label><div class="contributor-list" id="contributorList"><p style="color:var(--text-3);text-align:center;padding:1rem">No contributors yet</p></div></div>
    
    <div class="form-group"><label class="form-label">Share Collection</label><button class="btn btn-primary" style="width:100%;margin-bottom:0.5rem" onclick="shareCollectionURL(this,false)"> Share (with photos)</button><button class="btn btn-secondary" style="width:100%;margin-bottom:0.5rem" onclick="shareCollectionURL(this,true)"> Share (no photos)</button><button class="btn btn-secondary" style="width:100%" onclick="exportCollection()"> Export File</button></div>
    
    <div class="form-group">
      <label class="form-label"> Data Management</label>
      <button class="btn btn-secondary" style="width:100%;margin-bottom:0.5rem" onclick="clearAllData()"> Clear All Data</button>
      <button class="btn btn-secondary" style="width:100%" onclick="removeDuplicates()"> Remove Duplicates</button>
      <p style="font-size:0.7rem;color:var(--text-3);margin-top:0.5rem">Clear all data will reset the app. Remove duplicates will clean up repeated cards.</p>
    </div>
    
    <button class="btn btn-primary" style="width:100%;margin-top:1rem" onclick="saveSettings()">Save Settings</button>
  </div>
</div>

<!-- COMMUNITY MODAL -->
<div class="modal" id="communityModal">
  <div class="modal-content">
    <div class="modal-header"><h2 class="modal-title"> Community</h2><button class="modal-close" onclick="closeCommunity()"></button></div>
    <div class="form-group"><label class="form-label"> Top Contributors</label><div class="contributor-list" id="communityContributorList"></div></div>
    <div class="form-group"><label class="form-label"> Hot Cards</label><div class="contributor-list" id="hotCardsList" style="max-height:200px"></div></div>
    <div class="form-group"><label class="form-label"> Recent Activity</label><div class="contributor-list" id="recentActivityList" style="max-height:150px"></div></div>
    <label class="form-label"> Stats</label>
    <div class="stats-grid"><div class="stat-item"><div class="stat-label">Total Links</div><div class="stat-value" id="statsTotal">0</div></div><div class="stat-item"><div class="stat-label">Contributors</div><div class="stat-value" id="statsContributors">0</div></div><div class="stat-item"><div class="stat-label">Total Votes</div><div class="stat-value" id="statsVotes">0</div></div><div class="stat-item"><div class="stat-label">Comments</div><div class="stat-value" id="statsComments">0</div></div></div>
  </div>
</div>

<!-- COLLECTIONS MODAL -->
<div class="modal" id="collectionsModal">
  <div class="modal-content">
    <div class="modal-header"><h2 class="modal-title"> Collections</h2><button class="modal-close" onclick="closeCollections()"></button></div>
    <div class="promo-banner"><strong> Organize your way</strong><p>Create collections for different projects</p></div>
    <button class="btn btn-primary" style="width:100%;margin-bottom:1rem" onclick="createNewCollection()">+ Create Collection</button>
    <div id="collectionsList"></div>
  </div>
</div>

<!-- ADD TO COLLECTION MODAL -->
<div class="modal" id="addToCollectionModal">
  <div class="modal-content">
    <div class="modal-header"><h2 class="modal-title"> Save to Collection</h2><button class="modal-close" onclick="closeAddToCollection()"></button></div>
    <div style="padding:0.75rem;background:var(--bg-elevated);border-radius:var(--radius-md);margin-bottom:1rem"><div style="font-weight:600" id="addToCollectionCardTitle"></div><div style="font-size:0.75rem;color:var(--text-3)" id="addToCollectionCardUrl"></div></div>
    <div id="collectionsCheckboxList" style="display:flex;flex-direction:column;gap:0.5rem;margin-bottom:1rem;max-height:300px;overflow-y:auto"></div>
    <button class="btn btn-secondary" style="width:100%;margin-bottom:0.5rem" onclick="createCollectionFromModal()">+ New Collection</button>
    <button class="btn btn-primary" style="width:100%" onclick="saveToCollections()"> Save</button>
  </div>
</div>

<!-- QUICK ACTIONS MODAL -->
<div class="modal" id="quickActionsModal">
  <div class="modal-content">
    <div class="modal-header"><h2 class="modal-title"> Quick Actions</h2><button class="modal-close" onclick="closeQuickActions()"></button></div>
    <div id="quickActionsCardTitle" style="padding:0.75rem;background:var(--bg-elevated);border-radius:var(--radius-md);margin-bottom:1rem;font-size:0.9rem"></div>
    <div style="display:flex;flex-direction:column;gap:0.5rem">
      <button class="btn btn-secondary" onclick="quickActionAddToCollection()"> Add to Collection</button>
      <button class="btn btn-secondary" onclick="quickActionStar()"><span id="quickActionStarText"> Star</span></button>
      <button class="btn btn-secondary" onclick="quickActionCopyLink()"> Copy Link</button>
      <button class="btn btn-secondary" onclick="quickActionEdit()"> Edit</button>
      <button class="btn btn-danger" onclick="quickActionDelete()"> Delete</button>
    </div>
  </div>
</div>

<!-- AUTH MODAL -->
<div class="modal" id="authModal" style="z-index:9999">
  <div class="modal-content" style="max-width:450px">
    <div style="text-align:center;margin-bottom:2rem"><h1 style="font-size:2rem;background:var(--gradient);-webkit-background-clip:text;-webkit-text-fill-color:transparent">CommuneCollab</h1><p style="color:var(--text-3)">Community link sharing</p></div>
    <div class="promo-banner"><strong> Sign in to sync</strong><p>Access links from any device</p></div>
    <div class="form-group"><label class="form-label">Email</label><input type="email" class="form-input" id="authEmail" placeholder="your@email.com" onkeypress="if(event.key==='Enter')sendMagicLink()"></div>
    <button class="btn btn-primary" style="width:100%" id="sendMagicLinkBtn" onclick="sendMagicLink()"> Send Magic Link</button>
    <div id="authStatus" style="margin-top:1rem;text-align:center;font-size:0.85rem;min-height:1.5rem"></div>
    <button class="btn btn-ghost" style="width:100%;margin-top:1.5rem" onclick="document.getElementById('authModal').classList.remove('active')">Continue without sync</button>
  </div>
</div>
<!-- DISCOVER VIEW -->
<div class="discover-view" id="discoverView">
  <div class="discover-header">
  <div style="display:flex;align-items:center;gap:1.5rem;flex:1;">
    <div>
      <h2 style="font-size:1.25rem;font-weight:700;background:var(--gradient);-webkit-background-clip:text;-webkit-text-fill-color:transparent"> Discover</h2>
      <span style="font-size:0.75rem;color:var(--text-3)">Community feed</span>
    </div>
    <div class="discover-search-box">
      <span class="discover-search-icon"></span>
      <input type="text" class="discover-search-input" id="discoverSearchBar" placeholder="Search tags..." oninput="handleDiscoverSearch()">
    </div>
  </div>
  <div style="display:flex;gap:0.5rem;align-items:center">
    <button class="btn btn-secondary" onclick="closeDiscover()" style="font-size:0.8rem;padding:0.5rem 1rem;">
       My Cards
    </button>
    <select class="filter-select" id="discoverFilter" onchange="filterDiscoverByTag()">
      <option value="">All tags</option>
    </select>
    <button class="btn btn-primary discover-add-btn" onclick="openAddModal()" title="Share to community!">
      <span class="discover-add-icon">+</span>
      <span class="discover-add-text">Share</span>
    </button>
    <button class="btn btn-icon" onclick="closeDiscover()"></button>
  </div>
</div>
  <div class="discover-canvas" id="discoverCanvas">
    <svg id="connectionsSvg" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:5"></svg>
    <div class="bubble-container" id="bubbleContainer"></div>
    <div class="discover-stats">
      <div class="discover-stat"><strong id="statNodes">0</strong> cards</div>
      <div class="discover-stat"><strong id="statConnections">0</strong> connections</div>
    </div>
    <button class="discover-fab" onclick="openAddModal()" title="Share something new!">+</button>
    <div class="discover-controls">
      <button class="btn btn-secondary" onclick="zoomBubbles(1.2)" title="Zoom in">+</button>
      <button class="btn btn-secondary" onclick="zoomBubbles(0.8)" title="Zoom out"></button>
      <button class="btn btn-secondary" onclick="resetBubbleView()" title="Reset"></button>
      <button class="btn btn-secondary" onclick="shuffleBubbles()" title="Shuffle"></button>
    </div>
    <div class="discover-info" id="discoverInfo" style="display:none">
      <div class="discover-info-header">
        <div style="display:flex;align-items:flex-start;gap:0.75rem;flex:1;">
          <div class="discover-info-topic" id="infoTopic"></div>
          <h3 class="discover-info-title" id="infoTitle"></h3>
        </div>
        <button class="btn btn-ghost" onclick="closeDiscoverInfo()" style="padding:0.25rem;margin:-0.25rem;"></button>
      </div>
      <p class="discover-info-url" id="infoUrl"></p>
      <div class="discover-info-tags" id="infoTags"></div>
      <p class="discover-info-notes" id="infoNotes"></p>
      <div class="discover-info-actions">
        <button class="btn btn-primary" onclick="openCardFromDiscover()">Open Card</button>
        <button class="btn btn-secondary" onclick="focusOnBubble(selectedBubbleId)">Focus</button>
      </div>
    </div>
  </div>
</div>

<script>
// ============== CONFIGURATION ==============
const SUPABASE_URL = 'https://pehkbinywnrrfhcsadqf.supabase.co';
const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InBlaGtiaW55d25ycmZoY3NhZHFmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkzNjUxOTgsImV4cCI6MjA4NDk0MTE5OH0.VXu_F-YDtaQxU92XFUlqv1_qQi5DrJeQiGbcvGkrBew';

// ============== GLOBAL VARIABLES ==============
let supabaseClient = null, currentUser = null, db;
let cards = [], collections = [], userVotes = {};
let currentCardId = null, currentTopic = 'all', sortMode = 'date';
let searchQuery = '', showOnlyStarred = false, currentCollectionFilter = '';
let username = 'You', headerCollapsed = false, showContributors = true;
let compactCards = new Set(), bulkSelectMode = false, selectedCards = new Set();
let selectedNewMediaFiles = [], currentCardForCollection = null;
let pendingLinkScreenshot = null;
let currentQuickActionCardId = null;


// ============== INDEXEDDB ==============
const DB_NAME = 'CommuneCollabDB', DB_VERSION = 1, IMAGE_STORE = 'images';

async function initDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onerror = () => reject(req.error);
    req.onsuccess = () => { db = req.result; resolve(db); };
    req.onupgradeneeded = (e) => {
      const database = e.target.result;
      if (!database.objectStoreNames.contains(IMAGE_STORE)) database.createObjectStore(IMAGE_STORE);
    };
  });
}

async function storeImage(key, data) {
  if (!db) await initDB();
  return new Promise((res, rej) => {
    const tx = db.transaction([IMAGE_STORE], 'readwrite');
    const req = tx.objectStore(IMAGE_STORE).put(data, key);
    req.onsuccess = () => res(); req.onerror = () => rej(req.error);
  });
}

async function getImage(key) {
  if (!db) await initDB();
  return new Promise((res, rej) => {
    const tx = db.transaction([IMAGE_STORE], 'readonly');
    const req = tx.objectStore(IMAGE_STORE).get(key);
    req.onsuccess = () => res(req.result); req.onerror = () => rej(req.error);
  });
}

// ============== TOAST ==============
function showToast(msg, type = 'default') {
  const t = document.getElementById('toast');
  t.textContent = msg; t.className = 'toast show ' + type;
  setTimeout(() => t.classList.remove('show'), 3000);
}
// ============== SECURITY ==============
// Sanitization to prevent XSS attacks (not over-aggressive)
function sanitizeHTML(str) {
  if (!str) return '';
  return String(str)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;');
  // Note: apostrophes (') and forward slashes (/) are safe in text content
}
// Sanitize URL to prevent javascript: and data: exploits
function sanitizeURL(url) {
  if (!url) return '';
  const str = String(url).trim();
  const lower = str.toLowerCase();
  
  // Block dangerous protocols
  if (lower.startsWith('javascript:') || 
      lower.startsWith('data:text/html') ||
      lower.startsWith('vbscript:')) {
    return '';
  }
  
  // Allow safe protocols (return original, not lowercased)
  if (lower.startsWith('http://') || 
      lower.startsWith('https://') || 
      lower.startsWith('mailto:') ||
      lower.startsWith('thought://') ||
      lower.startsWith('media://')) {
    return str; // Return original URL, preserving case
  }
  
  // Default: assume https
  if (!lower.includes('://')) {
    return 'https://' + str;
  }
  
  return '';
}

// Sanitize imported card data
function sanitizeCardData(card) {
  return {
    id: typeof card.id === 'number' ? card.id : Date.now(),
    url: sanitizeURL(card.url) || 'about:blank',
    title: sanitizeHTML(String(card.title || 'Untitled').substring(0, 200)),
    notes: sanitizeHTML(String(card.notes || '').substring(0, 5000)),
    location: sanitizeHTML(String(card.location || '').substring(0, 200)),
    tags: Array.isArray(card.tags) 
      ? card.tags.slice(0, 20).map(t => sanitizeHTML(String(t).substring(0, 50)))
      : [],
    topic: ['tech', 'news', 'food', 'travel', 'entertainment', 'other'].includes(card.topic) 
      ? card.topic 
      : 'other',
    votes: typeof card.votes === 'number' ? Math.max(-1000, Math.min(1000, card.votes)) : 0,
    screenshot: sanitizeURL(card.screenshot),
    screenshotReal: Boolean(card.screenshotReal),
    isPrivate: Boolean(card.isPrivate),
    starred: Boolean(card.starred),
    photos: Array.isArray(card.photos) 
      ? card.photos.slice(0, 20).filter(p => typeof p === 'string' && (p.startsWith('data:image/') || sanitizeURL(p)))
      : [],
    comments: Array.isArray(card.comments)
      ? card.comments.slice(0, 100).map(c => ({
          id: typeof c.id === 'number' ? c.id : Date.now(),
          text: sanitizeHTML(String(c.text || '').substring(0, 1000)),
          author: sanitizeHTML(String(c.author || 'Anonymous').substring(0, 50)),
          timestamp: c.timestamp || new Date().toISOString()
        }))
      : [],
    addedBy: sanitizeHTML(String(card.addedBy || 'Unknown').substring(0, 50)),
    createdAt: card.createdAt || new Date().toISOString(),
    lastEdited: card.lastEdited || new Date().toISOString(),
    editedBy: sanitizeHTML(String(card.editedBy || 'Unknown').substring(0, 50))
  };
}

// Validate and sanitize username
function sanitizeUsername(name) {
  if (!name) return 'Anonymous';
  return sanitizeHTML(String(name).substring(0, 50).replace(/[<>'"]/g, ''));
}
// ============== DISCOVER BUBBLE VIEW ==============
let bubbles = [];
let isMobileDevice = false; // Will be set on init
let bubbleConnections = [];
let selectedBubbleId = null;
let bubbleZoom = 1;
let bubblePanX = 0, bubblePanY = 0;
let isDraggingCanvas = false, dragStartX = 0, dragStartY = 0;
let ambientFrame = null;
let isAnyCardHovered = false;
let centerCardId = null;
let lastClickTime = 0;
let lastClickId = null;
let hoveredBubbleId = null;

const TOPIC_COLORS = {
  tech: '#6366f1',
  news: '#f59e0b',
  food: '#10b981',
  travel: '#06b6d4',
  entertainment: '#ec4899',
  other: '#8b5cf6'
};

// Golden angle for Fibonacci spiral (in radians)
const GOLDEN_ANGLE = Math.PI * (3 - Math.sqrt(5));

// Guide cards for new users
const GUIDE_CARDS = [
  { id: 'guide_1', title: 'Welcome to CommuneCollab', url: 'thought://welcome-guide', tags: ['guide', 'welcome', 'start', 'community'], topic: 'other', notes: 'Your community hub for sharing links, ideas, and discoveries. Tap any card to explore, or use the controls to navigate this constellation of shared knowledge.', votes: 42, addedBy: 'CommuneCollab', isGuide: true },
  { id: 'guide_2', title: 'How Tags Work', url: 'thought://tags-guide', tags: ['guide', 'tags', 'organize', 'connections'], topic: 'tech', notes: 'Tags are the threads that weave ideas together. Add tags to your cards and watch connections form automatically. The more tags overlap, the stronger the connection.', votes: 38, addedBy: 'CommuneCollab', isGuide: true },
  { id: 'guide_3', title: 'Create Collections', url: 'thought://collections-guide', tags: ['guide', 'collections', 'organize'], topic: 'other', notes: 'Group related links into collections for easy access and sharing. Perfect for research projects, trip planning, or curating resources.', votes: 35, addedBy: 'CommuneCollab', isGuide: true },
  { id: 'guide_4', title: 'Share & Collaborate', url: 'thought://share-guide', tags: ['guide', 'share', 'community'], topic: 'travel', notes: 'Share your collection with friends or the world. Collaboration makes knowledge grow.', votes: 28, addedBy: 'CommuneCollab', isGuide: true },
  { id: 'guide_5', title: 'Vote on What Matters', url: 'thought://voting-guide', tags: ['guide', 'community', 'voting'], topic: 'news', notes: 'Upvote links you find valuable, downvote what misses the mark. Your votes help surface the best content.', votes: 30, addedBy: 'CommuneCollab', isGuide: true },
  { id: 'guide_6', title: 'Thought Cards', url: 'thought://thoughts-guide', tags: ['guide', 'thoughts', 'create'], topic: 'entertainment', notes: 'No link? No problem. Create Thought Cards to share ideas, quotes, or insights directly.', votes: 25, addedBy: 'CommuneCollab', isGuide: true },
  { id: 'guide_7', title: 'Discover Connections', url: 'thought://discover-guide', tags: ['guide', 'discover', 'connections', 'explore'], topic: 'tech', notes: 'You are here! This view shows how ideas connect through shared tags. Click cards to see their connections light up.', votes: 22, addedBy: 'CommuneCollab', isGuide: true }
];

// Celestial classification thresholds
const CELESTIAL_CONFIG = {
  // Mass calculation weights
  massWeights: {
    connection: 3,
    vote: 2,
    freshness: 5,
    trending: 4
  },
  
  // Classification thresholds (mass ranges)
  thresholds: {
    star: 25,      // mass >= 25  star
    planet: 10,    // mass >= 10  planet
    moon: 3,       // mass >= 3  moon
    comet: 0,      // new cards (< 72 hours)
    asteroid: 0    // old + low mass
  },
  
  // Size ranges (in pixels)
  sizes: {
    star: { min: 260, max: 300 },
    planet: { min: 200, max: 250 },
    moon: { min: 160, max: 190 },
    comet: { min: 200, max: 240 },  // boosted for visibility
    asteroid: { min: 140, max: 160 }
  },
  
  // Orbital distances from parent
  orbits: {
    planet: { min: 280, max: 450 },  // distance from star
    moon: { min: 180, max: 280 }      // distance from planet
  },
  
  // Time thresholds (in hours)
  time: {
    cometAge: 72,     // cards < 72 hours old are comets
    freshBoost: 48    // peak freshness boost < 48 hours
  },
  
  // Layout zones (percentage of canvas)
  zones: {
    cometY: 0.12,      // top 12% for comet zone
    asteroidRing: 0.9, // outer 10% for asteroids
    mainGalaxy: 0.75   // center 75% for star systems
  }
};

// Card age in hours
function getCardAgeHours(card) {
  const created = new Date(card.createdAt || Date.now());
  return (Date.now() - created.getTime()) / (1000 * 60 * 60);
}

// Calculate freshness multiplier (1.0 for old, up to 2.0 for brand new)
function getFreshnessMultiplier(card) {
  const ageHours = getCardAgeHours(card);
  if (ageHours > CELESTIAL_CONFIG.time.cometAge) return 1.0;
  // Exponential decay from 2.0 to 1.0 over 72 hours
  return 1.0 + Math.exp(-ageHours / 24);
}

// Calculate trending boost (based on recent vote velocity)
function getTrendingBoost(card) {
  // Simple approximation: votes / age gives velocity
  const ageHours = Math.max(getCardAgeHours(card), 1);
  const votes = Math.abs(card.votes || 0);
  return Math.min(votes / (ageHours / 24), 10); // cap at 10
}

// Calculate card "mass" (gravitational importance)
function calculateMass(card) {
  const w = CELESTIAL_CONFIG.massWeights;
  
  const connectionMass = Math.min(card.connectionCount || 0, 15) * w.connection;
  const voteMass = Math.log(Math.abs(card.votes || 0) + 1) * w.vote;
  const freshnessMass = (getFreshnessMultiplier(card) - 1) * w.freshness;
  const trendingMass = getTrendingBoost(card) * w.trending;
  
  return connectionMass + voteMass + freshnessMass + trendingMass;
}

// Classify card into celestial type
function classifyCard(card) {
  const ageHours = getCardAgeHours(card);
  const mass = card.mass || 0;
  const t = CELESTIAL_CONFIG.thresholds;
  
  // New cards are comets (regardless of mass)
  if (ageHours < CELESTIAL_CONFIG.time.cometAge) {
    return 'comet';
  }
  
  // Guide cards are always stars
  if (card.isGuide) {
    return 'star';
  }
  
  // Old cards with very low mass are asteroids
  if (mass < t.moon && ageHours > CELESTIAL_CONFIG.time.cometAge * 2) {
    return 'asteroid';
  }
  
  // Classification by mass
  if (mass >= t.star) return 'star';
  if (mass >= t.planet) return 'planet';
  if (mass >= t.moon) return 'moon';
  
  return 'asteroid';
}

// Get card size based on classification and mass
function getCardSize(card) {
  const type = card.celestialType || 'asteroid';
  const sizes = CELESTIAL_CONFIG.sizes[type];
  const mass = card.mass || 0;
  
  // Normalize mass to 0-1 range for size interpolation
  const maxMass = CELESTIAL_CONFIG.thresholds.star * 2;
  const normalizedMass = Math.min(mass / maxMass, 1);
  
  let size = sizes.min + (sizes.max - sizes.min) * normalizedMass;
  
  // Scale down for mobile
  if (isMobileDevice || window.innerWidth < 768) {
    size = Math.max(120, size * 0.6); // 60% size, minimum 120px
  }
  
  return size;
}

function openDiscover() {
  document.getElementById('discoverView').classList.add('active');
  
  // Reset view state
  isAnyCardHovered = false;
  hoveredBubbleId = null;
  
  // Set initial zoom based on screen size
  const isMobileView = window.innerWidth < 768;
  if (isMobileView) {
    bubbleZoom = 0.6;  // Start zoomed out on mobile
    bubblePanX = 0;
    bubblePanY = 0;
  } else {
    bubbleZoom = 1;
    bubblePanX = 0;
    bubblePanY = 0;
  }
  
  initBubbleView();
}

function closeDiscover() {
  document.getElementById('discoverView').classList.remove('active');
  if (ambientFrame) { 
    cancelAnimationFrame(ambientFrame); 
    ambientFrame = null; 
  }
  selectedBubbleId = null;
  hoveredBubbleId = null;
}

function closeDiscoverInfo() {
  document.getElementById('discoverInfo').style.display = 'none';
  selectedBubbleId = null;
  document.querySelectorAll('.bubble-card').forEach(b => {
    b.classList.remove('selected', 'related');
  });
  hideConnections();
}

async function initBubbleView() {
  const container = document.getElementById('bubbleContainer');
  container.innerHTML = `
    <div class="discover-loading">
      <div class="discover-loading-spinner"></div>
      <span style="color: var(--text-2);">Mapping the cosmos...</span>
    </div>
  `;
  
  await buildBubbleData();
  populateTagFilter();
  createBackgroundEffects();
  layoutCelestialSystem();  // Changed from layoutFibonacciSpiral()
  renderBubbles();
  setupCanvasDrag();
  startAmbientAnimation();
}

// Create star field and ambient particles
function createBackgroundEffects() {
  const canvas = document.getElementById('discoverCanvas');
  
  // Remove existing effects
  canvas.querySelectorAll('.star-field, .ambient-particles').forEach(el => el.remove());
  
  // Create star field
  const starField = document.createElement('div');
  starField.className = 'star-field';
  
  for (let i = 0; i < 100; i++) {
    const star = document.createElement('div');
    star.className = 'star';
    star.style.left = `${Math.random() * 100}%`;
    star.style.top = `${Math.random() * 100}%`;
    star.style.setProperty('--duration', `${2 + Math.random() * 4}s`);
    star.style.setProperty('--opacity', `${0.3 + Math.random() * 0.5}`);
    starField.appendChild(star);
  }
  
  canvas.insertBefore(starField, canvas.firstChild);
  
  // Create ambient particles
  const particles = document.createElement('div');
  particles.className = 'ambient-particles';
  
  const particleColors = ['#6366f1', '#8b5cf6', '#ec4899', '#06b6d4', '#10b981'];
  
  for (let i = 0; i < 20; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.left = `${Math.random() * 100}%`;
    particle.style.top = `${Math.random() * 100}%`;
    particle.style.width = `${4 + Math.random() * 8}px`;
    particle.style.height = particle.style.width;
    particle.style.background = particleColors[Math.floor(Math.random() * particleColors.length)];
    particle.style.setProperty('--duration', `${10 + Math.random() * 20}s`);
    particle.style.setProperty('--dx', `${(Math.random() - 0.5) * 100}px`);
    particle.style.setProperty('--dy', `${(Math.random() - 0.5) * 100}px`);
    particles.appendChild(particle);
  }
  
  canvas.insertBefore(particles, canvas.firstChild);
}

async function buildBubbleData() {
  const container = document.getElementById('bubbleContainer');
  container.innerHTML = `
    <div class="discover-loading">
      <div class="discover-loading-spinner"></div>
      <span style="color: var(--text-2);">Mapping the cosmos...</span>
    </div>
  `;
  
// Fetch community cards - allow even for anonymous users (read-only)
  // Fetch community cards - allow even for anonymous users (read-only)
  let communityCards = [];
  if (supabaseClient) {
    try {
      communityCards = await fetchCommunityCards();
      console.log(` Fetched ${communityCards.length} community cards`);
    } catch (e) {
      console.error('Failed to fetch community cards:', e);
    }
  }
  
  // Filter out promoted guide cards
  const promotedGuideUrls = new Set(
    cards.filter(c => c.url?.startsWith('thought://') && c.url?.includes('-guide'))
         .map(c => c.url)
  );
  
  const activeGuides = GUIDE_CARDS.filter(g => !promotedGuideUrls.has(g.url));
  
  const guidesWithImages = activeGuides.map(g => ({
    ...g,
    screenshot: generatePlaceholderThumbnail(g),
    photos: [],
    comments: [],
    starred: false,
    isPrivate: false
  }));
  
  // Merge local and community cards
  const seenUrls = new Set();
  const allUserCards = [];
  
  cards.forEach(c => {
    if (!seenUrls.has(c.url)) {
      seenUrls.add(c.url);
      allUserCards.push({ ...c, isGuide: false });
    }
  });
  
  communityCards.forEach(c => {
    if (!seenUrls.has(c.url)) {
      seenUrls.add(c.url);
      allUserCards.push({ ...c, isGuide: false, isCommunity: true });
    }
  });
  
  const allCards = [...guidesWithImages, ...allUserCards];
  
  // Create bubble objects
  bubbles = allCards.map((c, index) => ({
    ...c,
    bubbleId: String(c.id),
    x: 0, y: 0,
    baseX: 0, baseY: 0,
    index: index,
    connectionCount: 0,
    mass: 0,
    celestialType: 'asteroid',
    parentId: null,  // for moons/planets
    systemId: null,  // which star system
    orbitAngle: Math.random() * Math.PI * 2,
    orbitSpeed: 0.0002 + Math.random() * 0.0001,
    breathDelay: Math.random() * 4
  }));
  
  // Build connections based on shared tags
  bubbleConnections = [];
  for (let i = 0; i < bubbles.length; i++) {
    for (let j = i + 1; j < bubbles.length; j++) {
      const shared = (bubbles[i].tags || []).filter(t => (bubbles[j].tags || []).includes(t));
      if (shared.length > 0) {
        bubbleConnections.push({
          source: bubbles[i].bubbleId,
          target: bubbles[j].bubbleId,
          sharedTags: shared,
          strength: shared.length
        });
      }
    }
  }
  
  // Calculate connection counts
  bubbles.forEach(b => {
    b.connectionCount = bubbleConnections
      .filter(c => c.source === b.bubbleId || c.target === b.bubbleId)
      .reduce((sum, c) => sum + c.strength, 0);
  });
  
  // Calculate mass and classify each card
  bubbles.forEach(b => {
    b.mass = calculateMass(b);
    b.celestialType = classifyCard(b);
    b.size = getCardSize(b);
  });
  
  // Identify star systems (find stars and their orbiting bodies)
  identifyStarSystems();
  
  // Update stats
  document.getElementById('statNodes').textContent = bubbles.length;
  document.getElementById('statConnections').textContent = bubbleConnections.length;
}

// Identify star systems and assign relationships
function identifyStarSystems() {
  // Get all stars
  const stars = bubbles.filter(b => b.celestialType === 'star');
  const planets = bubbles.filter(b => b.celestialType === 'planet');
  const moons = bubbles.filter(b => b.celestialType === 'moon');
  const comets = bubbles.filter(b => b.celestialType === 'comet');
  const asteroids = bubbles.filter(b => b.celestialType === 'asteroid');
  
  // If no stars, promote the highest mass card to be a star
  if (stars.length === 0 && bubbles.length > 0) {
    const sorted = [...bubbles].sort((a, b) => b.mass - a.mass);
    if (sorted[0]) {
      sorted[0].celestialType = 'star';
      sorted[0].size = getCardSize(sorted[0]);
      stars.push(sorted[0]);
    }
  }
  
  // Assign each star a system ID
  stars.forEach((star, i) => {
    star.systemId = `system_${i}`;
  });
  
  // Assign planets to nearest star (by tag overlap)
  planets.forEach(planet => {
    let bestStar = null;
    let bestOverlap = 0;
    
    stars.forEach(star => {
      const overlap = (planet.tags || []).filter(t => (star.tags || []).includes(t)).length;
      if (overlap > bestOverlap) {
        bestOverlap = overlap;
        bestStar = star;
      }
    });
    
    // If no tag overlap, assign to nearest by mass
    if (!bestStar && stars.length > 0) {
      bestStar = stars[0];
    }
    
    if (bestStar) {
      planet.parentId = bestStar.bubbleId;
      planet.systemId = bestStar.systemId;
    }
  });
  
  // Assign moons to nearest planet (by tag overlap)
  moons.forEach(moon => {
    let bestPlanet = null;
    let bestOverlap = 0;
    
    planets.forEach(planet => {
      const overlap = (moon.tags || []).filter(t => (planet.tags || []).includes(t)).length;
      if (overlap > bestOverlap) {
        bestOverlap = overlap;
        bestPlanet = planet;
      }
    });
    
    if (bestPlanet) {
      moon.parentId = bestPlanet.bubbleId;
      moon.systemId = bestPlanet.systemId;
    } else if (stars.length > 0) {
      // No planet match, orbit nearest star directly
      moon.parentId = stars[0].bubbleId;
      moon.systemId = stars[0].systemId;
    }
  });
  
  // Comets get assigned to nearest system by tags (but stay in comet zone)
  comets.forEach(comet => {
    let bestStar = null;
    let bestOverlap = 0;
    
    stars.forEach(star => {
      const overlap = (comet.tags || []).filter(t => (star.tags || []).includes(t)).length;
      if (overlap > bestOverlap) {
        bestOverlap = overlap;
        bestStar = star;
      }
    });
    
    if (bestStar) {
      comet.systemId = bestStar.systemId;
      comet.potentialParentId = bestStar.bubbleId; // where it might go
    }
  });
  
  // Asteroids stay unassigned (asteroid belt)
}

// ========== CELESTIAL LAYOUT SYSTEM ==========
// Multi-cluster layout with mobile optimization

function layoutCelestialSystem() {
  const canvas = document.getElementById('discoverCanvas');
  const rect = canvas.getBoundingClientRect();
  const width = rect.width || window.innerWidth;
  const height = rect.height || window.innerHeight - 80;
  const centerX = width / 2;
  const centerY = height / 2;
  
  if (bubbles.length === 0) return;
  
  // ===== MOBILE VS DESKTOP CONFIG =====
  const isMobileLayout = window.innerWidth < 768;
  const config = isMobileLayout ? {
    baseSpacing: 30,
    spiralMultiplier: 45,
    collisionPadding: 12,
    maxIterations: 60,
    margin: 60,
    clusterGap: 60
  } : {
    baseSpacing: 70,
    spiralMultiplier: 105,
    collisionPadding: 25,
    maxIterations: 40,
    margin: 120,
    clusterGap: 150
  };
  
  // ===== STEP 1: Build connection map =====
  bubbles.forEach(bubble => {
    bubble.connections = {};
    bubble.totalConnections = 0;
  });
  
  for (let i = 0; i < bubbles.length; i++) {
    for (let j = i + 1; j < bubbles.length; j++) {
      const a = bubbles[i];
      const b = bubbles[j];
      const shared = (a.tags || []).filter(t => (b.tags || []).includes(t)).length;
      
      if (shared > 0) {
        a.connections[b.bubbleId] = shared;
        b.connections[a.bubbleId] = shared;
        a.totalConnections += shared;
        b.totalConnections += shared;
      }
    }
  }
  
  // ===== STEP 2: Split into connected vs orphans =====
  const connectedCards = bubbles.filter(b => b.totalConnections > 0);
  const orphanCards = bubbles.filter(b => b.totalConnections === 0);
  
  // ===== STEP 3: Sort connected cards by connectivity =====
  const placed = [];
  const unplaced = [...connectedCards];
  
  if (unplaced.length > 0) {
    unplaced.sort((a, b) => b.totalConnections - a.totalConnections);
    placed.push(unplaced.shift());
    
    while (unplaced.length > 0) {
      let bestCard = null;
      let bestScore = -Infinity;
      
      unplaced.forEach(candidate => {
        let connectionScore = 0;
        placed.forEach(placedCard => {
          connectionScore += candidate.connections[placedCard.bubbleId] || 0;
        });
        const score = connectionScore * 10 + (candidate.mass || 0) * 0.001;
        if (score > bestScore) {
          bestScore = score;
          bestCard = candidate;
        }
      });
      
      const idx = unplaced.indexOf(bestCard);
      if (idx > -1) {
        unplaced.splice(idx, 1);
        placed.push(bestCard);
      }
    }
  }
  
  // ===== STEP 4: Fibonacci spiral for connected cards =====
  const spiralCenterX = centerX;
  const spiralCenterY = centerY;
  
  placed.forEach((bubble, i) => {
    // Get card size (already scaled for mobile via getCardSize)
    const cardSize = bubble.size || 200;
    
    if (i === 0) {
      bubble.x = spiralCenterX;
      bubble.y = spiralCenterY;
    } else {
      const angle = i * GOLDEN_ANGLE;
      const sizeMultiplier = 1 + (cardSize - 150) / 400;
      const radius = config.baseSpacing + Math.sqrt(i) * (config.spiralMultiplier * sizeMultiplier);
      
      bubble.x = spiralCenterX + Math.cos(angle) * radius;
      bubble.y = spiralCenterY + Math.sin(angle) * radius;
    }
    
    bubble.baseX = bubble.x;
    bubble.baseY = bubble.y;
    bubble.orbitCenterX = spiralCenterX;
    bubble.orbitCenterY = spiralCenterY;
    bubble.orbitRadius = Math.sqrt((bubble.x - spiralCenterX) ** 2 + (bubble.y - spiralCenterY) ** 2);
    bubble.orbitAngle = Math.atan2(bubble.y - spiralCenterY, bubble.x - spiralCenterX);
    
    // Animation speed
    const distanceFactor = Math.max(0.2, 1 - (bubble.orbitRadius / 1000));
    bubble.orbitSpeed = bubble.celestialType === 'star' ? 0 : 0.00005 * distanceFactor;
  });
  
  // ===== STEP 5: Position orphans in outer ring =====
  if (orphanCards.length > 0) {
    let maxClusterRadius = 0;
    placed.forEach(b => {
      const dist = Math.sqrt((b.x - spiralCenterX) ** 2 + (b.y - spiralCenterY) ** 2);
      const cardRadius = (b.size || 200) / 2;
      maxClusterRadius = Math.max(maxClusterRadius, dist + cardRadius);
    });
    
    const orphanZoneInnerRadius = maxClusterRadius + config.clusterGap;
    const orphanZoneOuterRadius = Math.min(width, height) / 2 - config.margin;
    
    orphanCards.forEach((orphan, i) => {
      const baseAngle = (i / orphanCards.length) * Math.PI * 2;
      const angleVariation = (Math.random() - 0.5) * 0.8;
      const angle = baseAngle + angleVariation;
      
      const radiusRange = Math.max(50, orphanZoneOuterRadius - orphanZoneInnerRadius);
      const radius = orphanZoneInnerRadius + Math.random() * radiusRange;
      
      orphan.x = spiralCenterX + Math.cos(angle) * radius;
      orphan.y = spiralCenterY + Math.sin(angle) * radius;
      
      orphan.baseX = orphan.x;
      orphan.baseY = orphan.y;
      orphan.orbitCenterX = spiralCenterX;
      orphan.orbitCenterY = spiralCenterY;
      orphan.orbitRadius = radius;
      orphan.orbitAngle = angle;
      orphan.orbitSpeed = 0.00003;
    });
  }
  
  // ===== STEP 6: Collision resolution =====
  resolveCollisionsWithConfig(placed, config);
  resolveCollisionsWithConfig(orphanCards, config);
  
  // ===== STEP 6.5: Tag proximity - pull related cards closer, push unrelated apart =====
  const allCards = [...placed, ...orphanCards];
  enforceTagProximity(allCards, config);
  
  // ===== STEP 6.6: Re-resolve collisions with MORE padding =====
  // (ensure cards don't overlap after adjustments)
  resolveCollisionsWithConfig(allCards, { 
    ...config, 
    collisionPadding: config.collisionPadding * 1.2, // More spacing between all cards
    maxIterations: 30 
  });
  
  
  // ===== STEP 7: Ensure all visible =====
  const margin = config.margin;
  bubbles.forEach(b => {
    const halfSize = (b.size || 200) / 2;
    b.x = Math.max(margin, Math.min(width - margin - halfSize, b.x));
    b.y = Math.max(margin, Math.min(height - margin - halfSize, b.y));
    b.baseX = b.x;
    b.baseY = b.y;
  });
}

// Collision resolution with configurable padding
function resolveCollisionsWithConfig(cardGroup, config) {
  if (!cardGroup || cardGroup.length < 2) return;
  
  const padding = config?.collisionPadding || 25;
  const maxIterations = config?.maxIterations || 40;
  
  for (let iter = 0; iter < maxIterations; iter++) {
    let hadCollision = false;
    
    for (let i = 0; i < cardGroup.length; i++) {
      for (let j = i + 1; j < cardGroup.length; j++) {
        const a = cardGroup[i];
        const b = cardGroup[j];
        
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        const minDist = ((a.size || 200) + (b.size || 200)) / 2 + padding;
        
        if (dist < minDist) {
          hadCollision = true;
          const overlap = (minDist - dist) / 2;
          const pushX = (dx / dist) * overlap;
          const pushY = (dy / dist) * overlap;
          
          const aWeight = (a.totalConnections || 0) + 1;
          const bWeight = (b.totalConnections || 0) + 1;
          const totalWeight = aWeight + bWeight;
          
          a.x -= pushX * (bWeight / totalWeight);
          a.y -= pushY * (bWeight / totalWeight);
          b.x += pushX * (aWeight / totalWeight);
          b.y += pushY * (aWeight / totalWeight);
        }
      }
    }
    
    if (!hadCollision) break;
  }
  
  cardGroup.forEach(b => {
    b.baseX = b.x;
    b.baseY = b.y;
  });
}

// Enforce that cards sharing tags stay within a reasonable distance
// while also pushing apart cards that DON'T share tags
function enforceTagProximity(cardGroup, config) {
  if (!cardGroup || cardGroup.length < 2) return;
  
  const isMobileLayout = window.innerWidth < 768;
  
  // Distance settings - more generous
  const MAX_TAG_DISTANCE = isMobileLayout ? 400 : 600; // Max pixels for cards sharing tags
  const MIN_NO_TAG_DISTANCE = isMobileLayout ? 180 : 280; // Min pixels for cards NOT sharing tags
  const PULL_STRENGTH = 0.15; // Gentle pull (was 0.4)
  const PUSH_STRENGTH = 0.1; // Gentle push for unrelated cards
  const maxIterations = 15;
  
  for (let iter = 0; iter < maxIterations; iter++) {
    let hadAdjustment = false;
    
    for (let i = 0; i < cardGroup.length; i++) {
      for (let j = i + 1; j < cardGroup.length; j++) {
        const a = cardGroup[i];
        const b = cardGroup[j];
        
        // Check shared tags
        const aTags = (a.tags || []).map(t => t.toLowerCase());
        const bTags = (b.tags || []).map(t => t.toLowerCase());
        const sharedTags = aTags.filter(t => bTags.includes(t));
        
        // Calculate distance
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.sqrt(dx * dx + dy * dy) || 1;
        
        // Weight by connection count (more connected cards are "heavier")
        const aWeight = (a.totalConnections || 0) + (a.mass || 1) + 1;
        const bWeight = (b.totalConnections || 0) + (b.mass || 1) + 1;
        const totalWeight = aWeight + bWeight;
        
        if (sharedTags.length > 0) {
          // PULL together cards that share tags (if too far apart)
          
          // More shared tags = closer together
          const proximityMultiplier = 1 / (1 + (sharedTags.length - 1) * 0.2);
          const adjustedMaxDist = MAX_TAG_DISTANCE * proximityMultiplier;
          
          if (dist > adjustedMaxDist) {
            hadAdjustment = true;
            
            const pullDistance = (dist - adjustedMaxDist) * PULL_STRENGTH;
            const pullX = (dx / dist) * pullDistance;
            const pullY = (dy / dist) * pullDistance;
            
            // Move toward each other
            a.x += pullX * (bWeight / totalWeight);
            a.y += pullY * (bWeight / totalWeight);
            b.x -= pullX * (aWeight / totalWeight);
            b.y -= pullY * (aWeight / totalWeight);
          }
        } else {
          // PUSH apart cards that don't share any tags (if too close)
          
          // Calculate minimum distance based on card sizes
          const minDist = MIN_NO_TAG_DISTANCE + ((a.size || 200) + (b.size || 200)) / 4;
          
          if (dist < minDist) {
            hadAdjustment = true;
            
            const pushDistance = (minDist - dist) * PUSH_STRENGTH;
            const pushX = (dx / dist) * pushDistance;
            const pushY = (dy / dist) * pushDistance;
            
            // Move away from each other
            a.x -= pushX * (bWeight / totalWeight);
            a.y -= pushY * (bWeight / totalWeight);
            b.x += pushX * (aWeight / totalWeight);
            b.y += pushY * (aWeight / totalWeight);
          }
        }
      }
    }
    
    if (!hadAdjustment) break;
  }
  
  // Update base positions
  cardGroup.forEach(b => {
    b.baseX = b.x;
    b.baseY = b.y;
  });
}

// Lighter collision pass between clusters (only edge cards)
function resolveCrossClusterCollisions(clusterList, clusterZones) {
  if (clusterList.length < 2) return;
  
  const padding = 40; // Larger gap between clusters
  const maxIterations = 15;
  
  for (let iter = 0; iter < maxIterations; iter++) {
    let hadCollision = false;
    
    for (let ci = 0; ci < clusterList.length; ci++) {
      for (let cj = ci + 1; cj < clusterList.length; cj++) {
        const clusterA = clusterList[ci];
        const clusterB = clusterList[cj];
        
        // Only check outer cards of each cluster (performance)
        const outerA = clusterA.slice(-Math.min(5, clusterA.length));
        const outerB = clusterB.slice(-Math.min(5, clusterB.length));
        
        outerA.forEach(a => {
          outerB.forEach(b => {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
            const minDist = ((a.size || 200) + (b.size || 200)) / 2 + padding;
            
            if (dist < minDist) {
              hadCollision = true;
              const overlap = (minDist - dist) / 2;
              const pushX = (dx / dist) * overlap;
              const pushY = (dy / dist) * overlap;
              
              // Push both clusters apart (move all cards in cluster)
              clusterA.forEach(card => {
                card.x -= pushX * 0.3;
                card.y -= pushY * 0.3;
              });
              clusterB.forEach(card => {
                card.x += pushX * 0.3;
                card.y += pushY * 0.3;
              });
            }
          });
        });
      }
    }
    
    if (!hadCollision) break;
  }
  
  // Update base positions
  clusterList.flat().forEach(b => {
    b.baseX = b.x;
    b.baseY = b.y;
  });
}

// Keep all cards within visible bounds
function ensureAllVisible(width, height) {
  const margin = 100;
  
  bubbles.forEach(b => {
    const halfSize = (b.size || 200) / 2;
    b.x = Math.max(margin, Math.min(width - margin - halfSize, b.x));
    b.y = Math.max(margin, Math.min(height - margin - halfSize, b.y));
    b.baseX = b.x;
    b.baseY = b.y;
  });
}

function shuffleBubbles() {
  buildBubbleData().then(() => {
    layoutCelestialSystem();
    renderBubbles();
    closeDiscoverInfo();
    showToast(' Reshuffled!', 'default');
  });
}



function populateTagFilter() {
  const allTags = new Set();
  bubbles.forEach(b => (b.tags || []).forEach(t => allTags.add(t)));
  const select = document.getElementById('discoverFilter');
  select.innerHTML = '<option value="">All tags</option>' + 
    [...allTags].sort().map(t => `<option value="${t}">#${t}</option>`).join('');
}

function renderBubbles() {
  const container = document.getElementById('bubbleContainer');
  const topicEmojis = { tech: '', news: '', food: '', travel: '', entertainment: '', other: '' };
  
  container.innerHTML = bubbles.map((b, index) => {
    const emoji = topicEmojis[b.topic] || '';
    const tags = (b.tags || []).slice(0, 3);
    const v = b.votes || 0;
    const img = getCardThumbnail(b);
    const isStarred = b.starred;
    const width = b.size || (isMobileDevice ? 140 : 200);
    const type = b.celestialType || 'asteroid';
    
    // Visual classes based on celestial type
    const typeClasses = {
      star: 'celestial-star',
      planet: 'celestial-planet',
      moon: 'celestial-moon',
      comet: 'celestial-comet',
      asteroid: 'celestial-asteroid'
    };
    
    const typeClass = typeClasses[type] || '';
    const isComet = type === 'comet';
    const isStar = type === 'star';
    
    // Entry animation delay
    const delayClass = index < 15 ? `entering-delay-${Math.min(index, 10)}` : '';
    
    return `
      <div class="bubble-card ${typeClass} ${b.isGuide ? 'guide-card' : ''} entering ${delayClass}"
           id="bubble-${b.bubbleId}"
           data-id="${b.bubbleId}"
           data-type="${type}"
           data-is-guide="${b.isGuide}"
           style="left:${b.x - width / 2}px; top:${b.y - (width * 0.7)}px; width:${width}px; --breath-delay:${b.breathDelay}s;"
           onclick="handleBubbleClick('${b.bubbleId}', event)"
           onmouseenter="handleBubbleHover('${b.bubbleId}', true)"
           onmouseleave="handleBubbleHover('${b.bubbleId}', false)">
        
        ${isComet ? '<div class="comet-tail"></div>' : ''}
        ${isStar ? '<div class="star-corona"></div>' : ''}
        
        <div class="bubble-card-image">
          <img src="${img}" alt="${sanitizeHTML(b.title)}" onerror="this.onerror=null;this.src='${generatePlaceholderThumbnail(b).replace(/'/g, "\\'")}'">
          <div class="bubble-card-image-overlay">
            <div style="display:flex;gap:0.25rem;flex-wrap:wrap;">
              <span class="bubble-badge">${emoji}</span>
              ${v ? `<span class="bubble-badge" style="color:${v > 0 ? 'var(--success)' : 'var(--danger)'}">${v > 0 ? '+' : ''}${v}</span>` : ''}
              ${b.isGuide ? `<span class="bubble-badge guide-badge">Guide</span>` : ''}
              ${isComet ? `<span class="bubble-badge comet-badge">NEW</span>` : ''}
            </div>
            <button class="bubble-star-btn ${isStarred ? 'active' : ''}" onclick="handleBubbleStar('${b.bubbleId}', event)">
              ${isStarred ? '' : ''}
            </button>
          </div>
        </div>
        
        <div class="bubble-card-content">
          <h3 class="bubble-card-title">${sanitizeHTML(b.title)}</h3>
          <p class="bubble-card-url">${sanitizeHTML(formatUrl(b.url))}</p>
          ${tags.length ? `<div class="bubble-card-tags">${tags.map(t => `<span class="tag">${sanitizeHTML(t)}</span>`).join('')}</div>` : ''}
          <span class="bubble-card-author">
            ${b.isCommunity ? '' : ''} ${sanitizeHTML(b.addedBy || 'Anonymous')}
          </span>
        </div>
        
        <div class="bubble-card-footer">
          <button onclick="handleBubbleVote('${b.bubbleId}', event)" title="Upvote"> ${v > 0 ? `<span class="vote-count">${v}</span>` : ''}</button>
          <button onclick="handleBubbleCollection('${b.bubbleId}', event)" title="Save"></button>
          <button onclick="handleBubbleOpen('${b.bubbleId}', event)" title="Open"></button>
        </div>
      </div>
    `;
  }).join('');
  
  applyTransform();
  
  // Remove entering class after animation
  setTimeout(() => {
    document.querySelectorAll('.bubble-card.entering').forEach(el => {
      el.classList.remove('entering');
    });
  }, 1200);
}

function formatUrl(url) {
  try {
    if (url.startsWith('thought://')) return url;
    return new URL(url).hostname.replace('www.', '');
  } catch (e) {
    return url.substring(0, 30);
  }
}

function applyTransform() {
  const container = document.getElementById('bubbleContainer');
  const svg = document.getElementById('connectionsSvg');
  const starField = document.querySelector('.discover-view .star-field');
  const particles = document.querySelector('.discover-view .ambient-particles');
  
  const transform = `translate(${bubblePanX}px, ${bubblePanY}px) scale(${bubbleZoom})`;
  container.style.transform = transform;
  container.style.transformOrigin = 'center center';
  svg.style.transform = transform;
  svg.style.transformOrigin = 'center center';
  
  // Parallax effect - background layers move slower
  if (starField) {
    const parallaxSlow = `translate(${bubblePanX * 0.1}px, ${bubblePanY * 0.1}px) scale(${1 + (bubbleZoom - 1) * 0.05})`;
    starField.style.transform = parallaxSlow;
    starField.style.transformOrigin = 'center center';
  }
  
  if (particles) {
    const parallaxMedium = `translate(${bubblePanX * 0.3}px, ${bubblePanY * 0.3}px) scale(${1 + (bubbleZoom - 1) * 0.15})`;
    particles.style.transform = parallaxMedium;
    particles.style.transformOrigin = 'center center';
  }
}

// Handle hover with magnetic push effect
function handleBubbleHover(id, isEntering) {
  isAnyCardHovered = isEntering;
  hoveredBubbleId = isEntering ? id : null;
  
  const hoveredBubble = bubbles.find(b => b.bubbleId === id);
  if (!hoveredBubble) return;
  
  // Reset all cards first
  document.querySelectorAll('.bubble-card').forEach(el => {
    el.classList.remove('pushed');
  });
  
  if (isEntering) {
    // Push nearby cards away slightly
    bubbles.forEach(b => {
      if (b.bubbleId === id) return;
      
      const dx = b.x - hoveredBubble.x;
      const dy = b.y - hoveredBubble.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist < 350 && dist > 0) {
        const card = document.getElementById(`bubble-${b.bubbleId}`);
        if (card) {
          const pushStrength = Math.max(0, (350 - dist) / 350) * 15;
          const pushX = (dx / dist) * pushStrength;
          const pushY = (dy / dist) * pushStrength;
          
          card.classList.add('pushed');
          card.style.transform = `translate(${pushX}px, ${pushY}px)`;
        }
      }
    });
  } else {
    // Reset positions
    bubbles.forEach(b => {
      const card = document.getElementById(`bubble-${b.bubbleId}`);
      if (card && !card.classList.contains('selected')) {
        card.style.transform = '';
      }
    });
  }
}

// Double-click detection for opening cards
function handleBubbleClick(id, event) {
  event.stopPropagation();
  const now = Date.now();
  
  if (lastClickId === id && now - lastClickTime < 300) {
    handleBubbleOpen(id, event);
    lastClickTime = 0;
    lastClickId = null;
    return;
  }
  
  lastClickTime = now;
  lastClickId = id;
  selectBubble(id);
}

function selectBubble(id) {
  selectedBubbleId = id;
  const bubble = bubbles.find(b => b.bubbleId === id);
  if (!bubble) return;
  
  // Reset all cards
  document.querySelectorAll('.bubble-card').forEach(el => {
    el.classList.remove('selected', 'related');
    el.style.transform = '';
  });
  
  // Mark selected
  const selectedEl = document.getElementById(`bubble-${id}`);
  if (selectedEl) selectedEl.classList.add('selected');
  
  // Find and highlight related cards
  const relatedIds = new Set();
  bubbleConnections.forEach(conn => {
    if (conn.source === id) relatedIds.add(conn.target);
    if (conn.target === id) relatedIds.add(conn.source);
  });
  
  relatedIds.forEach(relId => {
    const relEl = document.getElementById(`bubble-${relId}`);
    if (relEl) relEl.classList.add('related');
  });
  
  showConnections(id);
  updateInfoPanel(bubble);
}

function updateInfoPanel(bubble) {
  const color = TOPIC_COLORS[bubble.topic] || TOPIC_COLORS.other;
  document.getElementById('infoTopic').style.background = color;
  document.getElementById('infoTopic').style.color = color;
  document.getElementById('infoTitle').textContent = sanitizeHTML(bubble.title);
  document.getElementById('infoUrl').textContent = sanitizeHTML(bubble.url);
  document.getElementById('infoTags').innerHTML = (bubble.tags || []).map(t => `<span class="tag">#${sanitizeHTML(t)}</span>`).join('');
  document.getElementById('infoNotes').textContent = sanitizeHTML(bubble.notes) || 'No notes added yet.';
  document.getElementById('discoverInfo').style.display = 'block';
}

function showConnections(id) {
  const svg = document.getElementById('connectionsSvg');
  const bubble = bubbles.find(b => b.bubbleId === id);
  if (!bubble) return;
  
  // Find all cards that share tags with the selected card
  const selectedTags = (bubble.tags || []).map(t => t.toLowerCase());
  
  // Build connections with shared tag info
  const related = [];
  bubbles.forEach(other => {
    if (other.bubbleId === id) return;
    
    const otherTags = (other.tags || []).map(t => t.toLowerCase());
    const sharedTags = selectedTags.filter(t => otherTags.includes(t));
    
    if (sharedTags.length > 0) {
      related.push({
        source: bubble,
        target: other,
        sharedTags: sharedTags,
        strength: sharedTags.length
      });
    }
  });
  
  const connections = related.map((conn, index) => {
    const a = conn.source;
    const b = conn.target;
    
    // Scale visuals by connection strength
    const strokeWidth = 1.5 + conn.strength * 0.7;
    const opacity = 0.5 + conn.strength * 0.12;
    
    // Calculate control points for curved path
    const midX = (a.x + b.x) / 2;
    const midY = (a.y + b.y) / 2;
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const dist = Math.sqrt(dx * dx + dy * dy) || 1;
    
    // Perpendicular offset for curve - alternate direction
    const curveAmount = dist * 0.15 * (index % 2 === 0 ? 1 : -1);
    const ctrlX = midX + (-dy / dist) * curveAmount;
    const ctrlY = midY + (dx / dist) * curveAmount;
    
    const nodeRadius = 3 + conn.strength;
    const pathId = `motionPath${index}`;
    const duration = 1.5 + Math.random() * 1;
    const delay = index * 0.3;
    
    // Gradient ID based on strength (stronger = different color)
    const gradId = conn.strength >= 3 ? 'strongGrad' : conn.strength >= 2 ? 'mediumGrad' : 'synapseGrad';
    
    return `
      <!-- Glow layer (behind) -->
      <path 
        d="M ${a.x} ${a.y} Q ${ctrlX} ${ctrlY} ${b.x} ${b.y}"
        fill="none"
        stroke="rgba(139, 92, 246, 0.3)" 
        stroke-width="${strokeWidth + 4}"
        opacity="${opacity * 0.5}"
        stroke-linecap="round"
      />
      
      <!-- Main curved path -->
      <path 
        d="M ${a.x} ${a.y} Q ${ctrlX} ${ctrlY} ${b.x} ${b.y}"
        fill="none"
        stroke="url(#${gradId})" 
        stroke-width="${strokeWidth}"
        opacity="${opacity}"
        stroke-linecap="round"
      />
      
      <!-- Hidden path for motion -->
      <path 
        id="${pathId}"
        d="M ${a.x} ${a.y} Q ${ctrlX} ${ctrlY} ${b.x} ${b.y}"
        fill="none"
        stroke="none"
      />
      
      <!-- Traveling light particle 1 -->
      <circle r="4" fill="#ffffff" opacity="0.9">
        <animateMotion 
          dur="${duration}s" 
          repeatCount="indefinite" 
          begin="${delay}s"
        >
          <mpath href="#${pathId}"/>
        </animateMotion>
      </circle>
      
      <!-- Traveling light particle 1 - glow -->
      <circle r="8" fill="rgba(167, 139, 250, 0.5)">
        <animateMotion 
          dur="${duration}s" 
          repeatCount="indefinite" 
          begin="${delay}s"
        >
          <mpath href="#${pathId}"/>
        </animateMotion>
      </circle>
      
      <!-- Traveling light particle 2 (offset timing) -->
      <circle r="3" fill="#e0e7ff" opacity="0.8">
        <animateMotion 
          dur="${duration}s" 
          repeatCount="indefinite" 
          begin="${delay + duration/2}s"
        >
          <mpath href="#${pathId}"/>
        </animateMotion>
      </circle>
      
      <!-- Traveling light particle 2 - glow -->
      <circle r="6" fill="rgba(99, 102, 241, 0.4)">
        <animateMotion 
          dur="${duration}s" 
          repeatCount="indefinite" 
          begin="${delay + duration/2}s"
        >
          <mpath href="#${pathId}"/>
        </animateMotion>
      </circle>
      
      <!-- End nodes -->
      <circle cx="${a.x}" cy="${a.y}" r="${nodeRadius}" fill="url(#nodeGrad)" opacity="0.9"/>
      <circle cx="${b.x}" cy="${b.y}" r="${nodeRadius}" fill="url(#nodeGrad)" opacity="0.9"/>
      
      <!-- Node glow -->
      <circle cx="${a.x}" cy="${a.y}" r="${nodeRadius + 6}" fill="rgba(139, 92, 246, 0.25)"/>
      <circle cx="${b.x}" cy="${b.y}" r="${nodeRadius + 6}" fill="rgba(139, 92, 246, 0.25)"/>
      
      <!-- Shared tags label (shows on 2+ shared tags) -->
      ${conn.strength >= 2 ? `
        <rect 
          x="${midX - (conn.sharedTags.slice(0, 3).join(', ').length * 3.5)}" 
          y="${midY - 18}" 
          width="${conn.sharedTags.slice(0, 3).join(', ').length * 7 + 12}" 
          height="16" 
          rx="4" 
          fill="rgba(0,0,0,0.7)"
          opacity="0.9"
        />
        <text 
          x="${midX}" 
          y="${midY - 6}" 
          fill="white" 
          font-size="10" 
          font-family="Inter, sans-serif"
          text-anchor="middle" 
          opacity="0.9"
          style="pointer-events:none;">
          ${conn.sharedTags.slice(0, 3).join(', ')}${conn.sharedTags.length > 3 ? '...' : ''}
        </text>
      ` : ''}
    `;
  }).join('');
  
  svg.innerHTML = `
    <defs>
      <!-- Default gradient (1 shared tag) -->
      <linearGradient id="synapseGrad" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%" stop-color="#6366f1"/>
        <stop offset="50%" stop-color="#a78bfa"/>
        <stop offset="100%" stop-color="#8b5cf6"/>
      </linearGradient>
      
      <!-- Medium gradient (2 shared tags) -->
      <linearGradient id="mediumGrad" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%" stop-color="#8b5cf6"/>
        <stop offset="50%" stop-color="#c084fc"/>
        <stop offset="100%" stop-color="#e879f9"/>
      </linearGradient>
      
      <!-- Strong gradient (3+ shared tags) -->
      <linearGradient id="strongGrad" x1="0%" y1="0%" x2="100%" y2="0%">
        <stop offset="0%" stop-color="#f472b6"/>
        <stop offset="50%" stop-color="#fb7185"/>
        <stop offset="100%" stop-color="#f59e0b"/>
      </linearGradient>
      
      <radialGradient id="nodeGrad" cx="50%" cy="50%" r="50%">
        <stop offset="0%" stop-color="#e0e7ff"/>
        <stop offset="50%" stop-color="#a78bfa"/>
        <stop offset="100%" stop-color="#6366f1"/>
      </radialGradient>
    </defs>
    ${connections}
  `;
}

function hideConnections() {
  document.getElementById('connectionsSvg').innerHTML = '';
}

// Ambient floating animation
function startAmbientAnimation() {
  let time = 0;
  const fps = 30;
  const frameInterval = 1000 / fps;
  let lastFrameTime = 0;
  
  function animate(currentTime) {
    ambientFrame = requestAnimationFrame(animate);
    
    if (currentTime - lastFrameTime < frameInterval) return;
    lastFrameTime = currentTime;
    
    // Don't animate while dragging or selecting
    if (isAnyCardHovered || selectedBubbleId || isDraggingCanvas) return;
    
    time += 0.008;
    
    bubbles.forEach(bubble => {
      const card = document.getElementById(`bubble-${bubble.bubbleId}`);
      if (!card || card.classList.contains('selected') || card.classList.contains('related')) return;
      
      const type = bubble.celestialType;
      let newX = bubble.baseX;
      let newY = bubble.baseY;
      
      // Different movement based on celestial type
      if (type === 'star') {
        // Stars: very subtle breathing only (no movement)
        return;
      } else if (type === 'planet' && bubble.orbitCenterX !== undefined) {
        // Planets: slow orbital drift
        const angle = bubble.orbitAngle + time * bubble.orbitSpeed;
        newX = bubble.orbitCenterX + Math.cos(angle) * bubble.orbitRadius;
        newY = bubble.orbitCenterY + Math.sin(angle) * bubble.orbitRadius;
      } else if (type === 'moon' && bubble.orbitCenterX !== undefined) {
        // Moons: faster orbital drift
        const angle = bubble.orbitAngle + time * bubble.orbitSpeed * 1.5;
        newX = bubble.orbitCenterX + Math.cos(angle) * bubble.orbitRadius;
        newY = bubble.orbitCenterY + Math.sin(angle) * bubble.orbitRadius;
      } else if (type === 'comet') {
        // Comets: gentle bobbing
        newX = bubble.baseX + Math.sin(time * 0.5 + bubble.breathDelay) * 3;
        newY = bubble.baseY + Math.cos(time * 0.3 + bubble.breathDelay) * 2;
      } else if (type === 'asteroid') {
        // Asteroids: slow tumbling drift
        newX = bubble.baseX + Math.sin(time * 0.2 + bubble.breathDelay) * 2;
        newY = bubble.baseY + Math.cos(time * 0.15 + bubble.breathDelay) * 2;
      }
      
      const width = bubble.size || 200;
      card.style.left = `${newX - width / 2}px`;
      card.style.top = `${newY - (width * 0.7)}px`;
    });
  }
  
  ambientFrame = requestAnimationFrame(animate);
}

// Guide card promotion
function promoteGuideCard(guideId) {
  const guide = GUIDE_CARDS.find(g => g.id === guideId);
  if (!guide) return null;
  
  const existing = cards.find(c => c.url === guide.url);
  if (existing) return existing;
  
  const newCard = {
    id: Date.now(),
    title: guide.title,
    url: guide.url,
    tags: [...guide.tags],
    topic: guide.topic,
    notes: guide.notes,
    votes: guide.votes,
    addedBy: username,
    screenshot: generatePlaceholderThumbnail(guide),
    screenshotReal: false,
    photos: [],
    comments: [],
    starred: true,
    isPrivate: false,
    createdAt: new Date().toISOString(),
    lastEdited: new Date().toISOString(),
    editedBy: username
  };
  
  cards.unshift(newCard);
  saveCards();
  renderGrid();
  return newCard;
}

// Bubble actions
function handleBubbleStar(id, event) {
  event.stopPropagation();
  const bubble = bubbles.find(b => b.bubbleId === id);
  if (!bubble) return;
  
  if (bubble.isGuide) {
    const promoted = promoteGuideCard(id);
    if (promoted) {
      showToast(' Added to your collection!', 'success');
      buildBubbleData();
      renderBubbles();
    }
  } else {
    const card = cards.find(c => String(c.id) === id);
    if (card) {
      card.starred = !card.starred;
      saveCards();
      renderBubbles();
      renderGrid();
      showToast(card.starred ? ' Starred!' : 'Removed star', 'success');
    }
  }
}

function handleBubbleVote(id, event) {
  event.stopPropagation();
  const bubble = bubbles.find(b => b.bubbleId === id);
  if (!bubble) return;
  
  if (bubble.isGuide) {
    showToast('Star this card first to vote on it', 'default');
    return;
  }
  
  const card = cards.find(c => String(c.id) === id);
  if (card) {
    vote(card.id, 1);
    bubble.votes = card.votes;
    renderBubbles();
  }
}

function handleBubbleCollection(id, event) {
  event.stopPropagation();
  const bubble = bubbles.find(b => b.bubbleId === id);
  if (!bubble) return;
  
  if (bubble.isGuide) {
    const promoted = promoteGuideCard(id);
    if (promoted) {
      showToast('Added to collection!', 'success');
      // Don't close Discover - modal will appear on top
      setTimeout(() => openAddToCollection(promoted.id), 100);
    }
  } else {
    const card = cards.find(c => String(c.id) === id);
    if (card) {
      // Don't close Discover - modal will appear on top
      openAddToCollection(card.id);
    }
  }
}

function handleBubbleOpen(id, event) {
  if (event) event.stopPropagation();
  const bubble = bubbles.find(b => b.bubbleId === id);
  if (!bubble) return;
  
  if (bubble.isGuide) {
    const promoted = promoteGuideCard(id);
    if (promoted) {
      openEditModal(promoted.id);
    }
  } else {
    // First check local cards
    let card = cards.find(c => String(c.id) === id);
    
    if (card) {
      openEditModal(card.id);
    } else if (bubble.isCommunity) {
      // It's a community card - open in view-only mode
      openCommunityCardModal(bubble);
    } else {
      // Card exists in bubbles but not in local cards - might be a sync issue
      // Try to open it as a community card
      openCommunityCardModal(bubble);
    }
  }
}

// View-only modal for community cards (not owned by user)
function openCommunityCardModal(bubble) {
  // Create a temporary card object for viewing
  const viewCard = {
    id: bubble.bubbleId || bubble.id,
    url: bubble.url,
    title: bubble.title,
    notes: bubble.notes || '',
    tags: bubble.tags || [],
    topic: bubble.topic || 'other',
    votes: bubble.votes || 0,
    screenshot: bubble.screenshot,
    photos: bubble.photos || [],
    comments: bubble.comments || [],
    location: bubble.location || '',
    addedBy: bubble.addedBy || 'Anonymous',
    createdAt: bubble.createdAt,
    isCommunity: true,
    isViewOnly: true
  };
  
  // Open the edit modal but in view-only mode
  openEditModalViewOnly(viewCard);
}

function openEditModalViewOnly(card) {
  currentCardId = card.id;
  
  document.getElementById('editModal').classList.add('active');
  
  // Image
  const detailImage = document.getElementById('detailImage');
  const mainImage = card.screenshot || generatePlaceholderThumbnail(card);
  detailImage.src = mainImage;
  detailImage.style.display = 'block';
  
  // Disable image upload for view-only
  const imageContainer = document.querySelector('.edit-image-container');
  if (imageContainer) {
    imageContainer.style.cursor = 'default';
    imageContainer.onclick = null;
  }
  
  // Title (read-only)
  const titleInput = document.getElementById('editTitle');
  titleInput.value = card.title;
  titleInput.disabled = true;
  
  // URL
  const urlLink = document.getElementById('editUrlLink');
  const urlText = document.getElementById('editUrlText');
  urlLink.href = card.url;
  urlText.textContent = card.url;
  
  // Notes (read-only)
  const notesEl = document.getElementById('editNotes');
  notesEl.value = card.notes || '';
  notesEl.disabled = true;
  
  // Location (read-only)
  const locationEl = document.getElementById('editLocation');
  if (locationEl) {
    locationEl.value = card.location || '';
    locationEl.disabled = true;
  }
  
  // Privacy checkbox - hide for community cards
  const privacyToggle = document.querySelector('.edit-privacy-toggle');
  if (privacyToggle) privacyToggle.style.display = 'none';
  
  // Star button - allow starring to save locally
  const starBtn = document.getElementById('editStarBtn');
  if (starBtn) {
    const isLocallyStarred = cards.find(c => c.url === card.url)?.starred;
    starBtn.textContent = isLocallyStarred ? '' : '';
    starBtn.title = 'Save to my collection';
    starBtn.onclick = () => saveCommunityCardLocally(card);
  }
  
  // Footer meta
  document.getElementById('editFooterMeta').textContent = 
    `Shared by ${card.addedBy}  ${new Date(card.createdAt).toLocaleDateString()}`;
  
  // Hide delete button for community cards
  const deleteBtn = document.querySelector('.edit-footer-right .btn-danger');
  if (deleteBtn) deleteBtn.style.display = 'none';
  
  // Add "Save to My Cards" button if not already saved
  const footerRight = document.querySelector('.edit-footer-right');
  const existingSaveBtn = document.getElementById('saveCommunityBtn');
  if (existingSaveBtn) existingSaveBtn.remove();
  
  const alreadySaved = cards.find(c => c.url === card.url);
  if (!alreadySaved && footerRight) {
    const saveBtn = document.createElement('button');
    saveBtn.id = 'saveCommunityBtn';
    saveBtn.className = 'btn btn-primary';
    saveBtn.innerHTML = ' Save to My Cards';
    saveBtn.onclick = () => saveCommunityCardLocally(card);
    footerRight.insertBefore(saveBtn, footerRight.firstChild);
  }
  
  // Update votes display
  updateVoteDisplay(card.id);
  
  // Render tags (read-only)
  renderEditTagsViewOnly(card);
  
  // Render photos (view-only)
  renderEditPhotosViewOnly(card);
  
  // Render comments (can still add comments if signed in)
  renderEditCommentsForCommunity(card);
}

function renderEditTagsViewOnly(card) {
  const container = document.getElementById('tagsContainer');
  if (!container) return;
  
  container.innerHTML = (card.tags || []).map(tag => 
    `<span class="tag">${sanitizeHTML(tag)}</span>`
  ).join('');
  
  // Hide tag input
  const tagInput = document.getElementById('newTag');
  if (tagInput) tagInput.style.display = 'none';
}

function renderEditPhotosViewOnly(card) {
  const grid = document.getElementById('editPhotoGrid');
  const countEl = document.getElementById('editPhotoCount');
  
  if (!grid) return;
  
  const photoCount = card.photos?.length || 0;
  if (countEl) countEl.textContent = photoCount > 0 ? `(${photoCount})` : '';
  
  let html = '';
  if (card.photos?.length) {
    html = card.photos.map((photo, i) => `
      <div class="edit-photo-item">
        <img src="${photo}" alt="Photo ${i+1}">
      </div>
    `).join('');
  } else {
    html = '<p style="color:var(--text-3);font-size:0.75rem;padding:0.5rem;">No photos</p>';
  }
  
  grid.innerHTML = html;
}

function renderEditCommentsForCommunity(card) {
  const list = document.getElementById('editCommentsList');
  const countEl = document.getElementById('editCommentsCount');
  
  if (!list) return;
  
  const comments = card.comments || [];
  if (countEl) countEl.textContent = comments.length;
  
  if (!comments.length) {
    list.innerHTML = `
      <div class="edit-comments-empty">
        <div class="edit-comments-empty-icon"></div>
        <p>No comments yet</p>
      </div>
    `;
  } else {
    list.innerHTML = comments.map(c => {
      const initial = (c.author || 'A').charAt(0).toUpperCase();
      return `
        <div class="edit-comment">
          <div class="edit-comment-header">
            <div class="edit-comment-author">
              <div class="edit-comment-avatar">${initial}</div>
              <span class="edit-comment-name">${sanitizeHTML(c.author)}</span>
            </div>
            <span class="edit-comment-time">${getRelativeTime(c.timestamp)}</span>
          </div>
          <div class="edit-comment-text">${sanitizeHTML(c.text)}</div>
        </div>
      `;
    }).join('');
  }
  
  // Show comment input only if signed in
  const commentInput = document.querySelector('.edit-comment-input-area');
  if (commentInput) {
    if (currentUser) {
      commentInput.style.display = 'block';
    } else {
      commentInput.innerHTML = `
        <p style="text-align:center;color:var(--text-3);font-size:0.8rem;padding:0.75rem;">
          <a href="#" onclick="document.getElementById('authModal').classList.add('active');return false;" style="color:var(--accent);">Sign in</a> to comment
        </p>
      `;
    }
  }
}

function saveCommunityCardLocally(card) {
  // Check if already saved
  const existing = cards.find(c => c.url === card.url);
  if (existing) {
    showToast('Already in your collection!', 'default');
    return;
  }
  
  // Create local copy
  const localCard = {
    id: Date.now(),
    url: card.url,
    title: card.title,
    notes: card.notes || '',
    location: card.location || '',
    tags: [...(card.tags || [])],
    topic: card.topic || 'other',
    votes: card.votes || 0,
    screenshot: card.screenshot,
    screenshotReal: !!card.screenshot,
    photos: [...(card.photos || [])],
    comments: [],
    starred: true,
    isPrivate: false,
    addedBy: username,
    originalAuthor: card.addedBy,
    createdAt: new Date().toISOString(),
    lastEdited: new Date().toISOString(),
    editedBy: username
  };
  
  cards.unshift(localCard);
  saveCards();
  renderGrid();
  
  closeEditModal();
  showToast(' Saved to your collection!', 'success');
}

function openCardFromDiscover() {
  if (!selectedBubbleId) return;
  // Don't close Discover - just open the card
  handleBubbleOpen(selectedBubbleId, null);
}

function focusOnBubble(id) {
  const bubble = bubbles.find(b => b.bubbleId === id);
  if (!bubble) return;
  
  const container = document.getElementById('bubbleContainer');
  const rect = container.parentElement.getBoundingClientRect();
  
  // Animate to focused position
  bubblePanX = rect.width / 2 - bubble.x;
  bubblePanY = rect.height / 2 - bubble.y;
  bubbleZoom = 1.15;
  
  applyTransform();
}

// Controls
function zoomBubbles(factor) {
  bubbleZoom = Math.max(0.3, Math.min(2.5, bubbleZoom * factor));
  applyTransform();
}

function resetBubbleView() {
  bubbleZoom = 1;
  bubblePanX = 0;
  bubblePanY = 0;
  applyTransform();
  closeDiscoverInfo();
}


function filterDiscoverByTag() {
  const tag = document.getElementById('discoverFilter').value;
  
  document.querySelectorAll('.bubble-card').forEach(el => {
    const bubble = bubbles.find(b => b.bubbleId === el.dataset.id);
    const matches = !tag || (bubble?.tags || []).includes(tag);
    
    if (matches) {
      el.style.opacity = '';
      el.style.pointerEvents = 'auto';
      el.style.filter = '';
    } else {
      el.style.opacity = '0.15';
      el.style.pointerEvents = 'none';
      el.style.filter = 'blur(2px)';
    }
  });
}
function handleDiscoverSearch() {
  const query = document.getElementById('discoverSearchBar').value.toLowerCase().trim();
  
  document.querySelectorAll('.bubble-card').forEach(el => {
    const bubble = bubbles.find(b => b.bubbleId === el.dataset.id);
    if (!bubble) return;
    
    const tags = (bubble.tags || []).join(' ').toLowerCase();
    const title = (bubble.title || '').toLowerCase();
    const matches = !query || tags.includes(query) || title.includes(query);
    
    if (matches) {
      el.style.opacity = '';
      el.style.pointerEvents = 'auto';
      el.style.filter = '';
    } else {
      el.style.opacity = '0.15';
      el.style.pointerEvents = 'none';
      el.style.filter = 'blur(2px)';
    }
  });
}
// Canvas drag and zoom
function setupCanvasDrag() {
  const canvas = document.getElementById('discoverCanvas');
  
  // Mouse events
  canvas.addEventListener('mousedown', e => {
    if (e.target.closest('.bubble-card') || e.target.closest('.discover-info') || e.target.closest('.discover-controls')) return;
    isDraggingCanvas = true;
    dragStartX = e.clientX - bubblePanX;
    dragStartY = e.clientY - bubblePanY;
    canvas.style.cursor = 'grabbing';
  });
  
  canvas.addEventListener('mousemove', e => {
    if (!isDraggingCanvas) return;
    bubblePanX = e.clientX - dragStartX;
    bubblePanY = e.clientY - dragStartY;
    applyTransform();
  });
  
  canvas.addEventListener('mouseup', () => {
    isDraggingCanvas = false;
    canvas.style.cursor = 'default';
  });
  
  canvas.addEventListener('mouseleave', () => {
    isDraggingCanvas = false;
    canvas.style.cursor = 'default';
  });
  
  // Touch events
  canvas.addEventListener('touchstart', e => {
    if (e.target.closest('.bubble-card') || e.target.closest('.discover-info')) return;
    isDraggingCanvas = true;
    dragStartX = e.touches[0].clientX - bubblePanX;
    dragStartY = e.touches[0].clientY - bubblePanY;
  }, { passive: true });
  
  canvas.addEventListener('touchmove', e => {
    if (!isDraggingCanvas) return;
    bubblePanX = e.touches[0].clientX - dragStartX;
    bubblePanY = e.touches[0].clientY - dragStartY;
    applyTransform();
  }, { passive: true });
  
  canvas.addEventListener('touchend', () => {
    isDraggingCanvas = false;
  });
  
  // Mouse wheel zoom
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const zoomFactor = e.deltaY > 0 ? 0.92 : 1.08;
    zoomBubbles(zoomFactor);
  }, { passive: false });
  
  // Click on canvas to deselect
  canvas.addEventListener('click', e => {
    if (!e.target.closest('.bubble-card') && 
        !e.target.closest('.discover-info') && 
        !e.target.closest('.discover-controls')) {
      closeDiscoverInfo();
    }
  });
}

// ============== CLOUD SYNC ==============
let cloudSyncEnabled = false;
let realtimeSubscription = null;
let syncInProgress = false;
let lastSyncTime = null;

// Initialize cloud sync after authentication
async function initCloudSync() {
  if (!supabaseClient || !currentUser) {
    cloudSyncEnabled = false;
    return;
  }
  
  cloudSyncEnabled = true;
  console.log(' Cloud sync enabled for:', currentUser.email);
  
  // Initial sync - merge local and cloud
  await performInitialSync();
  
  // Setup realtime subscriptions
  setupRealtimeSubscriptions();
  
  // Periodic sync every 30 seconds
  setInterval(syncToCloud, 30000);
}

// Initial sync: merge local cards with cloud
async function performInitialSync() {
  if (syncInProgress) return;
  syncInProgress = true;
  
  try {
    showToast(' Syncing...', 'default');
    
    // 1. Fetch user's own cards from cloud
    const { data: myCloudCards, error: myError } = await supabaseClient
      .from('cards')
      .select('*')
      .eq('user_id', currentUser.id);
    
    if (myError) throw myError;
    
    // 2. Get local cards that belong to this user
    const localUserCards = cards.filter(c => !c.isGuide && !c.cloudId);
    
    // 3. Upload local cards that aren't in cloud yet
    for (const localCard of localUserCards) {
      const existsInCloud = myCloudCards?.some(cc => cc.id === localCard.id || cc.url === localCard.url);
      if (!existsInCloud && !localCard.isPrivate) {
        await uploadCardToCloud(localCard);
      }
    }
    
    // 4. Merge cloud cards into local (avoid duplicates)
    if (myCloudCards?.length) {
      const localUrls = new Set(cards.map(c => c.url));
      const localIds = new Set(cards.map(c => c.id));
      
      for (const cloudCard of myCloudCards) {
        if (!localIds.has(cloudCard.id) && !localUrls.has(cloudCard.url)) {
          cards.push(cloudCardToLocal(cloudCard));
        }
      }
    }
    
    // 5. Fetch votes for all cards
    await syncVotesFromCloud();
    
    // 6. Fetch comments for all cards
    await syncCommentsFromCloud();
    
    saveCards();
    renderGrid();
    
    lastSyncTime = new Date();
    showToast(' Synced!', 'success');
    
  } catch (error) {
    console.error('Sync error:', error);
    showToast('Sync failed - working offline', 'error');
  } finally {
    syncInProgress = false;
  }
}

// Get a screenshot that's safe to store in the database
function getStorableScreenshot(card) {
  // If it's already a URL (including Supabase storage), store it directly
  if (card.screenshot && card.screenshot.startsWith('http')) {
    return card.screenshot;
  }
  
  // For YouTube, always use the thumbnail URL
  if (card.url && (card.url.includes('youtube.com') || card.url.includes('youtu.be'))) {
    const videoId = extractYouTubeId(card.url);
    if (videoId) {
      return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
    }
  }
  
  // For base64 images, only store if very small (most won't be)
  // Larger images should have been uploaded to storage already
  if (card.screenshot && card.screenshot.startsWith('data:')) {
    if (card.screenshot.length < 30000) { // ~22KB
      return card.screenshot;
    }
    // Too large - return null, the image is in local storage only
    console.log(' Screenshot too large to sync, stored locally only');
    return null;
  }
  
  return null;
}

// Upload image to Supabase Storage and return public URL
async function uploadImageToStorage(base64Data, cardId, imageType = 'screenshot') {
  if (!supabaseClient || !currentUser) {
    console.log(' Cannot upload image: not authenticated');
    return null;
  }
  
  if (!base64Data || !base64Data.startsWith('data:image/')) {
    return null;
  }
  
  try {
    // Convert base64 to blob
    const response = await fetch(base64Data);
    const blob = await response.blob();
    
    // Check file size (max 5MB)
    if (blob.size > 5 * 1024 * 1024) {
      console.warn(' Image too large, compressing...');
      // Compress the image
      const compressedBase64 = await compressImage(base64Data, 800, 0.7);
      const compressedResponse = await fetch(compressedBase64);
      const compressedBlob = await compressedResponse.blob();
      
      if (compressedBlob.size > 5 * 1024 * 1024) {
        console.error(' Image still too large after compression');
        return null;
      }
      
      return uploadBlobToStorage(compressedBlob, cardId, imageType);
    }
    
    return uploadBlobToStorage(blob, cardId, imageType);
    
  } catch (e) {
    console.error(' Image upload error:', e);
    return null;
  }
}

async function uploadBlobToStorage(blob, cardId, imageType) {
  if (!supabaseClient || !currentUser) return null;
  
  try {
    // Create unique filename: userId/cardId/type_timestamp.jpg
    const ext = blob.type.split('/')[1] || 'jpg';
    const fileName = `${currentUser.id}/${cardId}/${imageType}_${Date.now()}.${ext}`;
    
    console.log(' Uploading image:', fileName);
    
    const { data, error } = await supabaseClient.storage
      .from('card-images')
      .upload(fileName, blob, {
        cacheControl: '3600',
        upsert: true
      });
    
    if (error) {
      console.error(' Storage upload error:', error);
      return null;
    }
    
    // Get public URL
    const { data: urlData } = supabaseClient.storage
      .from('card-images')
      .getPublicUrl(fileName);
    
    console.log(' Image uploaded:', urlData.publicUrl);
    return urlData.publicUrl;
    
  } catch (e) {
    console.error(' Blob upload error:', e);
    return null;
  }
}

// Delete image from storage when card is deleted
async function deleteImageFromStorage(imageUrl) {
  if (!supabaseClient || !currentUser || !imageUrl) return;
  
  // Only delete if it's our storage URL
  if (!imageUrl.includes('supabase.co/storage')) return;
  
  try {
    // Extract path from URL
    const urlParts = imageUrl.split('/card-images/');
    if (urlParts.length < 2) return;
    
    const filePath = urlParts[1];
    
    const { error } = await supabaseClient.storage
      .from('card-images')
      .remove([filePath]);
    
    if (error) {
      console.warn(' Could not delete image:', error);
    } else {
      console.log(' Image deleted from storage');
    }
  } catch (e) {
    console.error(' Delete image error:', e);
  }
}

// Sync all local base64 images to cloud storage
async function syncImagesToCloud() {
  if (!supabaseClient || !currentUser) {
    showToast('Sign in to sync images', 'error');
    return;
  }
  
  const btn = document.getElementById('syncImagesBtn');
  if (btn) {
    btn.disabled = true;
    btn.textContent = ' Syncing...';
  }
  
  let uploaded = 0;
  let failed = 0;
  let skipped = 0;
  
  for (const card of cards) {
    // Skip cards that aren't ours
    if (card.cloudUserId && card.cloudUserId !== currentUser.id) {
      skipped++;
      continue;
    }
    
    // Sync screenshot if it's base64
    if (card.screenshot && card.screenshot.startsWith('data:image/')) {
      console.log(` Uploading screenshot for: ${card.title}`);
      const url = await uploadImageToStorage(card.screenshot, card.id, 'screenshot');
      if (url) {
        card.screenshot = url;
        card.screenshotReal = true;
        uploaded++;
      } else {
        failed++;
      }
    }
    
    // Sync photos if they're base64
    if (card.photos && card.photos.length > 0) {
      const newPhotos = [];
      for (let i = 0; i < card.photos.length; i++) {
        const photo = card.photos[i];
        if (photo.startsWith('data:image/')) {
          console.log(` Uploading photo ${i + 1} for: ${card.title}`);
          const url = await uploadImageToStorage(photo, card.id, `photo_${i}`);
          if (url) {
            newPhotos.push(url);
            uploaded++;
          } else {
            newPhotos.push(photo); // Keep local version
            failed++;
          }
        } else {
          newPhotos.push(photo); // Already a URL
          skipped++;
        }
      }
      card.photos = newPhotos;
    }
  }
  
  saveCards();
  
  // Re-upload cards to cloud with new URLs
  if (uploaded > 0) {
    console.log(' Re-syncing cards to cloud...');
    for (const card of cards) {
      if (!card.isPrivate && card.screenshot?.startsWith('http')) {
        await uploadCardToCloud(card);
      }
    }
  }
  
  if (btn) {
    btn.disabled = false;
    btn.textContent = ' Sync Images to Cloud';
  }
  
  if (uploaded > 0) {
    showToast(` Uploaded ${uploaded} images!`, 'success');
  } else if (failed > 0) {
    showToast(` ${failed} images failed to upload`, 'error');
  } else {
    showToast('All images already synced!', 'default');
  }
  
  renderGrid();
}

// ============== FULL CARD SYNC ==============
async function syncCardData(cardId) {
  const card = cards.find(c => c.id === cardId);
  if (!card) return;
  
  if (!supabaseClient || !currentUser) {
    showToast('Sign in to sync', 'error');
    return;
  }
  
  if (card.isPrivate) {
    showToast('Private cards are not synced', 'default');
    return;
  }
  
  const btn = document.getElementById('editSyncBtn');
  if (btn) {
    btn.disabled = true;
    btn.textContent = '';
  }
  
  showToast(' Syncing card data...', 'default');
  
  let uploaded = 0;
  let failed = 0;
  
  try {
    // 1. Sync screenshot if it's base64
    if (card.screenshot && card.screenshot.startsWith('data:image/')) {
      showToast(' Uploading screenshot...', 'default');
      const url = await uploadImageToStorage(card.screenshot, card.id, 'screenshot');
      if (url) {
        card.screenshot = url;
        card.screenshotReal = true;
        uploaded++;
        
        // Update displayed image
        const detailImage = document.getElementById('detailImage');
        if (detailImage) detailImage.src = url;
      } else {
        failed++;
      }
    }
    
    // 2. Sync photos if they're base64
    if (card.photos && card.photos.length > 0) {
      const newPhotos = [];
      for (let i = 0; i < card.photos.length; i++) {
        const photo = card.photos[i];
        if (photo.startsWith('data:image/')) {
          showToast(` Uploading photo ${i + 1}/${card.photos.length}...`, 'default');
          const url = await uploadImageToStorage(photo, card.id, `photo_${i}_${Date.now()}`);
          if (url) {
            newPhotos.push(url);
            uploaded++;
          } else {
            newPhotos.push(photo);
            failed++;
          }
        } else {
          newPhotos.push(photo);
        }
      }
      card.photos = newPhotos;
    }
    
    // 3. Upload ALL card data to cloud
    const cloudCard = {
      id: String(card.id),
      user_id: currentUser.id,
      url: card.url,
      title: card.title,
      notes: card.notes || '',
      location: card.location || '',
      topic: card.topic || 'other',
      tags: card.tags || [],
      screenshot: getStorableScreenshot(card),
      screenshot_real: card.screenshotReal || false,
      photos: card.photos?.filter(p => !p.startsWith('data:')) || [], // Only synced photos
      is_private: false,
      starred: card.starred || false,
      added_by: card.addedBy || username,
      created_at: card.createdAt || new Date().toISOString(),
      last_edited: new Date().toISOString(),
      edited_by: username
    };
    
    const { data, error } = await supabaseClient
      .from('cards')
      .upsert(cloudCard, { onConflict: 'id' })
      .select()
      .single();
    
    if (error) throw error;
    
    // Mark as synced
    card.cloudSynced = true;
    card.lastCloudSync = new Date().toISOString();
    
    saveCards();
    
    // Update UI
    if (btn) {
      btn.disabled = false;
      btn.textContent = '';
    }
    
    updateSyncButtonVisibility(card);
    renderEditPhotos();
    renderGrid();
    
    if (failed === 0) {
      showToast(` Card synced! ${uploaded > 0 ? `(${uploaded} images uploaded)` : ''}`, 'success');
    } else {
      showToast(` Synced with ${failed} image failure(s)`, 'error');
    }
    
  } catch (error) {
    console.error('Sync error:', error);
    showToast(' Sync failed: ' + error.message, 'error');
    
    if (btn) {
      btn.disabled = false;
      btn.textContent = '';
    }
  }
}

// Update sync button visibility - now checks for any unsyncced data
function updateSyncButtonVisibility(card) {
  const btn = document.getElementById('editSyncBtn');
  if (!btn) return;
  
  if (!currentUser) {
    btn.style.display = 'none';
    return;
  }
  
  btn.style.display = 'flex';
  
  const needsSync = cardNeedsSync(card);
  
  if (needsSync) {
    btn.style.opacity = '1';
    btn.title = 'Sync card to cloud';
  } else {
    btn.style.opacity = '0.5';
    btn.title = 'All data synced ';
  }
}

// Check if card has any unsyncced data
function cardNeedsSync(card) {
  if (!card) return false;
  
  // Check for local images
  if (card.screenshot && card.screenshot.startsWith('data:image/')) {
    return true;
  }
  
  if (card.photos && card.photos.some(p => p.startsWith('data:image/'))) {
    return true;
  }
  
  // Check if card was never synced or was edited since last sync
  if (!card.cloudSynced) {
    return true;
  }
  
  if (card.lastEdited && card.lastCloudSync) {
    if (new Date(card.lastEdited) > new Date(card.lastCloudSync)) {
      return true;
    }
  }
  
  return false;
}

// Update sync button visibility based on card state
function updateSyncButtonVisibility(card) {
  const btn = document.getElementById('editSyncBtn');
  if (!btn) return;
  
  // Show only if: signed in AND card has local images
  if (currentUser && cardNeedsImageSync(card)) {
    btn.style.display = 'flex';
    btn.title = 'Sync images to cloud';
  } else if (currentUser && !cardNeedsImageSync(card)) {
    btn.style.display = 'flex';
    btn.style.opacity = '0.5';
    btn.title = 'All images synced ';
  } else {
    btn.style.display = 'none';
  }
}

// Upload a single card to cloud
async function uploadCardToCloud(card) {
  if (!cloudSyncEnabled || !currentUser) return null;
  if (card.isPrivate) return null; // Never upload private cards
  if (card.url?.startsWith('thought://') && card.url?.includes('-guide')) return null; // Don't upload guide cards
  
  try {
    // Prepare card data (exclude large photos from main record)
    const cloudCard = {
      id: String(card.id),  // Ensure it's a string
      user_id: currentUser.id,
      url: card.url,
      title: card.title,
      notes: card.notes || '',
      location: card.location || '',
      topic: card.topic || 'other',
      tags: card.tags || [],
      screenshot: getStorableScreenshot(card), // Smart screenshot handling
      screenshot_real: card.screenshotReal || false,
      is_private: false,
      added_by: card.addedBy || username,
      created_at: card.createdAt || new Date().toISOString()
    };
    
    const { data, error } = await supabaseClient
      .from('cards')
      .upsert(cloudCard, { onConflict: 'id' })
      .select()
      .single();
    
    if (error) throw error;
    
    // Mark local card as synced
    card.cloudSynced = true;
    card.lastCloudSync = new Date().toISOString();
    
    return data;
    
  } catch (error) {
    console.error('Upload card error:', error);
    return null;
  }
}

// Delete card from cloud
async function deleteCardFromCloud(cardId) {
  if (!cloudSyncEnabled || !currentUser) return;
  
  try {
    await supabaseClient
      .from('cards')
      .delete()
      .eq('id', cardId)
      .eq('user_id', currentUser.id);
  } catch (error) {
    console.error('Delete from cloud error:', error);
  }
}

// Convert cloud card format to local format
function cloudCardToLocal(cloudCard) {
  // Regenerate screenshot if missing
  let screenshot = cloudCard.screenshot;
  
  // If no screenshot, try to generate one from URL
  if (!screenshot || screenshot === 'null') {
    // YouTube - use thumbnail URL
    if (cloudCard.url && (cloudCard.url.includes('youtube.com') || cloudCard.url.includes('youtu.be'))) {
      const videoId = extractYouTubeId(cloudCard.url);
      if (videoId) {
        screenshot = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
      }
    }
  }
  
  // Build the local card object
  const localCard = {
    id: cloudCard.id,
    url: cloudCard.url,
    title: cloudCard.title,
    notes: cloudCard.notes || '',
    location: cloudCard.location || '',
    topic: cloudCard.topic || 'other',
    tags: cloudCard.tags || [],
    screenshot: screenshot,
    screenshotReal: !!screenshot && screenshot.startsWith('http'),
    isPrivate: cloudCard.is_private,
    votes: cloudCard.vote_total || 0,
    photos: [],
    comments: [],
    starred: false,
    addedBy: cloudCard.added_by || 'Anonymous',
    createdAt: cloudCard.created_at,
    lastEdited: cloudCard.updated_at,
    editedBy: cloudCard.added_by,
    cloudSynced: true,
    cloudUserId: cloudCard.user_id,
    isOwnCard: cloudCard.user_id === currentUser?.id,
    isCommunity: cloudCard.user_id !== currentUser?.id
  };
  
  // If still no screenshot, generate a placeholder
  if (!localCard.screenshot) {
    localCard.screenshot = generatePlaceholderThumbnail(localCard);
    localCard.screenshotReal = false;
  }
  
  return localCard;
}

// Sync votes from cloud
async function syncVotesFromCloud() {
  if (!cloudSyncEnabled || !currentUser) return;
  
  try {
    // Get user's votes
    const { data: myVotes, error } = await supabaseClient
      .from('votes')
      .select('card_id, value')
      .eq('user_id', currentUser.id);
    
    if (error) throw error;
    
    if (myVotes) {
      myVotes.forEach(v => {
        userVotes[v.card_id] = v.value;
      });
      localStorage.setItem('linkgrid-votes', JSON.stringify(userVotes));
    }
    
  } catch (error) {
    console.error('Sync votes error:', error);
  }
}

// Sync comments from cloud
async function syncCommentsFromCloud() {
  if (!cloudSyncEnabled) return;
  
  try {
    const cardIds = cards.map(c => c.id);
    if (!cardIds.length) return;
    
    const { data: comments, error } = await supabaseClient
      .from('comments')
      .select('*')
      .in('card_id', cardIds)
      .order('created_at', { ascending: true });
    
    if (error) throw error;
    
    if (comments) {
      // Group comments by card
      const commentsByCard = {};
      comments.forEach(c => {
        if (!commentsByCard[c.card_id]) commentsByCard[c.card_id] = [];
        commentsByCard[c.card_id].push({
          id: c.id,
          text: c.text,
          author: c.author,
          timestamp: c.created_at,
          userId: c.user_id,
          isOwn: c.user_id === currentUser?.id
        });
      });
      
      // Merge into cards
      cards.forEach(card => {
        if (commentsByCard[card.id]) {
          card.comments = commentsByCard[card.id];
        }
      });
    }
    
  } catch (error) {
    console.error('Sync comments error:', error);
  }
}

// Background sync to cloud
async function syncToCloud() {
  if (!cloudSyncEnabled || !currentUser || syncInProgress) return;
  
  // Find cards that need syncing
  const needsSync = cards.filter(c => 
    !c.isPrivate && 
    !c.cloudSynced && 
    !c.url?.includes('-guide') &&
    c.addedBy === username
  );
  
  for (const card of needsSync) {
    await uploadCardToCloud(card);
  }
  
  if (needsSync.length > 0) {
    saveCards();
  }
}

// Vote on cloud
async function voteOnCloud(cardId, value) {
  if (!cloudSyncEnabled || !currentUser) return;
  
  try {
    if (value === 0) {
      // Remove vote
      await supabaseClient
        .from('votes')
        .delete()
        .eq('card_id', cardId)
        .eq('user_id', currentUser.id);
    } else {
      // Upsert vote
      await supabaseClient
        .from('votes')
        .upsert({
          card_id: cardId,
          user_id: currentUser.id,
          value: value
        }, { onConflict: 'card_id,user_id' });
    }
  } catch (error) {
    console.error('Vote cloud error:', error);
  }
}

// Add comment to cloud
async function addCommentToCloud(cardId, text) {
  if (!cloudSyncEnabled || !currentUser) return null;
  
  try {
    const { data, error } = await supabaseClient
      .from('comments')
      .insert({
        card_id: cardId,
        user_id: currentUser.id,
        text: text,
        author: username
      })
      .select()
      .single();
    
    if (error) throw error;
    return data;
    
  } catch (error) {
    console.error('Add comment cloud error:', error);
    return null;
  }
}

// Delete comment from cloud
async function deleteCommentFromCloud(commentId) {
  if (!cloudSyncEnabled || !currentUser) return;
  
  try {
    await supabaseClient
      .from('comments')
      .delete()
      .eq('id', commentId)
      .eq('user_id', currentUser.id);
  } catch (error) {
    console.error('Delete comment cloud error:', error);
  }
}

// Setup realtime subscriptions for live updates
function setupRealtimeSubscriptions() {
  if (!supabaseClient || realtimeSubscription) return;
  
  realtimeSubscription = supabaseClient
    .channel('public-updates')
    // Listen for new cards
    .on('postgres_changes', 
      { event: 'INSERT', schema: 'public', table: 'cards', filter: 'is_private=eq.false' },
      (payload) => {
        handleNewCardFromCloud(payload.new);
      }
    )
    // Listen for card updates
    .on('postgres_changes',
      { event: 'UPDATE', schema: 'public', table: 'cards' },
      (payload) => {
        handleCardUpdateFromCloud(payload.new);
      }
    )
    // Listen for card deletions
    .on('postgres_changes',
      { event: 'DELETE', schema: 'public', table: 'cards' },
      (payload) => {
        handleCardDeleteFromCloud(payload.old);
      }
    )
    // Listen for new comments
    .on('postgres_changes',
      { event: 'INSERT', schema: 'public', table: 'comments' },
      (payload) => {
        handleNewCommentFromCloud(payload.new);
      }
    )
    // Listen for profile/username changes (for current user)
    .on('postgres_changes',
      { event: 'UPDATE', schema: 'public', table: 'profiles', filter: `id=eq.${currentUser?.id}` },
      (payload) => {
        handleUsernameChangeFromCloud(payload.new);
      }
    )
    .subscribe();
}

function handleUsernameChangeFromCloud(profile) {
  if (!profile || !profile.username) return;
  
  // If username changed from another device
  if (profile.username !== username) {
    console.log(' Username updated from another device:', profile.username);
    
    const oldUsername = username;
    username = profile.username;
    localStorage.setItem('linkgrid-username', username);
    
    // Update local cards that had the old name
    cards.forEach(card => {
      if (card.addedBy === oldUsername || card.isOwnCard) {
        card.addedBy = username;
        card.editedBy = username;
      }
    });
    
    saveCards();
    renderGrid();
    
    showToast(` Username synced: ${username}`, 'success');
  }
}

// Handle new card from another user
function handleNewCardFromCloud(cloudCard) {
  // Don't add if it's our own card (we already have it)
  if (cloudCard.user_id === currentUser?.id) return;
  
  // Don't add if we already have this card
  if (cards.some(c => c.id === cloudCard.id || c.url === cloudCard.url)) return;
  
  // Add to local cards
  const localCard = cloudCardToLocal(cloudCard);
  cards.unshift(localCard);
  saveCards();
  renderGrid();
  
  // Show notification
  showToast(` New card: "${cloudCard.title.substring(0, 30)}..."`, 'success');
  
  // Update Discover if open
  if (document.getElementById('discoverView').classList.contains('active')) {
    buildBubbleData();
    renderBubbles();
  }
}

// Handle card update from cloud
function handleCardUpdateFromCloud(cloudCard) {
  const localCard = cards.find(c => c.id === cloudCard.id);
  if (!localCard) return;
  
  // Only update if it's not our card (we're the source of truth for our own cards)
  if (cloudCard.user_id === currentUser?.id) return;
  
  // Update local card
  localCard.title = cloudCard.title;
  localCard.notes = cloudCard.notes;
  localCard.tags = cloudCard.tags;
  localCard.topic = cloudCard.topic;
  
  saveCards();
  renderGrid();
}

// Handle card deletion from cloud
function handleCardDeleteFromCloud(cloudCard) {
  // Only remove if it's not our card
  if (cloudCard.user_id === currentUser?.id) return;
  
  const index = cards.findIndex(c => c.id === cloudCard.id);
  if (index > -1) {
    cards.splice(index, 1);
    saveCards();
    renderGrid();
  }
}

// Handle new comment from cloud
function handleNewCommentFromCloud(cloudComment) {
  // Don't duplicate our own comments
  if (cloudComment.user_id === currentUser?.id) return;
  
  const card = cards.find(c => c.id === cloudComment.card_id);
  if (!card) return;
  
  // Check if comment already exists
  if (card.comments?.some(c => c.id === cloudComment.id)) return;
  
  if (!card.comments) card.comments = [];
  card.comments.push({
    id: cloudComment.id,
    text: cloudComment.text,
    author: cloudComment.author,
    timestamp: cloudComment.created_at,
    userId: cloudComment.user_id,
    isOwn: false
  });
  
  saveCards();
  
  // Update UI if viewing this card
  if (currentCardId === card.id) {
    renderEditComments();
  }
}

// Fetch all public cards for Discover feed
// Fetch all public cards for Discover feed
async function fetchCommunityCards() {
  if (!supabaseClient) {
    console.log(' No Supabase client available');
    return [];
  }
  
  try {
    // Try the view first (has vote totals)
    let { data, error } = await supabaseClient
      .from('cards_with_votes')
      .select('*')
      .eq('is_private', false)
      .order('created_at', { ascending: false })
      .limit(200);
    
    // If view doesn't exist, fall back to base table
    if (error) {
      console.warn('cards_with_votes view error, trying cards table:', error.message);
      
      ({ data, error } = await supabaseClient
        .from('cards')
        .select('*')
        .eq('is_private', false)
        .order('created_at', { ascending: false })
        .limit(200));
    }
    
    if (error) {
      console.error(' Fetch community cards error:', error);
      return [];
    }
    
    console.log(` Fetched ${data?.length || 0} public cards from database`);
    return (data || []).map(cloudCardToLocal);
    
  } catch (error) {
    console.error(' Fetch community cards exception:', error);
    return [];
  }
}

// Cleanup realtime subscription
function cleanupRealtimeSubscription() {
  if (realtimeSubscription) {
    supabaseClient.removeChannel(realtimeSubscription);
    realtimeSubscription = null;
  }
}

// ============== LOAD & SAVE ==============
async function loadCards() {
  const stored = localStorage.getItem('linkgrid-cards');
  if (stored) {
    let loaded = JSON.parse(stored);
    
    // Fix images from IndexedDB
    loaded = await Promise.all(loaded.map(async (c) => {
      if (c.screenshot && !c.screenshot.startsWith('data:') && !c.screenshot.startsWith('http')) {
        try { c.screenshot = await getImage(c.screenshot) || c.screenshot; } catch(e) {}
      }
      if (c.photos?.length) {
        c.photos = await Promise.all(c.photos.map(async (p) => {
          if (!p.startsWith('data:') && !p.startsWith('http')) {
            try { return await getImage(p) || p; } catch(e) { return p; }
          }
          return p;
        }));
      }
      return c;
    }));
    
    // Filter out guide cards that shouldn't be in main collection
    loaded = loaded.filter(c => {
      // Remove guide cards unless they were starred (promoted)
      if (c.url?.startsWith('thought://') && c.url?.includes('-guide')) {
        return c.starred === true;
      }
      return true;
    });
    
    // Remove duplicates by URL
    const seen = new Set();
    cards = loaded.filter(card => {
      if (seen.has(card.url)) return false;
      seen.add(card.url);
      return true;
    });
    
    // Fix cards that have broken/missing thumbnails
    cards.forEach(card => {
      // Skip if already has a valid real screenshot
      if (card.screenshotReal && card.screenshot && 
          (card.screenshot.startsWith('http') || card.screenshot.startsWith('data:image/'))) {
        return;
      }
      
      // YouTube / youtu.be - always use direct thumbnail
      if (card.url && (card.url.includes('youtube.com') || card.url.includes('youtu.be'))) {
        const videoId = extractYouTubeId(card.url);
        if (videoId) {
          card.screenshot = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
          card.screenshotReal = true;
          // Fix title if it's just the video ID
          if (card.title === videoId || card.title.includes(videoId) || card.title.length < 5) {
            card.title = 'YouTube Video';
          }
        }
        return;
      }
      
      // Vimeo - use thumbnail API format
      if (card.url && card.url.includes('vimeo.com')) {
        const vimeoMatch = card.url.match(/vimeo\.com\/(\d+)/);
        if (vimeoMatch) {
          // Vimeo thumbnails need API call, so mark for retry
          if (!card.screenshot || !card.screenshot.startsWith('http')) {
            card.screenshot = generatePlaceholderThumbnail(card);
            card.screenshotReal = false;
          }
        }
        return;
      }
      
      // GitHub - use opengraph image pattern
      if (card.url && card.url.includes('github.com')) {
        try {
          const ghUrl = new URL(card.url);
          const pathParts = ghUrl.pathname.split('/').filter(Boolean);
          if (pathParts.length >= 2) {
            // GitHub's OpenGraph image format
            card.screenshot = `https://opengraph.githubassets.com/1/${pathParts[0]}/${pathParts[1]}`;
            card.screenshotReal = true;
          }
        } catch (e) {}
        return;
      }
      
      // Reddit - use preview image if available in URL
      if (card.url && (card.url.includes('reddit.com') || card.url.includes('redd.it'))) {
        // Reddit previews need API, mark for retry
        if (!card.screenshot || !card.screenshot.startsWith('http')) {
          card.screenshot = generatePlaceholderThumbnail(card);
          card.screenshotReal = false;
        }
        return;
      }
      
      // Restricted sites - use placeholder (don't retry)
      const restrictedSites = ['twitter.com', 'x.com', 'instagram.com', 'facebook.com', 'linkedin.com', 'tiktok.com'];
      if (restrictedSites.some(site => card.url?.includes(site))) {
        if (!card.screenshot || card.screenshot.length < 100) {
          card.screenshot = generatePlaceholderThumbnail(card);
          card.screenshotReal = false;
        }
        return;
      }
      
      // All other URLs - check if screenshot is broken/missing
      if (!card.screenshot || 
          card.screenshot === 'null' || 
          card.screenshot === 'undefined' ||
          card.screenshot.length < 50) {
        // Generate placeholder and add to retry queue on next render
        card.screenshot = generatePlaceholderThumbnail(card);
        card.screenshotReal = false;
      }
    });
  }
  
  userVotes = JSON.parse(localStorage.getItem('linkgrid-votes') || '{}');
  username = localStorage.getItem('linkgrid-username') || 'You';
  collections = JSON.parse(localStorage.getItem('linkgrid-collections') || '[]');
  
  if (localStorage.getItem('linkgrid-header-collapsed') === 'true') {
    headerCollapsed = true;
    const el = document.getElementById('headerExpand');
    if (el) el.classList.add('collapsed');
  }
  
  compactCards = new Set(JSON.parse(localStorage.getItem('linkgrid-compact-cards') || '[]'));
  const sp = localStorage.getItem('linkgrid-show-contributors');
  if (sp !== null) showContributors = sp === 'true';
  
  checkForSharedCard();
  checkForSharedCollection();
  renderGrid();
}

async function saveCards() {
  const toSave = await Promise.all(cards.map(async (c) => {
    const copy = { ...c };
    if (c.screenshot?.startsWith('data:')) {
      const key = `screenshot-${c.id}`;
      await storeImage(key, c.screenshot);
      copy.screenshot = key;
    }
    if (c.photos?.length) {
      copy.photos = await Promise.all(c.photos.map(async (p, i) => {
        if (p.startsWith('data:')) {
          const key = `photo-${c.id}-${i}`;
          await storeImage(key, p);
          return key;
        }
        return p;
      }));
    }
    return copy;
  }));
  localStorage.setItem('linkgrid-cards', JSON.stringify(toSave));
  document.getElementById('link-count').textContent = cards.length;
  
  // Trigger background cloud sync for new/updated cards
  if (cloudSyncEnabled && !syncInProgress) {
    syncToCloud();
  }
}
function saveCollections() {
  localStorage.setItem('linkgrid-collections', JSON.stringify(collections));
}

// ============== METADATA ==============
async function fetchMetadata(url) {
  // First, try to extract info from the URL itself (works without CORS)
  const urlBasedMeta = extractMetadataFromURL(url);
  
  // Check for YouTube - we can get thumbnail directly without API
  if (url.includes('youtube.com') || url.includes('youtu.be')) {
    const videoId = extractYouTubeId(url);
    if (videoId) {
      return { 
        title: urlBasedMeta.title || 'YouTube Video', 
        description: '', 
        icon: 'https://www.youtube.com/favicon.ico',
        image: `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`,
        hasMetadata: true 
      };
    }
  }
  
  // Try the API (will fail on local files due to CORS, but works when hosted)
  try {
    const res = await fetch(`https://jsonlink.io/api/extract?url=${encodeURIComponent(url)}`, { 
      signal: AbortSignal.timeout(5000) 
    });
    if (res.ok) {
      const d = await res.json();
      return { 
        title: d.title || urlBasedMeta.title, 
        description: d.description || '', 
        icon: d.favicon || urlBasedMeta.icon,
        image: d.images?.[0] || null,
        hasMetadata: true 
      };
    }
  } catch(e) {
    // CORS error or timeout - use URL-based metadata
    console.log('Metadata API unavailable, using URL-based fallback');
  }
  
  return urlBasedMeta;
}

function extractYouTubeId(url) {
  const patterns = [
    /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/,
    /youtube\.com\/shorts\/([^&\n?#]+)/
  ];
  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) return match[1];
  }
  return null;
}

function extractMetadataFromURL(url) {
  try {
    const u = new URL(url);
    let title = u.hostname.replace('www.', '');
    const path = u.pathname.split('/').filter(p => p);
    if (path.length) {
      const last = path[path.length - 1].replace(/[-_]/g, ' ').replace(/\.(html|php|asp|jsp)$/i, '');
      if (last.length > 3 && last.length < 60) title = last.charAt(0).toUpperCase() + last.slice(1);
    }
    if (u.hostname.includes('twitter.com') || u.hostname.includes('x.com')) title = 'Post on X';
    else if (u.hostname.includes('youtube.com') || u.hostname.includes('youtu.be')) title = 'YouTube Video';
    else if (u.hostname.includes('github.com')) title = 'GitHub Repository';
    return { title, description: url, icon: `https://www.google.com/s2/favicons?domain=${u.hostname}&sz=64`, hasMetadata: true };
  } catch(e) {
    return { title: url, description: '', icon: '', hasMetadata: false };
  }
}

// ============== SCREENSHOTS ==============
async function generateScreenshot(url) {
  try {
    const screenshotUrl = `https://image.thum.io/get/width/400/crop/300/noanimate/${encodeURIComponent(url)}`;
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve({ url: screenshotUrl, isReal: true, success: true });
      img.onerror = () => resolve({ url: generateMockScreenshot(url), isReal: false, success: false });
      img.src = screenshotUrl;
      setTimeout(() => resolve({ url: generateMockScreenshot(url), isReal: false, success: false }), 5000);
    });
  } catch(e) {
    return { url: generateMockScreenshot(url), isReal: false, success: false };
  }
}

function generateMockScreenshot(url) {
  const colors = ['#6366f1', '#8b5cf6', '#ec4899', '#f59e0b', '#10b981', '#3b82f6'];
  const c = colors[Math.floor(Math.random() * colors.length)];
  const text = encodeURIComponent(url.substring(0, 30));
  return `data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='400' height='300'%3E%3Crect width='400' height='300' fill='${c}'/%3E%3Ctext x='50%25' y='50%25' font-family='sans-serif' font-size='14' fill='white' text-anchor='middle'%3E${text}%3C/text%3E%3C/svg%3E`;
}

// Generate beautiful placeholder thumbnail
function generatePlaceholderThumbnail(card) {
  const canvas = document.createElement('canvas');
  canvas.width = 400;
  canvas.height = 250;
  const ctx = canvas.getContext('2d');
  
  // Topic-based color schemes
  const colorSchemes = {
    tech: { primary: '#6366f1', secondary: '#8b5cf6', accent: '#a5b4fc' },
    news: { primary: '#f59e0b', secondary: '#d97706', accent: '#fcd34d' },
    food: { primary: '#10b981', secondary: '#059669', accent: '#6ee7b7' },
    travel: { primary: '#06b6d4', secondary: '#0891b2', accent: '#67e8f9' },
    entertainment: { primary: '#ec4899', secondary: '#db2777', accent: '#f9a8d4' },
    other: { primary: '#8b5cf6', secondary: '#7c3aed', accent: '#c4b5fd' }
  };
  
  const colors = colorSchemes[card.topic] || colorSchemes.other;
  
  // Create gradient background
  const grad = ctx.createLinearGradient(0, 0, 400, 250);
  grad.addColorStop(0, colors.primary);
  grad.addColorStop(0.5, colors.secondary);
  grad.addColorStop(1, colors.primary);
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 400, 250);
  
  // Add animated-looking wave pattern
  ctx.fillStyle = 'rgba(255, 255, 255, 0.03)';
  for (let i = 0; i < 5; i++) {
    ctx.beginPath();
    ctx.moveTo(0, 150 + i * 20);
    for (let x = 0; x <= 400; x += 20) {
      ctx.lineTo(x, 150 + i * 20 + Math.sin(x * 0.02 + i) * 20);
    }
    ctx.lineTo(400, 250);
    ctx.lineTo(0, 250);
    ctx.closePath();
    ctx.fill();
  }
  
  // Add floating circles/orbs
  ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
  const orbs = [
    { x: 50, y: 40, r: 60 },
    { x: 350, y: 60, r: 80 },
    { x: 150, y: 180, r: 40 },
    { x: 300, y: 200, r: 50 },
    { x: 80, y: 150, r: 30 }
  ];
  orbs.forEach(orb => {
    ctx.beginPath();
    ctx.arc(orb.x, orb.y, orb.r, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Add small floating particles
  ctx.fillStyle = colors.accent;
  for (let i = 0; i < 30; i++) {
    ctx.globalAlpha = Math.random() * 0.5 + 0.2;
    ctx.beginPath();
    ctx.arc(
      Math.random() * 400,
      Math.random() * 250,
      Math.random() * 3 + 1,
      0, Math.PI * 2
    );
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  // Add subtle grid pattern
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
  ctx.lineWidth = 1;
  for (let x = 0; x < 400; x += 40) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 250);
    ctx.stroke();
  }
  for (let y = 0; y < 250; y += 40) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(400, y);
    ctx.stroke();
  }
  
  // Topic emoji
  const emojis = { tech: '', news: '', food: '', travel: '', entertainment: '', other: '' };
  ctx.font = '40px sans-serif';
  ctx.fillText(emojis[card.topic] || '', 20, 50);
  
  // Title text with shadow
  ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
  ctx.shadowBlur = 10;
  ctx.shadowOffsetX = 2;
  ctx.shadowOffsetY = 2;
  ctx.fillStyle = 'white';
  ctx.font = 'bold 22px Inter, system-ui, sans-serif';
  
  // Word wrap title
  const words = card.title.split(' ');
  let line = '';
  let y = 100;
  const maxWidth = 360;
  
  words.forEach(word => {
    const testLine = line + word + ' ';
    if (ctx.measureText(testLine).width > maxWidth && line) {
      ctx.fillText(line.trim(), 20, y);
      line = word + ' ';
      y += 28;
    } else {
      line = testLine;
    }
  });
  if (line && y < 200) {
    ctx.fillText(line.trim(), 20, y);
  }
  
  // Reset shadow
  ctx.shadowColor = 'transparent';
  ctx.shadowBlur = 0;
  
  // URL domain at bottom
  try {
    const domain = new URL(card.url).hostname.replace('www.', '');
    ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.font = '12px Inter, system-ui, sans-serif';
    ctx.fillText(domain, 20, 235);
  } catch (e) {}
  
  return canvas.toDataURL('image/png');
}

// Get valid thumbnail or generate placeholder
function getCardThumbnail(card) {
  // 1. Try YouTube thumbnail first (most reliable)
  if (card.url && (card.url.includes('youtube.com') || card.url.includes('youtu.be'))) {
    const videoId = extractYouTubeId(card.url);
    if (videoId) {
      return `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
    }
  }
  
  // 2. Check if screenshot exists and is valid
  if (card.screenshot) {
    // Valid URL
    if (card.screenshot.startsWith('http') && card.screenshot.length > 20) {
      return card.screenshot;
    }
    // Valid base64
    if (card.screenshot.startsWith('data:image/') && card.screenshot.length > 100) {
      return card.screenshot;
    }
  }
  
  // 3. Try to get from photos
  if (card.photos && card.photos.length > 0) {
    const photo = card.photos[0];
    if (photo && (photo.startsWith('http') || photo.startsWith('data:image/'))) {
      return photo;
    }
  }
  
  // 4. Generate placeholder as last resort
  return generatePlaceholderThumbnail(card);
}
  
  // ============== THUMBNAIL RETRY SYSTEM ==============
  let thumbnailRetryQueue = new Set();
  let thumbnailRetryInterval = null;

  function handleThumbnailError(imgElement, cardId) {
    // Prevent infinite loop
    imgElement.onerror = null;
    
    const card = cards.find(c => c.id === cardId);
    if (!card) {
      imgElement.src = generateMockScreenshot('broken-link');
      return;
    }
    
    // Try YouTube thumbnail directly if it's a YouTube URL
    if (card.url && (card.url.includes('youtube.com') || card.url.includes('youtu.be'))) {
      const videoId = extractYouTubeId(card.url);
      if (videoId) {
        // Try different quality thumbnails
        const currentSrc = imgElement.src;
        if (currentSrc.includes('hqdefault')) {
          imgElement.src = `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`;
          imgElement.onerror = () => {
            imgElement.onerror = null;
            imgElement.src = generatePlaceholderThumbnail(card);
          };
          return;
        }
      }
    }
    
    // Use generated placeholder
    imgElement.src = generatePlaceholderThumbnail(card);
    
    // Add to retry queue if not already there
    if (!card.screenshotReal && !thumbnailRetryQueue.has(cardId)) {
      thumbnailRetryQueue.add(cardId);
      startThumbnailRetryTimer();
    }
  }

  function startThumbnailRetryTimer() {
    if (thumbnailRetryInterval) return;
    
    // Retry every 30 seconds
    thumbnailRetryInterval = setInterval(async () => {
      if (thumbnailRetryQueue.size === 0) {
        clearInterval(thumbnailRetryInterval);
        thumbnailRetryInterval = null;
        return;
      }
      
      // Process up to 3 cards per cycle
      const toRetry = [...thumbnailRetryQueue].slice(0, 3);
      
      for (const cardId of toRetry) {
        const card = cards.find(c => c.id === cardId);
        if (!card) {
          thumbnailRetryQueue.delete(cardId);
          continue;
        }
        
        // Skip if already has real screenshot
        if (card.screenshotReal) {
          thumbnailRetryQueue.delete(cardId);
          continue;
        }
        
        // Try to fetch a real thumbnail
        const newThumbnail = await tryFetchThumbnail(card);
        if (newThumbnail) {
          card.screenshot = newThumbnail;
          card.screenshotReal = true;
          thumbnailRetryQueue.delete(cardId);
          saveCards();
          renderGrid();
          
          // Also update Discover if open
          if (document.getElementById('discoverView').classList.contains('active')) {
            const bubble = bubbles.find(b => b.bubbleId === String(cardId));
            if (bubble) {
              bubble.screenshot = newThumbnail;
              bubble.screenshotReal = true;
            }
            const bubbleImg = document.querySelector(`#bubble-${cardId} .bubble-card-image img`);
            if (bubbleImg) bubbleImg.src = newThumbnail;
          }
          
          console.log(` Thumbnail updated for: ${card.title}`);
        }
      }
    }, 30000);
  }

  async function tryFetchThumbnail(card) {
    if (!card.url) return null;
    
    try {
      const url = new URL(card.url);
      const hostname = url.hostname.toLowerCase();
      
      // YouTube - always use direct thumbnail URL
      if (hostname.includes('youtube.com') || hostname.includes('youtu.be')) {
        const videoId = extractYouTubeId(card.url);
        if (videoId) {
          const thumbUrl = `https://img.youtube.com/vi/${videoId}/hqdefault.jpg`;
          if (await testImageUrl(thumbUrl)) return thumbUrl;
          const mqUrl = `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`;
          if (await testImageUrl(mqUrl)) return mqUrl;
        }
        return null;
      }
      
      // GitHub - use opengraph image
      if (hostname.includes('github.com')) {
        const pathParts = url.pathname.split('/').filter(Boolean);
        if (pathParts.length >= 2) {
          const ghThumb = `https://opengraph.githubassets.com/1/${pathParts[0]}/${pathParts[1]}`;
          if (await testImageUrl(ghThumb)) return ghThumb;
        }
        return null;
      }
      
      // Medium - use miro.medium.com pattern
      if (hostname.includes('medium.com')) {
        // Medium uses dynamic OG images, try screenshot service
        const result = await generateScreenshot(card.url);
        if (result.isReal) return result.url;
        return null;
      }
      
      // Wikipedia - use page image API
      if (hostname.includes('wikipedia.org')) {
        const pageTitle = url.pathname.split('/wiki/')[1];
        if (pageTitle) {
          const wikiThumb = `https://en.wikipedia.org/wiki/Special:FilePath/${decodeURIComponent(pageTitle)}?width=400`;
          // Wikipedia redirects, so test with fetch
          try {
            const resp = await fetch(wikiThumb, { method: 'HEAD', mode: 'no-cors' });
            // If no error, URL is likely valid
            return wikiThumb;
          } catch (e) {}
        }
      }
      
      // News sites & blogs - try metadata fetch first
      const newsSites = ['nytimes.com', 'bbc.com', 'cnn.com', 'theverge.com', 'techcrunch.com', 'wired.com', 'arstechnica.com'];
      if (newsSites.some(site => hostname.includes(site))) {
        const metadata = await fetchMetadata(card.url);
        if (metadata.image && await testImageUrl(metadata.image)) {
          return metadata.image;
        }
      }
      
      // Restricted sites - don't retry
      const restrictedSites = ['twitter.com', 'x.com', 'instagram.com', 'facebook.com', 'linkedin.com', 'tiktok.com'];
      if (restrictedSites.some(site => hostname.includes(site))) {
        return null;
      }
      
      // Generic: try metadata fetch first (for OpenGraph images)
      const metadata = await fetchMetadata(card.url);
      if (metadata.image) {
        if (await testImageUrl(metadata.image)) {
          return metadata.image;
        }
      }
      
      // Last resort: try screenshot service
      const result = await generateScreenshot(card.url);
      if (result.isReal) {
        return result.url;
      }
      
    } catch (e) {
      console.warn('Thumbnail fetch failed for:', card.url, e);
    }
    
    return null;
  }

  function testImageUrl(url) {
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(true);
      img.onerror = () => resolve(false);
      img.src = url;
      // Timeout after 5 seconds
      setTimeout(() => resolve(false), 5000);
    });
  }
  

async function retryScreenshot(cardId) {
  const card = cards.find(c => c.id === cardId);
  if (!card || card.screenshotReal) return;
  
  // Skip retry for restricted sites
  const restrictedSites = ['twitter.com', 'x.com', 'instagram.com', 'facebook.com', 'linkedin.com', 'tiktok.com'];
  if (restrictedSites.some(site => card.url?.includes(site))) return;
  
  const result = await generateScreenshot(card.url);
  card.screenshot = result.url;
  card.screenshotReal = result.isReal;
  saveCards();
  renderGrid();
}

// ============== ADD MODAL ==============
function openAddModal() {
  document.getElementById('addModal').classList.add('active');
  switchAddTab('link');
}

function closeAddModal() {
  document.getElementById('addModal').classList.remove('active');
  document.getElementById('newUrl').value = '';
  const titleEl = document.getElementById('newMediaTitle');
  if (titleEl) titleEl.value = '';
  const thoughtTitle = document.getElementById('thoughtTitle');
  const thoughtContent = document.getElementById('thoughtContent');
  if (thoughtTitle) thoughtTitle.value = '';
  if (thoughtContent) thoughtContent.value = '';
  selectedNewMediaFiles = [];
  const preview = document.getElementById('newMediaPreviewArea');
  if (preview) preview.style.display = 'none';
}

function switchAddTab(tab) {
  const linkTab = document.getElementById('linkTab');
  const mediaTab = document.getElementById('mediaTab');
  const thoughtTab = document.getElementById('thoughtTab');
  const linkBtn = document.getElementById('linkTabBtn');
  const mediaBtn = document.getElementById('mediaTabBtn');
  const thoughtBtn = document.getElementById('thoughtTabBtn');
  
  if (linkTab) linkTab.style.display = 'none';
  if (mediaTab) mediaTab.style.display = 'none';
  if (thoughtTab) thoughtTab.style.display = 'none';
  
  const inactive = { background: 'var(--bg-elevated)', border: '1px solid var(--border-subtle)' };
  const active = { background: 'var(--gradient)', border: 'none' };
  
  if (linkBtn) Object.assign(linkBtn.style, inactive);
  if (mediaBtn) Object.assign(mediaBtn.style, inactive);
  if (thoughtBtn) Object.assign(thoughtBtn.style, inactive);
  
  if (tab === 'link' && linkTab && linkBtn) {
    linkTab.style.display = 'block';
    Object.assign(linkBtn.style, active);
    document.getElementById('newUrl')?.focus();
  } else if (tab === 'media' && mediaTab && mediaBtn) {
    mediaTab.style.display = 'block';
    Object.assign(mediaBtn.style, active);
  } else if (tab === 'thought' && thoughtTab && thoughtBtn) {
    thoughtTab.style.display = 'block';
    Object.assign(thoughtBtn.style, active);
    document.getElementById('thoughtContent')?.focus();
  }
}

async function addLink() {
  const url = document.getElementById('newUrl').value.trim();
  const topicEl = document.getElementById('newLinkTopic');
  const topic = topicEl ? topicEl.value : 'other';
  if (!url) return;
  
  try {
    new URL(url);
  } catch(e) {
    showToast('Please enter a valid URL', 'error');
    return;
  }
  
  // Fetch metadata first to check for thumbnails
  const metadata = await fetchMetadata(url);
  
  // Check if site blocks previews
  const restrictedSites = ['twitter.com', 'x.com', 'instagram.com', 'facebook.com', 'linkedin.com', 'tiktok.com'];
  const isRestricted = restrictedSites.some(site => url.includes(site));
  
  let screenshotResult;
  
  // Priority: 1) User uploaded screenshot, 2) OpenGraph/YouTube thumbnail, 3) Screenshot service, 4) Generated
  if (pendingLinkScreenshot) {
    // User uploaded a screenshot
    screenshotResult = { url: pendingLinkScreenshot, isReal: true, success: true };
    pendingLinkScreenshot = null;
  } else if (metadata.image) {
    // Use OpenGraph/YouTube thumbnail
    screenshotResult = { url: metadata.image, isReal: true, success: true };
  } else if (isRestricted) {
    // Use generated placeholder for restricted sites
    const placeholderCard = { title: metadata.title || url, topic: topic, url: url };
    screenshotResult = { 
      url: generatePlaceholderThumbnail(placeholderCard), 
      isReal: false, 
      success: true 
    };
  } else {
    // Try screenshot service
    screenshotResult = await generateScreenshot(url);
  }
  
    // Sanitize the URL
  const sanitizedUrl = sanitizeURL(url);
  if (!sanitizedUrl) {
    showToast('Invalid URL', 'error');
    return;
  }

  const newCard = {
    id: Date.now(),
    url: sanitizedUrl,
    screenshot: screenshotResult.url,
    screenshotReal: screenshotResult.isReal,
    title: metadata.title || new URL(url).hostname,
    notes: '',
    location: '',
    tags: [],
    topic: topic,
    votes: 0,
    photos: [],
    comments: [],
    starred: false,
    isPrivate: localStorage.getItem('linkgrid-default-card-private') === 'true',  // Respect default
    metadata: metadata,
    createdAt: new Date().toISOString(),
    lastEdited: new Date().toISOString(),
    editedBy: username,
    addedBy: username
  };
  
  cards.unshift(newCard);
  saveCards();
  renderGrid();
  closeAddModal();
  showToast('Link added!', 'success');
  
  // Prompt to sign in if not authenticated
  if (!currentUser) {
    setTimeout(() => {
      showToast(' Sign in to share with the community!', 'default');
    }, 2000);
  }
  
  if (!screenshotResult.isReal) {
    setTimeout(() => retryScreenshot(newCard.id), 3000);
  }
}
// ============== EDIT MODAL ==============
function openEditModal(id) {
  currentCardId = id;
  const card = cards.find(c => c.id === id);
  if (!card) return;
  
  const isGuideCard = card.isGuide || (card.url?.startsWith('thought://') && card.url?.includes('-guide'));
  document.getElementById('editModal').classList.add('active');
  
  // Setup media player
  setupMediaPlayer(card);
  
  // Image/Thumbnail
  const detailImage = document.getElementById('detailImage');
  let mainImage = card.screenshot;
  if (!card.screenshotReal && !card.customScreenshot && card.photos?.length) {
    mainImage = card.photos[0];
  }
  if (mainImage) {
    detailImage.src = mainImage;
    detailImage.style.display = 'block';
  } else {
    detailImage.src = generatePlaceholderThumbnail(card);
    detailImage.style.display = 'block';
  }
  
  // Title
  const titleInput = document.getElementById('editTitle');
  titleInput.value = card.title;
  titleInput.disabled = isGuideCard;
  
  // URL
  const urlLink = document.getElementById('editUrlLink');
  const urlText = document.getElementById('editUrlText');
  urlLink.href = card.url;
  urlText.textContent = card.url;
  
  // Notes
  document.getElementById('editNotes').value = card.notes || '';
  document.getElementById('editNotes').disabled = isGuideCard;
  
  // Location
  document.getElementById('editLocation').value = card.location || '';
  document.getElementById('editLocation').disabled = isGuideCard;
  
  // Privacy
  document.getElementById('editPrivate').checked = card.isPrivate || false;
  
  // Star button
  const starBtn = document.getElementById('editStarBtn');
  starBtn.textContent = card.starred ? '' : '';
  starBtn.title = card.starred ? 'Unstar' : 'Star';
  
  // Footer meta
  document.getElementById('editFooterMeta').textContent = `Created: ${new Date(card.createdAt).toLocaleDateString()}  Edited by ${card.editedBy || 'You'}`;
  
  // Hide delete for guide cards
  const deleteBtn = document.querySelector('.edit-footer-right .btn-danger');
  if (deleteBtn) deleteBtn.style.display = isGuideCard ? 'none' : 'flex';
  
  // Update votes, tags, photos, comments
  updateVoteDisplay(id);
  renderEditTags();
  renderEditPhotos();
  renderEditComments();
  
  // Show/hide sync button
  updateSyncButtonVisibility(card);
}

// ============== MEDIA DETECTION & PLAYBACK ==============
function detectMediaType(url) {
  if (!url) return { type: 'none', embedUrl: null };
  
  const urlLower = url.toLowerCase();
  
  // YouTube
  const ytMatch = url.match(/(?:youtube\.com\/(?:watch\?v=|embed\/|v\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
  if (ytMatch) {
    return { 
      type: 'youtube', 
      embedUrl: `https://www.youtube.com/embed/${ytMatch[1]}?autoplay=0&rel=0`,
      videoId: ytMatch[1]
    };
  }
  
  // Vimeo
  const vimeoMatch = url.match(/vimeo\.com\/(\d+)/);
  if (vimeoMatch) {
    return { 
      type: 'vimeo', 
      embedUrl: `https://player.vimeo.com/video/${vimeoMatch[1]}` 
    };
  }
  
  // Spotify
  const spotifyMatch = url.match(/spotify\.com\/(track|album|playlist|episode)\/([a-zA-Z0-9]+)/);
  if (spotifyMatch) {
    return { 
      type: 'spotify', 
      embedUrl: `https://open.spotify.com/embed/${spotifyMatch[1]}/${spotifyMatch[2]}` 
    };
  }
  
  // SoundCloud
  if (urlLower.includes('soundcloud.com')) {
    return { 
      type: 'soundcloud', 
      embedUrl: `https://w.soundcloud.com/player/?url=${encodeURIComponent(url)}&color=%236366f1&auto_play=false` 
    };
  }
  
  // Direct video files
  if (urlLower.match(/\.(mp4|webm|ogg|mov)(\?|$)/)) {
    return { type: 'video', embedUrl: url };
  }
  
  // Direct audio files
  if (urlLower.match(/\.(mp3|wav|ogg|m4a|flac)(\?|$)/)) {
    return { type: 'audio', embedUrl: url };
  }
  
  // Twitch
  const twitchMatch = url.match(/twitch\.tv\/(?:videos\/)?(\w+)/);
  if (twitchMatch) {
    const isVideo = url.includes('/videos/');
    return { 
      type: 'twitch', 
      embedUrl: isVideo 
        ? `https://player.twitch.tv/?video=${twitchMatch[1]}&parent=${window.location.hostname}`
        : `https://player.twitch.tv/?channel=${twitchMatch[1]}&parent=${window.location.hostname}`
    };
  }
  
  return { type: 'none', embedUrl: null };
}

function setupMediaPlayer(card) {
  const mediaPlayer = document.getElementById('editMediaPlayer');
  const mediaThumbnail = document.getElementById('editMediaThumbnail');
  const playBtn = document.getElementById('editPlayBtn');
  
  const media = detectMediaType(card.url);
  
  // Reset
  mediaPlayer.innerHTML = '';
  mediaPlayer.classList.remove('active');
  mediaThumbnail.style.display = 'block';
  playBtn.style.display = 'none';
  
  // Store media info for later
  mediaThumbnail.dataset.mediaType = media.type;
  mediaThumbnail.dataset.embedUrl = media.embedUrl || '';
  
  if (media.type !== 'none') {
    playBtn.style.display = 'flex';
    
    // For audio, show different icon
    if (media.type === 'audio' || media.type === 'spotify' || media.type === 'soundcloud') {
      playBtn.textContent = '';
    } else {
      playBtn.textContent = '';
    }
  }
}

function playMedia(event) {
  if (event) event.stopPropagation();
  
  const mediaThumbnail = document.getElementById('editMediaThumbnail');
  const mediaPlayer = document.getElementById('editMediaPlayer');
  const mediaType = mediaThumbnail.dataset.mediaType;
  const embedUrl = mediaThumbnail.dataset.embedUrl;
  
  if (!embedUrl || mediaType === 'none') return;
  
  let playerHTML = '';
  
  switch (mediaType) {
    case 'youtube':
    case 'vimeo':
    case 'twitch':
      playerHTML = `<iframe src="${embedUrl}" allowfullscreen allow="autoplay; encrypted-media; picture-in-picture"></iframe>`;
      break;
      
    case 'spotify':
      playerHTML = `<iframe src="${embedUrl}" allow="encrypted-media" style="height: 152px;"></iframe>`;
      break;
      
    case 'soundcloud':
      playerHTML = `<iframe src="${embedUrl}" allow="autoplay" style="height: 166px;"></iframe>`;
      break;
      
    case 'video':
      playerHTML = `<video src="${embedUrl}" controls autoplay playsinline></video>`;
      break;
      
    case 'audio':
      playerHTML = `
        <div style="display:flex;align-items:center;justify-content:center;height:100%;background:linear-gradient(135deg, var(--bg-secondary), var(--bg-elevated));">
          <div style="text-align:center;">
            <div style="font-size:4rem;margin-bottom:1rem;"></div>
            <audio src="${embedUrl}" controls autoplay style="width:90%;max-width:400px;"></audio>
          </div>
        </div>
      `;
      break;
  }
  
  mediaPlayer.innerHTML = playerHTML;
  mediaPlayer.classList.add('active');
  mediaThumbnail.style.display = 'none';
}

function stopMedia() {
  const mediaPlayer = document.getElementById('editMediaPlayer');
  const mediaThumbnail = document.getElementById('editMediaThumbnail');
  
  mediaPlayer.innerHTML = '';
  mediaPlayer.classList.remove('active');
  mediaThumbnail.style.display = 'block';
}

function closeEditModal() {
  // Stop any playing media
  stopMedia();
  
  document.getElementById('editModal').classList.remove('active');
  
  // Re-enable inputs that might have been disabled for view-only mode
  const titleInput = document.getElementById('editTitle');
  if (titleInput) titleInput.disabled = false;
  
  const notesEl = document.getElementById('editNotes');
  if (notesEl) notesEl.disabled = false;
  
  const locationEl = document.getElementById('editLocation');
  if (locationEl) locationEl.disabled = false;
  
  const tagInput = document.getElementById('newTag');
  if (tagInput) tagInput.style.display = 'block';
  
  const privacyToggle = document.querySelector('.edit-privacy-toggle');
  if (privacyToggle) privacyToggle.style.display = 'flex';
  
  const deleteBtn = document.querySelector('.edit-footer-right .btn-danger');
  if (deleteBtn) deleteBtn.style.display = 'flex';
  
  // Remove community save button if exists
  const saveCommunityBtn = document.getElementById('saveCommunityBtn');
  if (saveCommunityBtn) saveCommunityBtn.remove();
  
  // Restore image container click
  const imageContainer = document.querySelector('.edit-image-container');
  if (imageContainer) {
    imageContainer.style.cursor = 'pointer';
    imageContainer.onclick = () => document.getElementById('screenshotUpload').click();
  }
  
  // Restore comment input area
  const commentInput = document.querySelector('.edit-comment-input-area');
  if (commentInput && !commentInput.querySelector('.edit-comment-input-row')) {
    commentInput.innerHTML = `
      <div class="edit-comment-input-row">
        <input type="text" class="edit-comment-input" id="newCommentInput" placeholder="Join the conversation..." onkeypress="if(event.key==='Enter'){addCommentFromInput();event.preventDefault()}">
        <button class="edit-comment-submit" onclick="addCommentFromInput()">Post</button>
      </div>
    `;
  }
  
  // Save changes if it was an editable card
  const card = cards.find(c => c.id === currentCardId);
  if (card && !card.isViewOnly) {
    updateCard();
  }
  
  currentCardId = null;
}

function updateCard() {
  if (!currentCardId) return;
  const card = cards.find(c => c.id === currentCardId);
  if (!card) return;
  card.title = document.getElementById('editTitle').value;
  const locEl = document.getElementById('editLocation');
  if (locEl) card.location = locEl.value;
  card.notes = document.getElementById('editNotes').value;
  card.lastEdited = new Date().toISOString();
  card.editedBy = username;
  saveCards();
  renderGrid();
}

function deleteCard() {
  const card = cards.find(c => c.id === currentCardId);
  
  // Prevent deleting guide cards
  if (card?.isGuide || (card?.url?.startsWith('thought://') && card?.url?.includes('-guide'))) {
    showToast('Guide cards cannot be deleted', 'error');
    return;
  }
  
  // Check ownership for cloud cards
  if (card?.cloudUserId && currentUser && card.cloudUserId !== currentUser.id) {
    showToast('You can only delete your own cards', 'error');
    return;
  }
  
  if (!confirm('Delete this link?')) return;
  
  // Delete images from cloud storage
  if (card?.screenshot?.includes('supabase.co/storage')) {
    deleteImageFromStorage(card.screenshot);
  }
  if (card?.photos?.length) {
    card.photos.forEach(photo => {
      if (photo.includes('supabase.co/storage')) {
        deleteImageFromStorage(photo);
      }
    });
  }
  
  // Delete from cloud
  deleteCardFromCloud(currentCardId);
  
  // Delete locally
  cards = cards.filter(c => c.id !== currentCardId);
  collections.forEach(col => {
    if (col.cardIds) col.cardIds = col.cardIds.filter(id => id !== currentCardId);
  });
  
  saveCards();
  saveCollections();
  renderGrid();
  closeEditModal();
  showToast('Deleted', 'success');
}


// ============== TAGS ==============
function renderTags() {
  const card = cards.find(c => c.id === currentCardId);
  const container = document.getElementById('tagsContainer');
  if (!card || !container) return;
  container.innerHTML = card.tags.map(tag => `
    <span class="tag" onclick="removeTag('${sanitizeHTML(tag)}')" title="Click to remove">${sanitizeHTML(tag)} </span>
  `).join('');
}

function addTag() {
  const input = document.getElementById('newTag');
  const tag = input.value.trim();
  if (!tag) return;
  const card = cards.find(c => c.id === currentCardId);
  if (!card || card.tags.includes(tag)) { input.value = ''; return; }
  card.tags.push(tag);
  input.value = '';
  renderTags();
  saveCards();
}

function removeTag(tag) {
  const card = cards.find(c => c.id === currentCardId);
  if (!card) return;
  card.tags = card.tags.filter(t => t !== tag);
  renderTags();
  saveCards();
}

// New Edit Modal Section Toggle
function toggleEditSection(section) {
  const sectionMap = {
    'notes': 'editNotesSection',
    'photos': 'editPhotosSection',
    'location': 'editLocationSection'
  };
  
  const contentId = sectionMap[section];
  if (!contentId) return;
  
  const content = document.getElementById(contentId);
  const header = content.previousElementSibling;
  
  header.classList.toggle('collapsed');
  content.classList.toggle('collapsed');
}

// Render tags in new format
function renderEditTags() {
  const card = cards.find(c => c.id === currentCardId);
  const container = document.getElementById('tagsContainer');
  if (!card || !container) return;
  
  const isGuideCard = card.isGuide || (card.url?.startsWith('thought://') && card.url?.includes('-guide'));
  
  container.innerHTML = card.tags.map(tag => `
    <span class="tag" ${!isGuideCard ? `onclick="removeTag('${tag}')" title="Click to remove"` : ''}>
      ${tag}
    </span>
  `).join('');
  
  // Hide tag input for guide cards
  const tagInput = document.getElementById('newTag');
  if (tagInput) {
    tagInput.style.display = isGuideCard ? 'none' : 'block';
  }
}

// Render photos in new grid format
function renderEditPhotos() {
  const card = cards.find(c => c.id === currentCardId);
  const grid = document.getElementById('editPhotoGrid');
  const countEl = document.getElementById('editPhotoCount');
  
  if (!card || !grid) return;
  
  const photoCount = card.photos?.length || 0;
  countEl.textContent = photoCount > 0 ? `(${photoCount})` : '';
  
  let html = '';
  if (card.photos?.length) {
    html = card.photos.map((photo, i) => `
      <div class="edit-photo-item">
        <img src="${photo}" alt="Photo ${i+1}">
        <button class="edit-photo-delete" onclick="deletePhoto(${i})"></button>
      </div>
    `).join('');
  }
  html += `<div class="edit-photo-add" onclick="document.getElementById('addPhoto').click()">+</div>`;
  grid.innerHTML = html;
}


// Render comments in new format
function renderEditComments() {
  const card = cards.find(c => c.id === currentCardId);
  const list = document.getElementById('editCommentsList');
  const countEl = document.getElementById('editCommentsCount');
  
  if (!card || !list) return;
  
  const commentCount = card.comments?.length || 0;
  countEl.textContent = commentCount;
  
  if (!commentCount) {
    list.innerHTML = `
      <div class="edit-comments-empty">
        <div class="edit-comments-empty-icon"></div>
        <p>No comments yet</p>
        <p style="font-size: 0.75rem; margin-top: 0.25rem; opacity: 0.7;">Be the first to start the conversation!</p>
      </div>
    `;
    return;
  }
  
  list.innerHTML = card.comments.map(c => {
    const initial = (c.author || 'A').charAt(0).toUpperCase();
    return `
      <div class="edit-comment">
        <div class="edit-comment-header">
          <div class="edit-comment-author">
            <div class="edit-comment-avatar">${initial}</div>
            <span class="edit-comment-name">${sanitizeHTML(c.author)}</span>
          </div>
          <div class="edit-comment-meta">
            <span class="edit-comment-time">${getRelativeTime(c.timestamp)}</span>
            <button class="edit-comment-delete" onclick="deleteComment(${c.id})" title="Delete"></button>
          </div>
        </div>
        <div class="edit-comment-text">${sanitizeHTML(c.text)}</div>
      </div>
    `;
  }).join('');
}

// Add comment from input field
async function addCommentFromInput() {
  const input = document.getElementById('newCommentInput');
  const text = input.value.trim();
  if (!text) return;
  
  const card = cards.find(c => c.id === currentCardId);
  if (!card) return;
  
  if (!card.comments) card.comments = [];
  
  // Add locally first
  const localComment = { 
    id: Date.now(), 
    text, 
    author: username, 
    timestamp: new Date().toISOString(),
    isOwn: true
  };
  
  card.comments.push(localComment);
  input.value = '';
  saveCards();
  renderEditComments();
  
  // Sync to cloud
  const cloudComment = await addCommentToCloud(card.id, text);
  if (cloudComment) {
    // Update local comment with cloud ID
    localComment.id = cloudComment.id;
    saveCards();
  }
  
  showToast('Comment added', 'success');
}

// Relative time helper
function getRelativeTime(timestamp) {
  const diff = Date.now() - new Date(timestamp).getTime();
  const mins = Math.floor(diff / 60000);
  if (mins < 1) return 'now';
  if (mins < 60) return `${mins}m`;
  const hours = Math.floor(mins / 60);
  if (hours < 24) return `${hours}h`;
  const days = Math.floor(hours / 24);
  if (days < 7) return `${days}d`;
  return new Date(timestamp).toLocaleDateString();
}

// ============== PHOTOS ==============
async function addPhotos(event) {
  const files = Array.from(event.target.files);
  const card = cards.find(c => c.id === currentCardId);
  if (!card) return;
  if (!card.photos) card.photos = [];
  
  showToast(` Uploading ${files.length} photo(s)...`, 'default');
  
  let uploadedCount = 0;
  let localCount = 0;
  
  for (const file of files) {
    const base64 = await new Promise(resolve => {
      const reader = new FileReader();
      reader.onload = e => resolve(e.target.result);
      reader.readAsDataURL(file);
    });
    
    // Compress
    const compressed = await compressImage(base64, 1200, 0.8);
    
    // Try cloud upload
    let photoUrl = null;
    if (supabaseClient && currentUser) {
      photoUrl = await uploadImageToStorage(compressed, card.id, `photo_${Date.now()}`);
    }
    
    if (photoUrl) {
      card.photos.push(photoUrl);
      uploadedCount++;
    } else {
      card.photos.push(compressed);
      localCount++;
    }
  }
  
  saveCards();
  renderEditPhotos();
  renderGrid();
  
  if (uploadedCount > 0 && localCount === 0) {
    showToast(` ${uploadedCount} photo(s) uploaded!`, 'success');
  } else if (localCount > 0) {
    showToast(` ${uploadedCount} uploaded, ${localCount} saved locally`, 'default');
  }
  
  event.target.value = '';
}

function deletePhoto(index) {
  const card = cards.find(c => c.id === currentCardId);
  if (!card?.photos) return;
  if (confirm('Delete this photo?')) {
    card.photos.splice(index, 1);
    saveCards();
    renderPhotoGallery();
    renderGrid();
  }
}

function renderPhotoGallery() {
  const card = cards.find(c => c.id === currentCardId);
  const gallery = document.getElementById('photoGallery');
  if (!gallery) return;
  if (!card?.photos?.length) {
    gallery.innerHTML = '<p style="color:var(--text-3);font-size:0.8rem;text-align:center;padding:1rem;">No photos yet</p>';
    return;
  }
  gallery.innerHTML = card.photos.map((photo, i) => `
    <div class="gallery-item">
      <img src="${photo}" alt="Photo ${i+1}">
      <button class="gallery-item-delete" onclick="deletePhoto(${i})"></button>
    </div>
  `).join('');
}

// ============== COMMENTS ==============
function addComment() {
  const card = cards.find(c => c.id === currentCardId);
  const text = document.getElementById('newComment').value.trim();
  if (!card || !text) return;
  if (!card.comments) card.comments = [];
  card.comments.push({ id: Date.now(), text, author: username, timestamp: new Date().toISOString() });
  document.getElementById('newComment').value = '';
  saveCards();
  renderComments();
}

function deleteComment(commentId) {
  const card = cards.find(c => c.id === currentCardId);
  if (!card?.comments) return;
  
  const comment = card.comments.find(c => c.id === commentId);
  
  // Only allow deleting own comments
  if (comment && !comment.isOwn && currentUser && comment.userId !== currentUser.id) {
    showToast('You can only delete your own comments', 'error');
    return;
  }
  
  if (confirm('Delete comment?')) {
    card.comments = card.comments.filter(c => c.id !== commentId);
    saveCards();
    renderEditComments();
    
    // Sync to cloud
    deleteCommentFromCloud(commentId);
  }
}

function renderComments() {
  const card = cards.find(c => c.id === currentCardId);
  const container = document.getElementById('commentsContainer');
  if (!container) return;
  if (!card?.comments?.length) {
    container.innerHTML = '<p style="color:var(--text-3);font-size:0.8rem;">No comments yet</p>';
    return;
  }
  container.innerHTML = card.comments.map(c => `
    <div class="comment">
      <div class="comment-header">
        <span class="comment-author">${c.author}</span>
        <span class="comment-time">${new Date(c.timestamp).toLocaleString()}</span>
      </div>
      <div class="comment-text">${c.text}</div>
      <button onclick="deleteComment(${c.id})" style="background:transparent;border:none;color:var(--danger);font-size:0.7rem;cursor:pointer;margin-top:0.25rem;">Delete</button>
    </div>
  `).join('');
}

// ============== RENDER GRID ==============
function renderGrid() {
  const grid = document.getElementById('grid');
  updateCollectionFilterDropdown();
  
  let filtered = currentTopic === 'all' ? cards : cards.filter(c => c.topic === currentTopic);
  if (currentCollectionFilter) {
    const col = collections.find(c => c.id === currentCollectionFilter);
    if (col) filtered = filtered.filter(c => col.cardIds?.includes(c.id));
  }
  if (showOnlyStarred) filtered = filtered.filter(c => c.starred);
  if (searchQuery) {
    const q = searchQuery.toLowerCase();
    filtered = filtered.filter(c => 
      c.title.toLowerCase().includes(q) || c.url.toLowerCase().includes(q) ||
      c.notes?.toLowerCase().includes(q) || c.tags?.some(t => t.toLowerCase().includes(q))
    );
  }
  
  filtered = sortCards(filtered);
  
  if (!filtered.length) {
    grid.innerHTML = `<div class="empty-state"><div class="empty-icon">${searchQuery ? '' : showOnlyStarred ? '' : ''}</div><h2>${searchQuery ? 'No results' : showOnlyStarred ? 'No starred links' : 'No links yet'}</h2><p>${searchQuery ? 'Try different terms' : 'Add your first link'}</p><button class="btn btn-primary" onclick="${searchQuery ? "document.getElementById('searchBar').value='';handleSearch()" : 'openAddModal()'}">+ Add Link</button></div>`;
    return;
  }
  
  const topicEmojis = {tech:'',news:'',food:'',travel:'',entertainment:'',other:''};
  
  grid.innerHTML = filtered.map(card => {
    const emoji = topicEmojis[card.topic] || '';
    const v = card.votes || 0;
    const compact = compactCards.has(card.id);
    
    return `
      <div class="card ${compact ? 'compact' : ''}" onclick="${bulkSelectMode ? `toggleCardSelection(${card.id},event)` : `openEditModal(${card.id})`}">
        ${bulkSelectMode ? `<input type="checkbox" ${selectedCards.has(card.id)?'checked':''} onclick="toggleCardSelection(${card.id},event)" style="position:absolute;top:0.75rem;left:0.75rem;width:20px;height:20px;z-index:10">` : ''}
        ${!compact ? `<button class="card-star ${card.starred?'active':''}" onclick="event.stopPropagation();toggleStar(${card.id})">${card.starred?'':''}</button>` : ''}
        <div class="card-image">
          <img src="${getCardThumbnail(card)}" alt="${sanitizeHTML(card.title)}" loading="lazy" onerror="handleThumbnailError(this, ${card.id})">
          <div class="card-badges">
            <span class="badge">${emoji}</span>
            ${v ? `<span class="badge badge-vote ${v<0?'negative':''}">${v>0?'+':''}${v}</span>` : ''}
			${card.isPrivate ? `<span class="badge" style="background:rgba(99,102,241,0.9)"></span>` : ''}${card.isPrivate ? `<span class="badge" style="background:rgba(99,102,241,0.9)"></span>` : ''}
   ${card.cloudSynced ? `<span class="badge" style="background:rgba(6,182,212,0.9)"></span>` : ''}
		  </div>
        </div>
        <div class="card-content">
          <h3 class="card-title">${sanitizeHTML(card.title)}</h3>
          <p class="card-url">${sanitizeHTML(card.url)}</p>
          ${card.location ? `<div class="card-location"> ${sanitizeHTML(card.location)}</div>` : ''}
          ${card.notes ? `<p class="card-notes">${sanitizeHTML(card.notes)}</p>` : ''}
          ${card.tags?.length ? `<div class="card-tags">${card.tags.map(t=>`<span class="tag">${sanitizeHTML(t)}</span>`).join('')}</div>` : ''}
          <div class="card-meta"><span> ${showContributors ? sanitizeHTML(card.addedBy||'Anonymous') : 'Anonymous'}</span></div>
        </div>
        <div class="card-footer" ${compact ? 'style="padding:0.5rem"' : ''}>
          <button class="btn btn-ghost" onclick="event.stopPropagation();toggleCard(${card.id})">${compact ? '' : ''}</button>
          ${!compact ? `<button class="btn btn-ghost" onclick="event.stopPropagation();openAddToCollection(${card.id})"></button>
          <button class="btn btn-ghost" onclick="event.stopPropagation();showQuickActions(${card.id})"></button>` : ''}
        </div>
      </div>
    `;
  }).join('');
  
  document.getElementById('link-count').textContent = cards.length;
  const contribs = new Set(cards.map(c=>c.addedBy).filter(Boolean));
  document.getElementById('contributor-count').textContent = showContributors ? contribs.size : '?';
}

function sortCards(arr) {
  const sorted = [...arr];
  if (sortMode === 'votes') sorted.sort((a,b) => (b.votes||0) - (a.votes||0));
  else if (sortMode === 'title') sorted.sort((a,b) => a.title.localeCompare(b.title));
  else sorted.sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt));
  return sorted;
}

// ============== VOTING ==============
function vote(cardId, value) {
  const c = cards.find(x => x.id === cardId);
  if (!c) return;
  if (!c.votes) c.votes = 0;
  
  const prev = userVotes[cardId] || 0;
  
  if (prev === value) {
    // Toggle off
    c.votes -= value;
    userVotes[cardId] = 0;
    voteOnCloud(cardId, 0); // Sync to cloud
  } else {
    // Change vote
    c.votes -= prev;
    c.votes += value;
    userVotes[cardId] = value;
    voteOnCloud(cardId, value); // Sync to cloud
  }
  
  saveCards();
  localStorage.setItem('linkgrid-votes', JSON.stringify(userVotes));
  updateVoteDisplay(cardId);
  renderGrid();
}

function updateVoteDisplay(cardId) {
  const c = cards.find(x => x.id === cardId);
  if (!c) return;
  
  const score = document.getElementById('voteScore');
  const up = document.getElementById('upvoteBtn');
  const down = document.getElementById('downvoteBtn');
  
  if (score) {
    score.textContent = c.votes || 0;
    score.className = 'edit-vote-score';
    if (c.votes > 0) score.classList.add('positive');
    else if (c.votes < 0) score.classList.add('negative');
  }
  
  const uv = userVotes[cardId] || 0;
  if (up) {
    up.className = 'edit-vote-btn';
    if (uv === 1) up.classList.add('upvoted');
  }
  if (down) {
    down.className = 'edit-vote-btn';
    if (uv === -1) down.classList.add('downvoted');
  }
}

// ============== STARS & FILTERS ==============
function toggleStar(id) {
  const c = cards.find(x => x.id === id);
  if (c) { c.starred = !c.starred; saveCards(); renderGrid(); }
}

function toggleStarred() {
  showOnlyStarred = !showOnlyStarred;
  document.getElementById('starFilterBtn').textContent = showOnlyStarred ? ' All' : ' Starred';
  renderGrid();
}

function handleSearch() {
  searchQuery = document.getElementById('searchBar').value.toLowerCase();
  renderGrid();
}

function switchTopic(topic, el) {
  currentTopic = topic;
  document.querySelectorAll('#topicChips .chip').forEach(c => c.classList.remove('active'));
  el?.classList.add('active');
  renderGrid();
}

function setSortMode(mode, el) {
  sortMode = mode;
  document.querySelectorAll('.sort-tab').forEach(t => t.classList.remove('active'));
  el?.classList.add('active');
  renderGrid();
}

function toggleHeaderCollapse() {
  headerCollapsed = !headerCollapsed;
  const el = document.getElementById('headerExpand');
  if (headerCollapsed) { el.classList.add('collapsed'); document.getElementById('collapseIcon').textContent = ''; document.getElementById('collapseText').textContent = 'Show filters'; }
  else { el.classList.remove('collapsed'); document.getElementById('collapseIcon').textContent = ''; document.getElementById('collapseText').textContent = 'Hide filters'; }
  localStorage.setItem('linkgrid-header-collapsed', headerCollapsed);
}

function toggleSection(name) {
  const content = document.getElementById(name + 'Content');
  const toggle = document.getElementById(name + 'Toggle');
  if (content && toggle) { content.classList.toggle('collapsed'); toggle.classList.toggle('collapsed'); }
}

function toggleCard(id) {
  if (compactCards.has(id)) compactCards.delete(id);
  else compactCards.add(id);
  localStorage.setItem('linkgrid-compact-cards', JSON.stringify([...compactCards]));
  renderGrid();
}

// ============== COLLECTIONS ==============
function updateCollectionFilterDropdown() {
  const sel = document.getElementById('collectionFilter');
  if (!sel) return;
  sel.innerHTML = '<option value="">All Collections</option>' + 
    collections.map(c => `<option value="${c.id}">${c.emoji||''} ${c.name} (${c.cardIds?.length||0})</option>`).join('');
}

function filterByCollection() {
  currentCollectionFilter = document.getElementById('collectionFilter').value;
  renderGrid();
}

function renderCollectionsList() {
  const el = document.getElementById('collectionsList');
  if (!collections.length) { el.innerHTML = '<p style="color:var(--text-3);text-align:center;padding:2rem">No collections yet</p>'; return; }
  el.innerHTML = collections.map(c => `
    <div style="background:var(--bg-elevated);padding:1rem;border-radius:var(--radius-md);margin-bottom:0.75rem;border-left:4px solid ${c.color||'var(--accent)'}">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:0.5rem">
        <strong>${c.emoji||''} ${sanitizeHTML(c.name)}</strong>
        <button onclick="deleteCollection('${c.id}')" style="background:transparent;border:none;color:var(--danger);cursor:pointer"></button>
      </div>
      <div style="font-size:0.8rem;color:var(--text-2)">${c.cardIds?.length||0} links</div>
    </div>
  `).join('');
}

function createNewCollection() {
  const name = prompt('Collection name:');
  if (!name?.trim()) return;
  const emoji = prompt('Emoji (optional):', '') || '';
  collections.push({ id: 'col_'+Date.now(), name: name.trim(), emoji, color: '#6366f1', cardIds: [], createdAt: new Date().toISOString(), createdBy: username });
  saveCollections();
  renderCollectionsList();
  updateCollectionFilterDropdown();
  showToast('Collection created!', 'success');
}

function deleteCollection(id) {
  if (!confirm('Delete this collection?')) return;
  collections = collections.filter(c => c.id !== id);
  saveCollections();
  renderCollectionsList();
  updateCollectionFilterDropdown();
}

function openAddToCollection(cardId) {
  currentCardForCollection = cardId;
  const card = cards.find(c => c.id === cardId);
  if (!card) return;
  document.getElementById('addToCollectionCardTitle').textContent = card.title;
  document.getElementById('addToCollectionCardUrl').textContent = card.url;
  document.getElementById('addToCollectionModal').classList.add('active');
  renderCollectionsCheckboxes();
}

function closeAddToCollection() { document.getElementById('addToCollectionModal').classList.remove('active'); currentCardForCollection = null; }

function renderCollectionsCheckboxes() {
  const el = document.getElementById('collectionsCheckboxList');
  if (!collections.length) { el.innerHTML = '<p style="color:var(--text-3);text-align:center">No collections</p>'; return; }
  el.innerHTML = collections.map(c => {
    const checked = c.cardIds?.includes(currentCardForCollection);
    return `<label style="display:flex;align-items:center;gap:0.75rem;padding:0.75rem;background:var(--bg-elevated);border-radius:var(--radius-md);cursor:pointer;border:2px solid ${checked?'var(--success)':'var(--border-subtle)'}">
      <input type="checkbox" value="${c.id}" ${checked?'checked':''} style="width:18px;height:18px;accent-color:var(--success)">
      <span>${c.emoji||''} ${c.name}</span>
    </label>`;
  }).join('');
}

function saveToCollections() {
  if (!currentCardForCollection) return;
  document.querySelectorAll('#collectionsCheckboxList input').forEach(cb => {
    const col = collections.find(c => c.id === cb.value);
    if (!col) return;
    if (!col.cardIds) col.cardIds = [];
    if (cb.checked && !col.cardIds.includes(currentCardForCollection)) col.cardIds.push(currentCardForCollection);
    else if (!cb.checked) col.cardIds = col.cardIds.filter(id => id !== currentCardForCollection);
  });
  saveCollections();
  closeAddToCollection();
  showToast('Saved!', 'success');
}

function createCollectionFromModal() { createNewCollection(); setTimeout(renderCollectionsCheckboxes, 100); }

// ============== QUICK ACTIONS ==============
function showQuickActions(cardId) {
  currentQuickActionCardId = cardId;
  const card = cards.find(c => c.id === cardId);
  if (!card) return;
  document.getElementById('quickActionsCardTitle').textContent = card.title;
  document.getElementById('quickActionStarText').textContent = card.starred ? ' Unstar' : ' Star';
  document.getElementById('quickActionsModal').classList.add('active');
}

function closeQuickActions() { document.getElementById('quickActionsModal').classList.remove('active'); currentQuickActionCardId = null; }
function quickActionAddToCollection() { const id = currentQuickActionCardId; closeQuickActions(); openAddToCollection(id); }
function quickActionStar() { toggleStar(currentQuickActionCardId); closeQuickActions(); }
function quickActionCopyLink() { const c = cards.find(x => x.id === currentQuickActionCardId); if (c) navigator.clipboard?.writeText(c.url); showToast('Copied!', 'success'); closeQuickActions(); }
function quickActionEdit() { const id = currentQuickActionCardId; closeQuickActions(); openEditModal(id); }
function quickActionDelete() { if (confirm('Delete this link?')) { cards = cards.filter(c => c.id !== currentQuickActionCardId); saveCards(); renderGrid(); } closeQuickActions(); }

// ============== BULK MODE ==============
function toggleBulkMode() {
  bulkSelectMode = !bulkSelectMode;
  selectedCards.clear();
  const btn = document.getElementById('bulkModeBtn');
  const bar = document.getElementById('bulkBar');
  if (bulkSelectMode) { btn.textContent = ' Cancel'; bar.classList.add('active'); }
  else { btn.textContent = ' Select'; bar.classList.remove('active'); }
  renderGrid();
}

function toggleCardSelection(id, e) {
  e?.stopPropagation();
  if (selectedCards.has(id)) selectedCards.delete(id);
  else selectedCards.add(id);
  document.getElementById('bulkCount').textContent = selectedCards.size;
  renderGrid();
}

function bulkAddToCollection() {
  if (!selectedCards.size) { showToast('No cards selected', 'error'); return; }
  if (!collections.length) { showToast('Create a collection first', 'error'); return; }
  const choice = prompt('Add to which collection?\n\n' + collections.map((c,i) => `${i+1}. ${c.emoji} ${c.name}`).join('\n') + '\n\nEnter number:');
  if (!choice) return;
  const idx = parseInt(choice) - 1;
  if (idx < 0 || idx >= collections.length) { showToast('Invalid selection', 'error'); return; }
  const col = collections[idx];
  if (!col.cardIds) col.cardIds = [];
  let added = 0;
  selectedCards.forEach(id => { if (!col.cardIds.includes(id)) { col.cardIds.push(id); added++; } });
  saveCollections();
  showToast(`Added ${added} to "${col.name}"`, 'success');
  toggleBulkMode();
}

function bulkDelete() {
  if (!selectedCards.size) { showToast('No cards selected', 'error'); return; }
  if (!confirm(`Delete ${selectedCards.size} cards?`)) return;
  cards = cards.filter(c => !selectedCards.has(c.id));
  collections.forEach(col => { if (col.cardIds) col.cardIds = col.cardIds.filter(id => !selectedCards.has(id)); });
  saveCards();
  saveCollections();
  showToast(`Deleted ${selectedCards.size} cards`, 'success');
  toggleBulkMode();
}

// ============== SHARING ==============
async function shareLink() {
  const c = cards.find(x => x.id === currentCardId);
  if (!c) return;
  const text = `${c.title}\n${c.url}${c.location ? '\n ' + c.location : ''}${c.notes ? '\n\n' + c.notes : ''}`;
  if (navigator.share) {
    try { await navigator.share({ title: c.title, text, url: c.url }); showToast('Shared!', 'success'); return; } catch(e) {}
  }
  navigator.clipboard?.writeText(text);
  showToast('Copied to clipboard!', 'success');
}

function shareToX() { const c = cards.find(x => x.id === currentCardId); if (c) window.open(`https://twitter.com/intent/tweet?text=${encodeURIComponent(c.title)}&url=${encodeURIComponent(c.url)}`, '_blank'); }
function shareToReddit() { const c = cards.find(x => x.id === currentCardId); if (c) window.open(`https://reddit.com/submit?title=${encodeURIComponent(c.title)}&url=${encodeURIComponent(c.url)}`, '_blank'); }
function shareToFacebook() { const c = cards.find(x => x.id === currentCardId); if (c) window.open(`https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(c.url)}`, '_blank'); }
function shareToLinkedIn() { const c = cards.find(x => x.id === currentCardId); if (c) window.open(`https://www.linkedin.com/sharing/share-offsite/?url=${encodeURIComponent(c.url)}`, '_blank'); }
function shareToWhatsApp() { const c = cards.find(x => x.id === currentCardId); if (c) window.open(`https://api.whatsapp.com/send?text=${encodeURIComponent(c.title + '\n' + c.url)}`, '_blank'); }
function shareToEmail() { const c = cards.find(x => x.id === currentCardId); if (c) window.location.href = `mailto:?subject=${encodeURIComponent(c.title)}&body=${encodeURIComponent(c.url + '\n\n' + (c.notes || ''))}`; }

// ============== EXPORT/IMPORT ==============
function exportCollection() {
  const data = { cards, collections, exportedBy: username, exportedAt: new Date().toISOString(), version: '2.0' };
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `communecollab-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  showToast(`Exported ${cards.length} links`, 'success');
}

function importCollection(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    try {
      const data = JSON.parse(ev.target.result);
      if (data.cards?.length) {
        const existing = new Set(cards.map(c => c.url));
        const newCards = data.cards.filter(c => !existing.has(c.url));
        cards = [...cards, ...newCards];
        saveCards();
        renderGrid();
        showToast(`Imported ${newCards.length} new links`, 'success');
      }
    } catch(err) { showToast('Invalid file', 'error'); }
  };
  reader.readAsText(file);
  e.target.value = '';
}

function shareCollectionURL(btn, excludePhotos = false) {
  try {
    const data = { cards: excludePhotos ? cards.map(c => ({...c, photos: [], screenshot: c.screenshotReal ? c.screenshot : null})) : cards, sharedBy: username, sharedAt: new Date().toISOString() };
    const encoded = btoa(encodeURIComponent(JSON.stringify(data)));
    const url = window.location.href.split('?')[0] + '?import=' + encoded;
    if (url.length > 8000) { showToast('Too large! Use Export instead.', 'error'); return; }
    navigator.clipboard?.writeText(url);
    showToast('Share link copied!', 'success');
  } catch(err) { showToast('Error creating link', 'error'); }
}

function checkForSharedCard() {
  const params = new URLSearchParams(window.location.search);
  const importData = params.get('import');
  if (importData) {
    try {
      // Limit import data size to prevent DoS
      if (importData.length > 500000) {
        showToast('Import data too large', 'error');
        window.history.replaceState({}, '', window.location.pathname);
        return;
      }
      
      const data = JSON.parse(decodeURIComponent(atob(importData)));
      
      // Validate structure
      if (!data.cards || !Array.isArray(data.cards)) {
        throw new Error('Invalid import format');
      }
      
      // Limit number of cards
      const maxImport = 100;
      const cardsToImport = data.cards.slice(0, maxImport);
      
      if (confirm(`Import ${cardsToImport.length} links from ${sanitizeHTML(data.sharedBy) || 'someone'}?`)) {
        const existing = new Set(cards.map(c => c.url));
        
        // Sanitize each imported card
        const newCards = cardsToImport
          .map(c => sanitizeCardData(c))
          .filter(c => c.url && !existing.has(c.url));
        
        cards = [...cards, ...newCards];
        saveCards();
        renderGrid();
        showToast(`Imported ${newCards.length} links`, 'success');
      }
      
      window.history.replaceState({}, '', window.location.pathname);
    } catch(e) { 
      console.warn('Invalid share link:', e.message);
      window.history.replaceState({}, '', window.location.pathname);
    }
  }
}

function checkForSharedCollection() {
  const hash = window.location.hash;
  if (hash.startsWith('#collection=')) {
    try {
      const encoded = hash.substring(12);
      
      // Limit size
      if (encoded.length > 500000) {
        showToast('Collection data too large', 'error');
        window.location.hash = '';
        return;
      }
      
      const data = JSON.parse(decodeURIComponent(atob(encoded)));
      
      if (!data.cards || !Array.isArray(data.cards)) {
        throw new Error('Invalid collection format');
      }
      
      const maxImport = 100;
      const cardsToImport = data.cards.slice(0, maxImport);
      const collectionName = sanitizeHTML(String(data.collection?.name || 'Imported').substring(0, 100));
      
      if (confirm(`Import collection "${collectionName}" with ${cardsToImport.length} links?`)) {
        const existing = new Set(cards.map(c => c.url));
        
        const newCards = cardsToImport
          .map(c => sanitizeCardData(c))
          .filter(c => c.url && !existing.has(c.url));
        
        cards = [...cards, ...newCards];
        
        if (data.collection) {
          collections.push({
            id: 'col_' + Date.now(),
            name: collectionName,
            emoji: sanitizeHTML(String(data.collection.emoji || '').substring(0, 4)),
            color: /^#[0-9a-fA-F]{6}$/.test(data.collection.color) ? data.collection.color : '#6366f1',
            cardIds: newCards.map(c => c.id),
            createdAt: new Date().toISOString(),
            isPrivate: false
          });
          saveCollections();
        }
        
        saveCards();
        renderGrid();
        showToast(`Imported ${newCards.length} links`, 'success');
      }
      
      window.location.hash = '';
    } catch(e) {
      console.warn('Invalid collection link:', e.message);
      window.location.hash = '';
    }
  }
}

// ============== SCREENSHOT UPLOAD ==============
function handleUploadZoneClick(e) {
  if (e.target.id === 'removeImageBtn') return;
  document.getElementById('screenshotUpload').click();
}

async function handleScreenshotUpload(e) {
  const file = e.target.files[0];
  if (!file || !file.type.startsWith('image/')) return;
  
  const reader = new FileReader();
  reader.onload = async (ev) => {
    const card = cards.find(c => c.id === currentCardId);
    if (!card) return;
    
    // Show loading state
    const detailImage = document.getElementById('detailImage');
    detailImage.style.opacity = '0.5';
    showToast(' Uploading image...', 'default');
    
    // Compress the image
    const compressed = await compressImage(ev.target.result, 800, 0.8);
    
    // Try to upload to cloud storage
    let imageUrl = null;
    if (supabaseClient && currentUser) {
      imageUrl = await uploadImageToStorage(compressed, card.id, 'screenshot');
    }
    
    if (imageUrl) {
      // Success - use cloud URL
      card.screenshot = imageUrl;
      card.screenshotReal = true;
      card.customScreenshot = true;
      console.log(' Screenshot uploaded to cloud:', imageUrl);
    } else {
      // Fallback - store locally
      card.screenshot = compressed;
      card.screenshotReal = true;
      card.customScreenshot = true;
      console.log(' Screenshot saved locally (not synced)');
    }
    
    // Update UI
    detailImage.src = card.screenshot;
    detailImage.style.opacity = '1';
    detailImage.style.display = 'block';
    
    saveCards();
    renderGrid();
    
    if (imageUrl) {
      showToast(' Screenshot uploaded!', 'success');
    } else {
      showToast(' Screenshot saved locally', 'default');
    }
  };
  reader.readAsDataURL(file);
  e.target.value = '';
}

function removeUploadedImage(e) {
  e.stopPropagation();
  const card = cards.find(c => c.id === currentCardId);
  if (!card || !confirm('Remove screenshot?')) return;
  card.customScreenshot = false;
  document.getElementById('removeImageBtn').style.display = 'none';
  saveCards();
  renderGrid();
  showToast('Screenshot removed', 'success');
}

// ============== LOCATION ==============
function getMyLocation() {
  if (!navigator.geolocation) { showToast('Location not supported', 'error'); return; }
  navigator.geolocation.getCurrentPosition(
    async (pos) => {
      try {
        const res = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${pos.coords.latitude}&lon=${pos.coords.longitude}`);
        const data = await res.json();
        const loc = data.address ? [data.address.road, data.address.city || data.address.town, data.address.state].filter(Boolean).join(', ') : `${pos.coords.latitude.toFixed(4)}, ${pos.coords.longitude.toFixed(4)}`;
        document.getElementById('editLocation').value = loc;
        showToast('Location added', 'success');
      } catch(e) { document.getElementById('editLocation').value = `${pos.coords.latitude.toFixed(4)}, ${pos.coords.longitude.toFixed(4)}`; }
    },
    (err) => { showToast('Could not get location', 'error'); }
  );
}

// ============== MEDIA CARDS ==============
selectedNewMediaFiles = [];

function handleNewMediaUpload(e) {
  selectedNewMediaFiles = Array.from(e.target.files);
  if (!selectedNewMediaFiles.length) return;
  const titleEl = document.getElementById('newMediaTitle');
  if (titleEl && !titleEl.value) titleEl.value = selectedNewMediaFiles[0].name.replace(/\.[^/.]+$/, '');
  document.getElementById('newMediaPreviewArea').style.display = 'block';
  document.getElementById('newMediaPreviewList').innerHTML = selectedNewMediaFiles.map((f, i) => `
    <div style="display:flex;align-items:center;gap:0.75rem;padding:0.75rem;background:var(--bg-elevated);border-radius:var(--radius-md)">
      <span style="font-size:1.5rem">${f.type.startsWith('image/')?'':f.type.includes('pdf')?'':''}</span>
      <div style="flex:1;min-width:0"><div style="font-weight:500;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${f.name}</div><div style="font-size:0.75rem;color:var(--text-3)">${(f.size/1024).toFixed(1)} KB</div></div>
      <button onclick="removeNewMediaFile(${i})" style="background:transparent;border:none;color:var(--danger);cursor:pointer;font-size:1.2rem"></button>
    </div>
  `).join('');
  const btn = document.getElementById('createMediaCardBtn');
  if (btn) { btn.disabled = false; btn.style.opacity = '1'; btn.style.cursor = 'pointer'; }
}

function removeNewMediaFile(i) {
  selectedNewMediaFiles.splice(i, 1);
  if (!selectedNewMediaFiles.length) {
    document.getElementById('newMediaPreviewArea').style.display = 'none';
    const btn = document.getElementById('createMediaCardBtn');
    if (btn) { btn.disabled = true; btn.style.opacity = '0.5'; btn.style.cursor = 'not-allowed'; }
  } else { handleNewMediaUpload({ target: { files: selectedNewMediaFiles } }); }
}

async function createMediaCard() {
  if (!selectedNewMediaFiles.length) return;
  const title = document.getElementById('newMediaTitle').value.trim() || selectedNewMediaFiles[0].name;
  const topic = document.getElementById('newMediaTopic')?.value || 'other';
  const photos = await Promise.all(selectedNewMediaFiles.filter(f => f.type.startsWith('image/')).map(f => new Promise(res => { const r = new FileReader(); r.onload = e => res(e.target.result); r.readAsDataURL(f); })));
  const newCard = { id: Date.now(), url: `media://${selectedNewMediaFiles[0].name}`, title, topic, screenshot: photos[0] || null, screenshotReal: false, notes: '', tags: [], votes: 0, photos, comments: [], starred: false, metadata: { isMediaCard: true }, addedBy: username, createdAt: new Date().toISOString(), lastEdited: new Date().toISOString(), editedBy: username };
  cards.unshift(newCard);
  saveCards();
  renderGrid();
  closeAddModal();
  showToast('Media card created!', 'success');
}

// ============== THOUGHT CARDS ==============
function updateThoughtPreview() {
  const title = document.getElementById('thoughtTitle')?.value.trim() || '';
  const content = document.getElementById('thoughtContent')?.value || '';
  document.getElementById('thoughtCharCount').textContent = `${content.length} chars`;
  document.getElementById('thoughtLineCount').textContent = `${content.split('\n').length} lines`;
  document.getElementById('previewTitle').textContent = title || 'Untitled';
  document.getElementById('previewContent').textContent = content || 'Your thought will appear here...';
  const btn = document.getElementById('createThoughtBtn');
  if (btn) { btn.disabled = !content.trim(); btn.style.opacity = content.trim() ? '1' : '0.5'; btn.style.cursor = content.trim() ? 'pointer' : 'not-allowed'; }
}

function generateThoughtImage(title, content) {
  const canvas = document.createElement('canvas');
  canvas.width = 800; canvas.height = 500;
  const ctx = canvas.getContext('2d');
  const hour = new Date().getHours();
  let g1, g2;
  if (hour >= 5 && hour < 8) { g1 = '#FFB88C'; g2 = '#DE6262'; }
  else if (hour >= 8 && hour < 12) { g1 = '#56CCF2'; g2 = '#2F80ED'; }
  else if (hour >= 12 && hour < 17) { g1 = '#4A90E2'; g2 = '#7B68EE'; }
  else if (hour >= 17 && hour < 20) { g1 = '#FF6B6B'; g2 = '#764BA2'; }
  else if (hour >= 20 && hour < 22) { g1 = '#667EEA'; g2 = '#4A148C'; }
  else { g1 = '#1e3c72'; g2 = '#2a5298'; }
  const grad = ctx.createLinearGradient(0, 0, 800, 500);
  grad.addColorStop(0, g1); grad.addColorStop(1, g2);
  ctx.fillStyle = grad; ctx.fillRect(0, 0, 800, 500);
  if (hour >= 20 || hour < 6) { ctx.fillStyle = 'rgba(255,255,255,0.8)'; for (let i = 0; i < 80; i++) { ctx.beginPath(); ctx.arc(Math.random()*800, Math.random()*300, Math.random()*2, 0, Math.PI*2); ctx.fill(); } }
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  [{ x: 0, w: 80, h: 180 }, { x: 90, w: 60, h: 240 }, { x: 160, w: 100, h: 140 }, { x: 270, w: 70, h: 210 }, { x: 350, w: 90, h: 160 }, { x: 450, w: 80, h: 270 }, { x: 540, w: 60, h: 190 }, { x: 610, w: 110, h: 150 }, { x: 730, w: 70, h: 220 }].forEach(b => ctx.fillRect(b.x, 500 - b.h, b.w, b.h));
  ctx.fillStyle = 'white'; ctx.font = 'bold 32px Inter, system-ui'; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 8;
  ctx.fillText(title.substring(0, 30), 40, 80);
  ctx.font = '20px Inter, system-ui'; ctx.fillStyle = 'rgba(255,255,255,0.95)';
  let y = 140;
  content.split('\n').slice(0, 10).forEach(line => {
    const words = line.split(' '); let currentLine = '';
    words.forEach(word => {
      const test = currentLine + word + ' ';
      if (ctx.measureText(test).width > 720 && currentLine) { ctx.fillText(currentLine, 40, y); y += 30; currentLine = word + ' '; }
      else currentLine = test;
    });
    if (currentLine && y <= 380) { ctx.fillText(currentLine, 40, y); y += 30; }
  });
  return canvas.toDataURL('image/png');
}

async function createThoughtCard() {
  const title = document.getElementById('thoughtTitle')?.value.trim() || 'Thought';
  const content = document.getElementById('thoughtContent')?.value.trim();
  const topic = document.getElementById('thoughtTopic')?.value || 'other';
  if (!content) return;
  const img = generateThoughtImage(title, content);
  const newCard = { id: Date.now(), url: `thought://${Date.now()}`, title, topic, screenshot: img, screenshotReal: false, notes: content, tags: ['thought'], votes: 0, photos: [img], comments: [], starred: false, metadata: { isThought: true }, addedBy: username, createdAt: new Date().toISOString(), lastEdited: new Date().toISOString(), editedBy: username };
  cards.unshift(newCard);
  saveCards();
  renderGrid();
  closeAddModal();
  showToast('Thought posted!', 'success');
}

// ============== SETTINGS ==============
function openSettings() {
  document.getElementById('settingsModal').classList.add('active');
  document.getElementById('usernameInput').value = username;
  
  // Load privacy toggles
  const showToggle = document.getElementById('showContributorsToggle');
  if (showToggle) showToggle.checked = showContributors;
  
  const profileToggle = document.getElementById('profilePublicToggle');
  if (profileToggle) profileToggle.checked = localStorage.getItem('linkgrid-profile-public') === 'true';
  
  const cardPrivateToggle = document.getElementById('defaultCardPrivateToggle');
  if (cardPrivateToggle) cardPrivateToggle.checked = localStorage.getItem('linkgrid-default-card-private') === 'true';
  
  updateContributorList();
  
  // Show appropriate auth section
  const cloudSection = document.getElementById('cloudSyncSection');
  const signInSection = document.getElementById('settingsSignInSection');
  
  if (currentUser) {
    // User is logged in
    if (cloudSection) {
      cloudSection.style.display = 'block';
      document.getElementById('userEmailDisplay').textContent = currentUser.email;
      
      // Show last sync time
      const lastSyncEl = document.getElementById('lastSyncDisplay');
      if (lastSyncEl && lastSyncTime) {
        lastSyncEl.textContent = `Last sync: ${getRelativeTime(lastSyncTime.toISOString())}`;
      }
    }
    if (signInSection) signInSection.style.display = 'none';
  } else {
    // User is not logged in
    if (cloudSection) cloudSection.style.display = 'none';
    if (signInSection) signInSection.style.display = 'block';
  }
}

function closeSettings() { document.getElementById('settingsModal').classList.remove('active'); }

function saveSettings() {
  const rawName = document.getElementById('usernameInput').value.trim();
  if (rawName) { 
    username = sanitizeUsername(rawName);
    localStorage.setItem('linkgrid-username', username);
  }
  closeSettings();
  showToast('Saved!', 'success');
}

async function updateAllCardsUsername() {
  const newName = document.getElementById('usernameInput').value.trim();
  
  if (!newName) {
    showToast('Enter a display name first', 'error');
    return;
  }
  
  if (newName.length < 2) {
    showToast('Name must be at least 2 characters', 'error');
    return;
  }
  
  if (newName.length > 30) {
    showToast('Name must be 30 characters or less', 'error');
    return;
  }
  
  const sanitizedName = sanitizeUsername(newName);
  
  // Check if it's different from current
  if (sanitizedName.toLowerCase() === username.toLowerCase()) {
    // Same name, just update cards
    updateCardsWithUsername(sanitizedName);
    return;
  }
  
  // Check availability
  showToast(' Checking availability...', 'default');
  const available = await checkUsernameAvailable(sanitizedName);
  
  if (!available) {
    showToast(` "${sanitizedName}" is already taken`, 'error');
    return;
  }
  
  // Confirm the change
  if (supabaseClient && currentUser) {
    const confirmChange = confirm(
      `Change your display name to "${sanitizedName}"?\n\n` +
      `Your new name will sync to all your devices automatically.`
    );
    
    if (!confirmChange) {
      showToast('Cancelled', 'default');
      return;
    }
  }
  
  // Save to cloud first
  const saved = await saveUsernameToCloud(sanitizedName);
  if (!saved && supabaseClient && currentUser) {
    showToast(' Could not save username', 'error');
    return;
  }
  
  // Sign out other sessions (but keep this one)
  if (supabaseClient && currentUser) {
    await signOutOtherSessions();
  }
  
  // Update local
  updateCardsWithUsername(sanitizedName);
}

async function signOutOtherSessions() {
  // NOTE: Supabase doesn't support "sign out others but keep me"
  // Instead, we rely on username sync via the profiles table
  // Other devices will get the new username when they next refresh
  
  console.log(' Username change will sync to other devices automatically');
  
  // We could implement a custom "force refresh" flag in the profiles table
  // that other devices check, but for now just let it sync naturally
  return true;
}

function updateCardsWithUsername(newName) {
  let updatedCount = 0;
  
  cards.forEach(card => {
    // Only update cards that belong to this user
    if (card.addedBy === username || 
        card.addedBy === 'You' || 
        card.addedBy === currentUser?.email?.split('@')[0] ||
        card.cloudUserId === currentUser?.id ||
        card.isOwnCard) {
      card.addedBy = newName;
      card.editedBy = newName;
      updatedCount++;
    }
  });
  
  // Update the global username
  const oldName = username;
  username = newName;
  localStorage.setItem('linkgrid-username', username);
  
  saveCards();
  renderGrid();
  
  showToast(` Updated ${updatedCount} cards to "${newName}"`, 'success');
}


let usernameCheckTimeout = null;

function validateUsernameInput() {
  const input = document.getElementById('usernameInput');
  const status = document.getElementById('usernameStatus');
  const hint = document.getElementById('usernameHint');
  const btn = document.getElementById('updateUsernameBtn');
  const value = input.value.trim();
  
  // Clear previous timeout
  if (usernameCheckTimeout) {
    clearTimeout(usernameCheckTimeout);
  }
  
  // Reset state
  status.textContent = '';
  hint.style.color = 'var(--text-3)';
  if (btn) btn.disabled = false;
  
  if (!value) {
    hint.textContent = 'This is how others see you. Your email is never shown.';
    return;
  }
  
  if (value.length < 2) {
    status.textContent = '';
    hint.textContent = 'Must be at least 2 characters';
    hint.style.color = 'var(--warning)';
    if (btn) btn.disabled = true;
    return;
  }
  
  // Same as current username
  if (value.toLowerCase() === username.toLowerCase()) {
    status.textContent = '';
    hint.textContent = 'This is your current name';
    hint.style.color = 'var(--success)';
    return;
  }
  
  // Show checking status
  status.textContent = '';
  hint.textContent = 'Checking availability...';
  if (btn) btn.disabled = true;
  
  // Debounce the check
  usernameCheckTimeout = setTimeout(async () => {
    const available = await checkUsernameAvailable(value);
    
    // Make sure input hasn't changed
    if (input.value.trim() !== value) return;
    
    if (available) {
      status.textContent = '';
      hint.textContent = `"${value}" is available!`;
      hint.style.color = 'var(--success)';
      if (btn) btn.disabled = false;
    } else {
      status.textContent = '';
      hint.textContent = `"${value}" is already taken`;
      hint.style.color = 'var(--danger)';
      if (btn) btn.disabled = true;
    }
  }, 500);
}

function toggleShowContributors() {
  showContributors = document.getElementById('showContributorsToggle').checked;
  localStorage.setItem('linkgrid-show-contributors', showContributors);
  renderGrid();
}


function updateContributorList() {
  const stats = {};
  cards.forEach(c => { const name = c.addedBy || 'Unknown'; if (!stats[name]) stats[name] = { links: 0, votes: 0 }; stats[name].links++; stats[name].votes += (c.votes || 0); });
  const sorted = Object.entries(stats).sort((a, b) => b[1].links - a[1].links).slice(0, 10);
  const el = document.getElementById('contributorList');
  if (!el) return;
  if (!showContributors) { el.innerHTML = '<div style="opacity:0.6">Privacy mode enabled</div>'; return; }
  if (!sorted.length) { el.innerHTML = '<div style="opacity:0.6">No contributors yet</div>'; return; }
  el.innerHTML = sorted.map(([name, s], i) => `<div style="display:flex;justify-content:space-between;padding:0.5rem 0;${i > 0 ? 'border-top:1px solid var(--border-subtle);' : ''}"><span>#${i + 1} <strong>${sanitizeHTML(name)}</strong></span><span style="opacity:0.7;font-size:0.75rem;">${s.links} links</span></div>`).join('');
}

function openCommunity() { document.getElementById('communityModal').classList.add('active'); updateCommunityData(); }
function closeCommunity() { document.getElementById('communityModal').classList.remove('active'); }
function openCollections() { document.getElementById('collectionsModal').classList.add('active'); renderCollectionsList(); }
function closeCollections() { document.getElementById('collectionsModal').classList.remove('active'); }

function updateCommunityData() {
  const totalVotes = cards.reduce((sum, c) => sum + Math.abs(c.votes || 0), 0);
  const totalComments = cards.reduce((sum, c) => sum + (c.comments?.length || 0), 0);
  const contributors = new Set(cards.map(c => c.addedBy).filter(Boolean));
  const el1 = document.getElementById('statsTotal'); if (el1) el1.textContent = cards.length;
  const el2 = document.getElementById('statsContributors'); if (el2) el2.textContent = showContributors ? contributors.size : '?';
  const el3 = document.getElementById('statsVotes'); if (el3) el3.textContent = totalVotes;
  const el4 = document.getElementById('statsComments'); if (el4) el4.textContent = totalComments;
}


// Privacy settings
let profilePublic = false;
let defaultCardPrivate = false;

function toggleProfilePublic() {
  profilePublic = document.getElementById('profilePublicToggle').checked;
  localStorage.setItem('linkgrid-profile-public', profilePublic);
  showToast(profilePublic ? ' Profile is now public' : ' Profile is now private', 'success');
}

function toggleDefaultCardPrivate() {
  defaultCardPrivate = document.getElementById('defaultCardPrivateToggle').checked;
  localStorage.setItem('linkgrid-default-card-private', defaultCardPrivate);
  showToast(defaultCardPrivate ? ' New cards will be private' : ' New cards will be public', 'success');
}

function toggleCardPrivacy(cardId) {
  const card = cards.find(c => c.id === cardId);
  if (!card) return;
  card.isPrivate = !card.isPrivate;
  saveCards();
  renderGrid();
  showToast(card.isPrivate ? ' Card is now private' : ' Card is now public', 'success');
}

function toggleCollectionPrivacy(collectionId) {
  const col = collections.find(c => c.id === collectionId);
  if (!col) return;
  col.isPrivate = !col.isPrivate;
  saveCollections();
  renderCollectionsList();
  showToast(col.isPrivate ? ' Collection is now private' : ' Collection is now public', 'success');
}

// ============== SUPABASE AUTH ==============
async function initSupabase() {
  if (typeof supabase === 'undefined' || !SUPABASE_URL || !SUPABASE_ANON_KEY) {
    console.log(' Supabase not available');
    return false;
  }
  
  try {
    console.log(' Initializing Supabase...');
    
    // Initialize client
    supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
      auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true
      }
    });
    
    // Check for auth callback in URL (magic link redirect)
    const hashParams = new URLSearchParams(window.location.hash.substring(1));
    const accessToken = hashParams.get('access_token');
    const refreshToken = hashParams.get('refresh_token');
    
    if (accessToken && refreshToken) {
      console.log(' Processing magic link callback...');
      
      const { data, error } = await supabaseClient.auth.setSession({
        access_token: accessToken,
        refresh_token: refreshToken
      });
      
      if (error) {
        console.error(' Auth callback error:', error);
        showToast('Sign in failed: ' + error.message, 'error');
      } else if (data.session) {
        currentUser = data.session.user;
        window.history.replaceState(null, '', window.location.pathname + window.location.search);
        console.log(' Signed in via magic link:', currentUser.email);
        onUserLoggedIn();
        return true;
      }
    }
    
    // Check for error in URL
    const errorCode = hashParams.get('error_code');
    const errorDesc = hashParams.get('error_description');
    if (errorCode) {
      console.error(' Auth error in URL:', errorCode, errorDesc);
      showToast('Sign in failed: ' + (errorDesc?.replace(/\+/g, ' ') || errorCode), 'error');
      window.history.replaceState(null, '', window.location.pathname + window.location.search);
    }
    
    // Try to get existing session with retry logic
    console.log(' Checking for existing session...');
    let session = null;
    
    // Attempt 1: Normal getSession
    try {
      const { data, error } = await supabaseClient.auth.getSession();
      if (!error && data?.session) {
        session = data.session;
        console.log(' Got session via getSession()');
      }
    } catch (e) {
      console.warn(' getSession() failed:', e.message);
    }
    
    // Attempt 2: If getSession failed, try to restore from localStorage manually
    if (!session) {
      console.log(' Attempting manual session restore...');
      const storageKey = `sb-${SUPABASE_URL.split('//')[1].split('.')[0]}-auth-token`;
      const storedData = localStorage.getItem(storageKey);
      
      if (storedData) {
        try {
          const parsed = JSON.parse(storedData);
          console.log(' Found stored session, attempting restore...');
          
          if (parsed.access_token && parsed.refresh_token) {
            // Use setSession to restore
            const { data, error } = await supabaseClient.auth.setSession({
              access_token: parsed.access_token,
              refresh_token: parsed.refresh_token
            });
            
            if (!error && data?.session) {
              session = data.session;
              console.log(' Session restored from localStorage');
            } else if (error) {
              console.warn(' setSession failed:', error.message);
              
              // Token might be expired, try refresh
              console.log(' Attempting token refresh...');
              const { data: refreshData, error: refreshError } = await supabaseClient.auth.refreshSession({
                refresh_token: parsed.refresh_token
              });
              
              if (!refreshError && refreshData?.session) {
                session = refreshData.session;
                console.log(' Session restored via refresh');
              } else {
                console.warn(' Refresh failed:', refreshError?.message);
                // Clear invalid stored data
                localStorage.removeItem(storageKey);
              }
            }
          }
        } catch (parseError) {
          console.warn(' Could not parse stored session:', parseError.message);
        }
      }
    }
    
    // Process the session if we got one
    if (session) {
      currentUser = session.user;
      console.log(' Session active:', currentUser.email);
      onUserLoggedIn(true);
    } else {
      console.log(' No valid session found');
      
      // Only show auth modal on first visit
      const hasSeenAuthPrompt = localStorage.getItem('linkgrid-seen-auth');
      if (!hasSeenAuthPrompt) {
        setTimeout(() => {
          document.getElementById('authModal')?.classList.add('active');
          localStorage.setItem('linkgrid-seen-auth', 'true');
        }, 1000);
      }
    }
    
    // Listen for auth state changes
    supabaseClient.auth.onAuthStateChange((event, session) => {
      console.log(' Auth state changed:', event, session?.user?.email || 'no user');
      
      if (event === 'SIGNED_IN' && session) {
        currentUser = session.user;
        if (!cloudSyncEnabled) {
          onUserLoggedIn(true);
        }
      } else if (event === 'SIGNED_OUT') {
        currentUser = null;
        cloudSyncEnabled = false;
        cleanupRealtimeSubscription();
        console.log(' Signed out');
      } else if (event === 'TOKEN_REFRESHED') {
        console.log(' Token refreshed successfully');
        if (session) {
          currentUser = session.user;
        }
      } else if (event === 'INITIAL_SESSION') {
        console.log(' Initial session event:', session?.user?.email || 'no session');
        if (session && !currentUser) {
          currentUser = session.user;
          onUserLoggedIn(true);
        }
      }
    });
    
    return true;
  } catch (e) {
    console.error(' Supabase init error:', e);
    
    // Even if init fails, try one more manual restore
    try {
      const storageKey = `sb-${SUPABASE_URL.split('//')[1].split('.')[0]}-auth-token`;
      const storedData = localStorage.getItem(storageKey);
      if (storedData) {
        const parsed = JSON.parse(storedData);
        if (parsed.user) {
          currentUser = parsed.user;
          console.log(' Emergency session restore from cache:', currentUser.email);
          // Try to reinitialize cloud sync later
          setTimeout(() => {
            if (supabaseClient && currentUser && !cloudSyncEnabled) {
              initCloudSync();
            }
          }, 2000);
          return true;
        }
      }
    } catch (e2) {
      console.error(' Emergency restore failed:', e2);
    }
    
    return false;
  }
}

async function sendMagicLink() {
  const email = document.getElementById('authEmail').value.trim();
  const status = document.getElementById('authStatus');
  const btn = document.getElementById('sendMagicLinkBtn');
  
  if (!email || !email.includes('@')) { 
    if (status) { 
      status.textContent = ' Enter valid email'; 
      status.style.color = 'var(--danger)'; 
    } 
    return; 
  }
  
  if (btn) { 
    btn.disabled = true; 
    btn.textContent = 'Sending...'; 
  }
  if (status) { 
    status.textContent = ' Sending...'; 
    status.style.color = 'var(--accent)'; 
  }
  
  try {
    // Use current page URL as redirect
    const redirectUrl = window.location.href.split('#')[0].split('?')[0];
    
    const { error } = await supabaseClient.auth.signInWithOtp({ 
      email, 
      options: { 
        emailRedirectTo: redirectUrl
      } 
    });
    
    if (error) throw error;
    
    if (status) { 
      status.textContent = ' Check your email!'; 
      status.style.color = 'var(--success)'; 
    }
    if (btn) {
      btn.textContent = ' Email Sent!';
    }
    document.getElementById('authEmail').value = '';
    
  } catch (e) {
    console.error('Magic link error:', e);
    if (status) { 
      status.textContent = ' ' + e.message; 
      status.style.color = 'var(--danger)'; 
    }
    if (btn) { 
      btn.disabled = false; 
      btn.textContent = ' Send Magic Link'; 
    }
  }
}

async function sendMagicLinkFromSettings() {
  const email = document.getElementById('settingsAuthEmail')?.value.trim();
  const status = document.getElementById('settingsAuthStatus');
  
  if (!email || !email.includes('@')) { 
    if (status) { 
      status.textContent = ' Enter valid email'; 
      status.style.color = 'var(--danger)'; 
    } 
    return; 
  }
  
  if (status) { 
    status.textContent = ' Sending...'; 
    status.style.color = 'var(--accent)'; 
  }
  
  try {
    const redirectUrl = window.location.href.split('#')[0].split('?')[0];
    
    const { error } = await supabaseClient.auth.signInWithOtp({ 
      email, 
      options: { 
        emailRedirectTo: redirectUrl
      } 
    });
    
    if (error) throw error;
    
    if (status) { 
      status.textContent = ' Check your email!'; 
      status.style.color = 'var(--success)'; 
    }
    document.getElementById('settingsAuthEmail').value = '';
    
  } catch (e) { 
    if (status) { 
      status.textContent = ' ' + e.message; 
      status.style.color = 'var(--danger)'; 
    } 
  }
}

function onUserLoggedIn(silent = false) {
  document.getElementById('authModal')?.classList.remove('active');
  
  // Check if this is first login (no custom username set)
  const savedUsername = localStorage.getItem('linkgrid-username');
  const isFirstLogin = !savedUsername || savedUsername === 'You' || savedUsername === currentUser.email.split('@')[0];
  
  if (isFirstLogin && !silent) {
    // Prompt for display name only on explicit login
    setTimeout(() => {
      showUsernameSetupPrompt();
    }, 500);
  } else if (savedUsername) {
    username = savedUsername;
    // Verify username is still ours in cloud
    verifyUsernameOwnership();
  }
  
  if (!silent) {
    showToast(' Signed in!', 'success');
  } else {
    console.log(' Session restored for:', currentUser.email);
  }
  
  // Initialize cloud sync
  initCloudSync();
}


async function showUsernameSetupPrompt() {
  const suggestedName = currentUser.email.split('@')[0];
  let displayName = null;
  let isValid = false;
  
  while (!isValid) {
    displayName = prompt(
      ' Choose your display name\n\nThis is how others will see you. Must be unique.\nYour email will never be shown publicly.',
      displayName || suggestedName
    );
    
    // User cancelled
    if (displayName === null) {
      displayName = suggestedName;
      break;
    }
    
    displayName = displayName.trim();
    
    if (!displayName) {
      alert(' Display name cannot be empty');
      continue;
    }
    
    if (displayName.length < 2) {
      alert(' Display name must be at least 2 characters');
      continue;
    }
    
    if (displayName.length > 30) {
      alert(' Display name must be 30 characters or less');
      continue;
    }
    
    // Check if username is available
    const available = await checkUsernameAvailable(displayName);
    
    if (!available) {
      alert(` "${displayName}" is already taken. Please choose another name.`);
      continue;
    }
    
    isValid = true;
  }
  
  username = sanitizeUsername(displayName);
  localStorage.setItem('linkgrid-username', username);
  
  // Save to cloud
  await saveUsernameToCloud(username);
  
  renderGrid();
  showToast(` Welcome, ${username}!`, 'success');
}

async function checkUsernameAvailable(desiredUsername) {
  if (!supabaseClient || !currentUser) {
    // Offline mode - allow any username
    return true;
  }
  
  try {
    const normalizedName = desiredUsername.toLowerCase().trim();
    
    const { data, error } = await supabaseClient
      .from('profiles')
      .select('id, username')
      .ilike('username', normalizedName)
      .limit(1);
    
    if (error) {
      console.error('Username check error:', error);
      // If table doesn't exist yet, allow the username
      if (error.code === '42P01') return true;
      return true; // Fail open for other errors
    }
    
    // Available if no results, or if the result is our own profile
    if (!data || data.length === 0) return true;
    if (data[0].id === currentUser.id) return true;
    
    return false;
    
  } catch (e) {
    console.error('Username check exception:', e);
    return true; // Fail open
  }
}

async function saveUsernameToCloud(newUsername) {
  if (!supabaseClient || !currentUser) return false;
  
  try {
    const { error } = await supabaseClient
      .from('profiles')
      .upsert({
        id: currentUser.id,
        username: newUsername,
        updated_at: new Date().toISOString()
      }, { onConflict: 'id' });
    
    if (error) {
      console.error('Save username error:', error);
      return false;
    }
    
    console.log(' Username saved to cloud:', newUsername);
    return true;
    
  } catch (e) {
    console.error('Save username exception:', e);
    return false;
  }
}

async function verifyUsernameOwnership() {
  if (!supabaseClient || !currentUser) return;
  
  try {
    const { data, error } = await supabaseClient
      .from('profiles')
      .select('username')
      .eq('id', currentUser.id)
      .single();
    
    if (error && error.code !== 'PGRST116') {
      console.error('Verify username error:', error);
      return;
    }
    
    if (data && data.username) {
      // Cloud username takes precedence
      if (data.username !== username) {
        username = data.username;
        localStorage.setItem('linkgrid-username', username);
        renderGrid();
      }
    } else {
      // No cloud profile yet, save current username
      await saveUsernameToCloud(username);
    }
    
  } catch (e) {
    console.error('Verify username exception:', e);
  }
}

async function signOut() {
  if (!supabaseClient) return;
  
  if (confirm('Sign out? Your local data will be kept.')) {
    cleanupRealtimeSubscription();
    cloudSyncEnabled = false;
    
    await supabaseClient.auth.signOut();
    currentUser = null;
    
    closeSettings();
    showToast('Signed out', 'default');
  }
}
// ============== KEYBOARD SHORTCUTS ==============
document.addEventListener('keydown', (e) => {
  if (e.key === '/' && !['INPUT', 'TEXTAREA'].includes(document.activeElement.tagName)) { e.preventDefault(); document.getElementById('searchBar')?.focus(); }
  if (e.key === 'Escape') { closeAddModal(); closeEditModal(); closeSettings(); closeCommunity(); closeCollections(); closeAddToCollection(); closeQuickActions(); closeDiscover(); document.getElementById('authModal')?.classList.remove('active'); document.getElementById('customConfirmModal')?.classList.remove('active'); }
  if (e.key === 'n' && (e.metaKey || e.ctrlKey)) { e.preventDefault(); openAddModal(); }
});

// Close modals on backdrop click
['addModal', 'editModal', 'settingsModal', 'communityModal', 'collectionsModal', 'addToCollectionModal', 'quickActionsModal', 'customConfirmModal', 'authModal', 'discoverView'].forEach(id => {
  document.getElementById(id)?.addEventListener('click', function(e) { if (e.target === this) this.classList.remove('active'); });
});
function compressImage(base64Data, maxWidth = 800, quality = 0.8) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => {
      const canvas = document.createElement('canvas');
      let width = img.width, height = img.height;
      if (width > maxWidth) { height = (height * maxWidth) / width; width = maxWidth; }
      canvas.width = width; canvas.height = height;
      canvas.getContext('2d').drawImage(img, 0, 0, width, height);
      resolve(canvas.toDataURL('image/jpeg', quality));
    };
    img.src = base64Data;
  });
}
function checkRestrictedSite() {
  const url = document.getElementById('newUrl').value.trim();
  const restricted = ['twitter.com', 'x.com', 'instagram.com', 'facebook.com', 'linkedin.com'];
  const isRestricted = restricted.some(site => url.includes(site));
  document.getElementById('restrictedSitePrompt').style.display = isRestricted ? 'block' : 'none';
}

function handleLinkScreenshot(e) {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    pendingLinkScreenshot = ev.target.result;
    document.getElementById('linkScreenshotImg').src = ev.target.result;
    document.getElementById('linkScreenshotPreview').style.display = 'block';
    document.getElementById('uploadScreenshotPrompt').style.display = 'none';
  };
  reader.readAsDataURL(file);
}

function removeLinkScreenshot(e) {
  e.stopPropagation();
  pendingLinkScreenshot = null;
  document.getElementById('linkScreenshotPreview').style.display = 'none';
  document.getElementById('uploadScreenshotPrompt').style.display = 'block';
}
// ============== MOBILE DETECTION & ADJUSTMENTS ==============
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
const isTouchDevice = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
isMobileDevice = isMobile; // Store globally for runtime checks

// Adjust double-click timing for mobile (more forgiving)
if (isMobile || isTouchDevice) {
  const originalHandleBubbleClick = handleBubbleClick;
  handleBubbleClick = function(id, event) {
    event.stopPropagation();
    const now = Date.now();
    
    // Use 500ms threshold on mobile instead of 300ms
    if (lastClickId === id && now - lastClickTime < 500) {
      handleBubbleOpen(id, event);
      lastClickTime = 0;
      lastClickId = null;
      return;
    }
    
    lastClickTime = now;
    lastClickId = id;
    selectBubble(id);
  };
}

// Reduce particle count on mobile for performance
if (isMobile) {
  const originalCreateBackgroundEffects = createBackgroundEffects;
  createBackgroundEffects = function() {
    const canvas = document.getElementById('discoverCanvas');
    if (!canvas) return;
    
    // Remove existing effects
    canvas.querySelectorAll('.star-field, .ambient-particles').forEach(el => el.remove());
    
    // Reduced star field (40 instead of 100)
    const starField = document.createElement('div');
    starField.className = 'star-field';
    
    for (let i = 0; i < 40; i++) {
      const star = document.createElement('div');
      star.className = 'star';
      star.style.left = `${Math.random() * 100}%`;
      star.style.top = `${Math.random() * 100}%`;
      star.style.setProperty('--duration', `${3 + Math.random() * 5}s`);
      star.style.setProperty('--opacity', `${0.3 + Math.random() * 0.5}`);
      starField.appendChild(star);
    }
    
    canvas.insertBefore(starField, canvas.firstChild);
    
    // Reduced ambient particles (8 instead of 20)
    const particles = document.createElement('div');
    particles.className = 'ambient-particles';
    
    const particleColors = ['#6366f1', '#8b5cf6', '#ec4899', '#06b6d4', '#10b981'];
    
    for (let i = 0; i < 8; i++) {
      const particle = document.createElement('div');
      particle.className = 'particle';
      particle.style.left = `${Math.random() * 100}%`;
      particle.style.top = `${Math.random() * 100}%`;
      particle.style.width = `${4 + Math.random() * 8}px`;
      particle.style.height = particle.style.width;
      particle.style.background = particleColors[Math.floor(Math.random() * particleColors.length)];
      particle.style.setProperty('--duration', `${15 + Math.random() * 25}s`);
      particle.style.setProperty('--dx', `${(Math.random() - 0.5) * 80}px`);
      particle.style.setProperty('--dy', `${(Math.random() - 0.5) * 80}px`);
      particles.appendChild(particle);
    }
    
    canvas.insertBefore(particles, canvas.firstChild);
  };
}

// Disable magnetic hover effect on touch devices
if (isTouchDevice) {
  handleBubbleHover = function(id, isEntering) {
    isAnyCardHovered = isEntering;
    hoveredBubbleId = isEntering ? id : null;
  };
}

// Prevent pull-to-refresh when panning in Discover
document.addEventListener('touchmove', function(e) {
  if (document.getElementById('discoverView')?.classList.contains('active')) {
    if (isDraggingCanvas) {
      e.preventDefault();
    }
  }
}, { passive: false });

// Orientation change handler
window.addEventListener('orientationchange', function() {
  setTimeout(function() {
    if (document.getElementById('discoverView')?.classList.contains('active')) {
      layoutCelestialSystem();
      renderBubbles();
    }
  }, 100);
});

console.log(' Mobile mode:', isMobile, '| Touch device:', isTouchDevice);
// ============== INIT ==============
async function init() {
  await initDB();
  await loadCards();
  await initSupabase();
  
  // Default to Discover view after a brief moment for everything to load
  setTimeout(() => {
    openDiscover();
  }, 300);
  
  // Refresh session when user returns to the tab
  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && supabaseClient) {
      console.log(' Tab became visible, checking session...');
      const { data: { session } } = await supabaseClient.auth.getSession();
      
      if (session && !currentUser) {
        // Session exists but we lost the user reference
        currentUser = session.user;
        if (!cloudSyncEnabled) {
          initCloudSync();
        }
        console.log(' Session restored on tab focus');
      } else if (!session && currentUser) {
        // Session was invalidated elsewhere
        currentUser = null;
        cloudSyncEnabled = false;
        console.log(' Session expired');
      }
    }
  });
}
init();
</script>
</body>
</html>
  
  
